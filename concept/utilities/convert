#!/usr/bin/env bash

# This file is part of COùòïCEPT, the cosmological ùòï-body code in Python.
# Copyright ¬© 2015-2016 Jeppe Mosgaard Dakin.
#
# COùòïCEPT is free software: You can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# COùòïCEPT is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with COùòïCEPT. If not, see http://www.gnu.org/licenses/
#
# The auther of COùòïCEPT can be contacted at dakin(at)phys.au.dk
# The latest version of COùòïCEPT is available at
# https://github.com/jmd-dk/concept/



# This utility can convert between different types of snapshots,
# and even make changes to the global parameters and component attributes.
# You can run this file directly as
# utilities/convert path
# or invoke it via the concept script as
# ./concept --util convert path
# In both cases, path is the path to a snapshot file
# or a directory containing snapshot files.



# Absolute paths to this file and its directory
this_file="$(readlink -f "${BASH_SOURCE[0]}")"
this_dir="$(dirname "${this_file}")"

# Source the concept script
source "${this_dir}/../concept"

# Set up error trapping
ctrl_c()
{
    trap : 0
    exit 2
}
abort()
{
    colorprint "An error occurred while using the \"$(basename ${this_file})\" utility!" "red"
    exit 1
}
if [ "${called_from_concept}" == "True" ]; then
    trap 'ctrl_c' SIGINT
    trap 'abort' EXIT
    set -e
fi

# Use Python's argparse module to handle command-line arguments
args=$("${python}" -c "
import argparse, sys
# Setup command-line arguments
parser = argparse.ArgumentParser(prog='$(basename ${this_file})',
                                 description='Run the COùòïCEPT $(basename ${this_file}) utility')
parser.add_argument('path',
                    help='path to snapshot or directory of snapshots',
                    )
parser.add_argument('attributes',
                    nargs='*',
                    help='space-separated list of global parameters and component attributes',
                    )
# Enables Python to write directly to screen (stderr)
# in case of help request.
stdout_copy = sys.stdout
sys.stdout = sys.stderr
# Now do the actual argument parsing,
# including writing out the help message.
if '${called_from_concept}' == 'True':
    # Called from concept - Through exception on illegal args
    args = parser.parse_args()
else:
    # Called directly - Allow what appears to be illegal args
    # (these might be known to the concept script).
    args, unknown_args = parser.parse_known_args()
# Reset stdout
sys.stdout = stdout_copy
# Print out the arguments.
# These will be captured in the Bash 'args' variable.
print(  ' argparse_finished=yes'
      + '; path=\"{}\"'.format(args.path)
      + '; attributes=\"{}\"'.format(args.attributes)
      )
" "$@")
#       + '; representation=\"{}\"'.format({r[:r.index('=')]: r[(r.index('=') + 1):]
#                                          for r in args.representation})  # Python dict
# Evaluate the handled arguments into this scope
eval "${args}"
# Exit if argparse exited without finishing
if [ "${argparse_finished}" != "yes" ]; then
    trap : 0
    exit 0
fi

# If not called indirectly through the concept script,
# call the concept script now.
if [ "${called_from_concept}" != "True" ]; then
    "${this_dir}/../concept" --util "${this_file}" "$@"
    trap : 0
    exit 0
fi

# If no parameterfile is supplied,
# use the one that goes along with this utility.
params_given="True"
if [ "${params}" == "None" ]; then
    params="${this_file}.params"
    params_given="False"
fi

# Convert to absolute path
path="$(absolute_path "${path}" "${workdir}")"

# Find snapshots in the path
info="$("${concept}" --pure-python --util info "${path}")"
snapshot_filenames_fmt="$(echo "${info}" | grep -x Information.* | awk '{print $3}')"
# Remove escape sequence from snapshot filenames
snapshot_filenames=""
snapshot_filenames_tuple=""
for snapshot_filename in ${snapshot_filenames_fmt}; do
    snapshot_filename="$(${python} -B -c "import re;                                             \
                                          print('\"{}\"'.format(re.search('\"(.*?)\"',           \
                                                                          '${snapshot_filename}' \
                                                                          ).group(1)))")"
    if [ -z "${snapshot_filenames}" ]; then
        snapshot_filenames="${snapshot_filename}"
        snapshot_filenames_tuple="${snapshot_filename}, "
    else
        snapshot_filenames="${snapshot_filenames}
${snapshot_filename}"
    snapshot_filenames_tuple="${snapshot_filenames_tuple} ${snapshot_filename}, "
    fi
done
snapshot_filenames_tuple="(${snapshot_filenames_tuple})"

# Print out which snapshots will be converted
N_snapshots="$(echo "${snapshot_filenames}" | wc -l)"
if [ ${N_snapshots} == 1 ]; then
    echo "The following snapshot will be converted:"
else
    echo "The following snapshots will be converted:"
fi
echo "${snapshot_filenames}"

# Make temporary parameter file with every information needed
printf "special_params = {
    'special':            '$(basename ${this_file})',
    'params_given':       ${params_given},
    'attributes':         ${attributes},
    'snapshot_filenames': ${snapshot_filenames_tuple},
                  }
$(cat "${params}")
" > "${this_file}.params.full"
# Run COùòïCEPT to perform the convertion
"${concept}" -m "${main}"                  \
             -n  ${nprocs}                 \
             -p "${this_file}.params.full" \
             -q "${queue}"                 \
             -w "${walltime}"              \
             ${local_flag} ${pure_python_flag}

# Cleanup
rm "${this_file}.params.full"

# Exit gracefully
colorprint "$(basename ${this_file}) utility ran successfully" "green"
trap : 0

