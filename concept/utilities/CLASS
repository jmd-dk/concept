#!/usr/bin/env bash

# This file is part of COð˜•CEPT, the cosmological ð˜•-body code in Python.
# Copyright Â© 2015â€“2018 Jeppe Mosgaard Dakin.
#
# COð˜•CEPT is free software: You can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# COð˜•CEPT is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with COð˜•CEPT. If not, see http://www.gnu.org/licenses/
#
# The author of COð˜•CEPT can be contacted at dakin(at)phys.au.dk
# The latest version of COð˜•CEPT is available at
# https://github.com/jmd-dk/concept/



# This utility will save the processed CLASS output
# (background and perturbations) to disk.
# You can run this file directly as
# utilities/CLASS
# or invoke it via the concept script as
# ./concept -u CLASS
# The saved CLASS data will be that which is necessary
# to realize the components given by the
# initial_conditionsto parameter.



# Absolute paths to this file and its directory
this_file="$(readlink -f "${BASH_SOURCE[0]}")"
this_dir="$(dirname "${this_file}")"

# Source the concept script
source "${this_dir}/../concept"

# Set up error trapping
ctrl_c(){
    trap : 0
    exit 2
}
abort(){
    exit_code=$?
    colorprint "An error occurred while using the \"$(basename "${this_file}")\" utility!" "red"
    exit ${exit_code}
}
if [ "${called_from_concept}" == "True" ]; then
    trap 'ctrl_c' SIGINT
    trap 'abort' EXIT
    set -e
fi

# Use Python's argparse module to handle command-line arguments
argparse_finished="no"
args=$("${python}" -B -c "
import argparse, sys
# Setup command-line arguments
parser = argparse.ArgumentParser(prog='$(basename "${this_file}")',
                                 description='Run the COð˜•CEPT $(basename "${this_file}") utility')
parser.add_argument(
    '--max_a_values',
    default='np.inf',
    help='maximum number of a values in the tabulated perturbations',
)
parser.add_argument(
    '--gauge',
    default='N-body',
    help='gauge of perturbations. Should be one of N-body (default), synchronous or Newtonian.',
)
# Enables Python to write directly to screen (stderr)
# in case of help request.
stdout_copy = sys.stdout
sys.stdout = sys.stderr
# Now do the actual argument parsing,
# including writing out the help message.
if '${called_from_concept}' == 'True':
    # Called from concept - Throw exception on illegal args
    args = parser.parse_args()
else:
    # Called directly - Allow what appears to be illegal args
    # (these might be known to the concept script).
    args, unknown_args = parser.parse_known_args()
# Reset stdout
sys.stdout = stdout_copy
# Print out the arguments.
# These will be captured in the Bash 'args' variable.
print('argparse_finished=yes')
print(f'max_a_values={args.max_a_values}')
print(f'gauge={args.gauge}')
" "$@" || :)
# Evaluate the handled arguments into this scope
eval "${args}"
# Exit if argparse exited without finishing
if [ "${argparse_finished}" != "yes" ]; then
    trap : 0
    exit 0
fi

# If not called indirectly through the concept script,
# call the concept script now.
if [ "${called_from_concept}" != "True" ]; then
    "${concept}" -u "${this_file}" "$@"
    trap : 0
    exit 0
fi

# If no parameter file is supplied,
# use the one that goes along with this utility.
if [ "${params}" == "None" ]; then
    params="${this_file}.params"
fi

# Make temporary parameter file with every information needed
mkdir -p "${this_dir}/params"
params_filename="${this_dir}/params/$(basename "${this_file}").params"
printf "
# The special_params dict, specifying details of the utility run
special_params = {
    'special'     : '$(basename "${this_file}")',
    'max_a_values': '${max_a_values}',
    'gauge'       : '${gauge}',
}
# Parameter values which should always be used when running this utility
special_params['keep_class_extra_background'] = True
# Set the path to the parameter file to be the path to the actual
# parameter file specified by the user, not this autogenerated
# parameter file.
params_path_ori = paths['params']
paths['params'] = '${params}'
###################
# User parameters #
###################
$(cat "${params}")
##########################
# End of user parameters #
##########################
# Reinsert original path to the parameter file
paths['params'] = params_path_ori
" > "${params_filename}"

# Run COð˜•CEPT to produce the CLASS output.
# Capture the jobid and exit code.
exec 4>&1
jobid_and_exit_code="$(                \
    "${concept}"                       \
        -m "${main}"                   \
        -n ${nprocs}                   \
        -p "${params_filename}"        \
        -q "${queue}"                  \
        -w "${walltime}"               \
        --memory ${memory}             \
        ${interactive_flag}            \
        ${local_flag}                  \
        ${no_optimization_flag}        \
        ${no_watch_flag}               \
        ${pure_python_flag}            \
        ${unsafe_build_flag}           \
    | tee >(cat - >&4)                 \
    | grep "Log file"                  \
    | head -n 1                        \
    ; echo "exit_code${PIPESTATUS[0]}" \

)"
exec 4>&-
exit_code="$("${python}" -B -c                                                              \
    "import re; print(re.search(r'exit_code(\d+)', '''${jobid_and_exit_code}''').group(1))" \
    2>/dev/null)" || :
if [ -z "${exit_code}" ]; then
    colorprint "Error capturing exit code" "red"
    exit 1
elif [ ${exit_code} != 0 ]; then
    exit ${exit_code}
fi
jobid="$("${python}" -B -c                                                                  \
    "import re; print(re.search(r'(/|^Job )(\d+)', '''${jobid_and_exit_code}''').group(2))" \
    2>/dev/null)" || :

# Exit gracefully
echo
if [ "${remote}" == "False" ] || [ "${no_watch}" == "False" ]; then
    if [ -z "${jobid}" ]; then
        colorprint "Error capturing jobid from output" "red"
        exit 1
    fi
    if [ -f "${logs_dir}/${jobid}_err" ]; then
        echo "$(basename "${this_file}") utility finished"
    else
        colorprint "$(basename "${this_file}") utility finished successfully" "green"
    fi
else
    echo "$(basename "${this_file}") utility finished. \
Check the submitted job for results."
fi
trap : 0
