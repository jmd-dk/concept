#!/usr/bin/env bash

# This file is part of COð˜•CEPT, the cosmological ð˜•-body code in Python.
# Copyright Â© 2015â€“2020 Jeppe Mosgaard Dakin.
#
# COð˜•CEPT is free software: You can redistribute it and/or modifypath
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# COð˜•CEPT is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with COð˜•CEPT. If not, see http://www.gnu.org/licenses/
#
# The author of COð˜•CEPT can be contacted at dakin(at)phys.au.dk
# The latest version of COð˜•CEPT is available at
# https://github.com/jmd-dk/concept/



# Help text which gets printed if invoked with -h or --help.
help_text='This script downloads and installs the COð˜•CEPT code with all its
dependencies.

Below you will find a short description of how to run this script.
This is more thoroughly documented in the COð˜•CEPT documentation:
https://jmd-dk.github.io/concept/installation.html

If run without an argument, this script will prompt for an
installation directory. Alternatively, this directory can be passed as
an argument. Everything will be installed within this directory.

Options taken by this script:
  -h, --help   Show this help message and exit.
  -t, --tests  Test the various dependency programs after their individual
               installations. COð˜•CEPT itself will similarly be tested.
               On failure (fatal or non-fatal) of any test, a log file of the
               test output will be placed in the installation subdirectory of
               the given program. Any test failures will be reported at the
               end of the entire installation process.
  -y, --yes    Accept default options on future quiries. Currently these
               include only the system-wide installations of system
               dependencies (e.g. gcc), should they be missing.
               Note that this require root access.
  --fix-ssh    Set up the ~/.ssh directory so that it allows for password-less
               SSH login between nodes. This may be needed in order to run
               multi-node MPI computations on clusters.
               The original state of the ~/.ssh directory will be backed up.
               Note that this option will perform the changes to ~/.ssh only;
               no actual installation will take place.

The full invocation signature of this script thus looks like
  /path/to/installer [/path/to/concept] [-t] [-y]
or
  /path/to/installer --fix-ssh
where brackets indicate optional arguments.

The system dependencies mentioned above consist of the following
(GNU implementations, specifically):
  - awk
  - gcc
  - g++
  - gfortran
  - grep
  - gzip
  - make
  - sed
  - tar
  - wget
  - glibc
  - as and ld
  - Linux headers
If any of these are missing, an attempt will be made to locate the
package manager on the system. If successful, you will be prompted to install
the missing system dependency, which will require root access.

The only system dependencies needed but not installed are the GNU core
utilities and bash. This script (and others used in COð˜•CEPT) should be
compatible with bash version 3.0 or later.

The programs which will be installed into the specified installation
directory consist of the following and will be installed in order:
  - zlib     (needed by libpng, HDF5 and Python)
  - libpng   (needed by matplotlib)
  - GSL
  - Perl     (needed by OpenSSL, OpenBLAS and MPICH/OpenMPI)
  - MPICH/OpenMPI
  - HDF5
  - FFTW
  - FreeType (needed by matplotlib)
  - ncurses  (needed by _curses, which is needed by blessings)
  - OpenSSL  (needed by pip)
  - libffi   (needed by _ctypes, which is needed by pip)
  - OpenBLAS (needed by SciPy and also used by NumPy)
  - Python, with the following packages (together with their own Python
    package dependencies):
      - pip, setuptools & wheel (if any of the below)
      - Blessings
      - Cython
      - CythonGSL
      - pytest (needed by NumPy and SciPy if running with tests)
      - NumPy
      - SciPy
      - Matplotlib
      - MPI4Py
      - H5Py
      - Sphinx
      - sphinx_copybutton
      - sphinx_rtd_theme
      - sphinx_tabs
  - COð˜•CEPT
  - CLASS
  - FFTW 2 (needed by GADGET)
  - GADGET

Due to the numerosity of the above list, the installation process will take
about an hour or two on modern hardware. The installation time depend strongly
on whether make is allowed to build in parallel or not. When running locally
(i.e. not over SSH), the default is to build in parallel using all available
CPU cores. Conversely, when running remotely the default is to build serially.
You can overwrite these defaults by setting the `make_jobs`
environment variable. E.g. to build in parallel using up to 4 CPU cores,
invoke this script as
  make_jobs="-j 4" /path/to/installer [/path/to/concept] [-t] [-y]

The installation time is significantly increased when invoked with -t.
Note that the Python test suite will be run even when invoked without -t,
as this is done as part of the profile guided optimization used to make
the resultant Python interpreter faster.

By default, any pre-installed software on the list above will be ignored.
No conflicts should come of this. Should you still wish COð˜•CEPT to use one such
pre-installed component, you can declare its directory path through the
`programname_dir` environment variable.
E.g. to use a pre-installedgsl library:
  gsl_dir=/path/to/gsl /path/to/installer [/path/to/concept] [-t] [-y]
The set of such environment variables correspond to the program names
above (using lowercase only), except for MPICH/OpenMPI and OpenBLAS, which are
just mpi_dir and blas_dir, respectively, as the specific MPI and BLAS
implementation does not matter.

When installing COð˜•CEPT on a cluster, it is often preferable to make use of an
already installed MPI library (MPI standard 3, any implementation should do),
as this is (hopefully) properly configured with e.g. InfiniBand, which may not
be the case for the MPI installation produced by this script.
Thus on clusters it is adviced to use
  mpi_dir=/path/to/mpi /path/to/installer [/path/to/concept] [-t] [-y]
If you have /path/to/mpi/bin properly loaded into your PATH,
you can get by without specifying the MPI path explicitly using
  mpi_dir=$(which mpicc) /path/to/installer [/path/to/concept] [-t] [-y]
(Note that $(which mpicc) results in /path/to/mpi/bin/mpicc, not /path/to/mpi.
Though both are valid in this case,
generally you must specify precisely programname_dir=/path/to/programname.)

When not using a pre-installed MPI (i.e. when mpi_dir is not specified),
you may specify which MPI implementation to install --- either MPICH
or OpenMPI --- by setting the `mpi` environment variable to "mpich"
or "openmpi", respectively. E.g.
  mpi=openmpi /path/to/installer [/path/to/concept] [-t] [-y]
The default is MPICH.

Should you choose to use a pre-installed Python distribution
(by setting the python_dir variable), any missing Python packages
will be installed in this distribution. Pre-installed Python packages
will not be touched; e.g. if the installer wishes to install NumPy
1.10.4, but 1.10.3 is already installed, the package will not be
updated. If you want such Python package updates (or downgrades),
set the `pythonpackagename_install` environment variable to "True".
E.g. to overwrite a pre-installed NumPy package:
  numpy_install=True python_dir=/path/to/python /path/to/installer
If you choose to use a pre-installed Python distribution, it is your
responsibility that pip is installed as part of this distribution.
Also, if the blessings package is not pre-installed in the Python
distribution, Python should at least be compiled with the ncurses
library.

Should you choose to use a pre-installed GADGET (by setting the gadget_dir
variable), note that this must be placed in a directory to which you have
write (as well as read and execute, naturally) permissions and that COð˜•CEPT
will make changes to the source files of GADGET during some tests.

Should you wish to install a specific version of some dependency
program, Python package or COð˜•CEPT itself, simply set the environment
variable `programname_version` when invoking the installer.
E.g. to install GSL 2.4:
  gsl_version=2.4 /path/to/installer [/path/to/concept] [-t] [-y]

When installing in a complicated environment with several available compilers
(typical for clusters) the installation time can be up to several times longer,
as for each program the installer tries out different compilers
and other options until a working configuration is found.
The available compilers located on the system will be printed out at the
beginning, in the precedence (order) of which they will be tried out.
You can choose this order yourself by setting the compiler_precedence
variable. To e.g. first try out Intel compilers and then GNU compilers:
  compiler_precedence="intel gnu" /path/to/installer [/path/to/concept] [-t] [-y]
All other compilers located will then be tried out after GNU. The complete
list of compilers in order of default precedence is "specified_mpi",
"default", "gnu", "clang", "mpi", "intel", "cray", "portland", "generic",
"unset". Here, "specified_mpi" means the MPI compiler provided by the MPI
library specified via mpi_dir, "default" means that we do not explicitly
alter the environment to specify any compiler (and so if e.g. $CC is defined,
this will probably be used), "mpi" means any MPI compiler (e.g. mpicc)
found on the system, "generic" refers to compilers not fitting into any
of the other categories (e.g. cc) and "unset" means that we explicitly
unset e.g. $CC.

Logs of the installation process are written to install_log (stdout)
and install_log_err (stderr) in the top installation directory.
Should the installation process end prematurely (e.g. due to network failure),
simply rerun this script with the same arguments and environment variables
as originally, and it will pick up the installation from where it left off.

See https://github.com/jmd-dk/concept/ for further information.
'
# Print help text and exit, if help is requested
for var in "$@"; do
    if     [ "${var}" ==  "-h"    ] \
        || [ "${var}" == "--h"    ] \
        || [ "${var}" == "--he"   ] \
        || [ "${var}" == "--hel"  ] \
        || [ "${var}" == "--help" ]; then
        printf "${help_text}"
        exit 0
    fi
done

# If invoked directly from the web (e.g. via wget), a small pause
# ensures that the print outs will not corrupt the loading bar.
sleep 2
# Newer versions of wget saves a copy of the printout when using the
# -O- option to a file called wget-log[.x], x âˆˆ â„•. Remove any such log
# produced from invoking this script via wget.
wget_log_maxage=300
for filename in *; do
    if [ ! -f "${filename}" ] || [[ "${filename}" != "wget-log"* ]]; then
        continue
    fi
    fileage=$(($(date +%s) - $(stat -c '%Y' "${filename}")))
    if [ ${fileage} -lt ${wget_log_maxage} ]; then
        rm -f "${filename}" || :
    fi
done



##################
# Specifications #
##################
# The MPI implementation to use
mpi_lower="$(echo "${mpi}" | tr '[:upper:]' '[:lower:]')"
if [ -z "${mpi}" ]; then
    # If mpi_dir is specified,
    # try to determine whether MPICH or OpenMPI is used.
    if [ -n "${mpi_dir}" ]; then
        if [ -f "${mpi_dir}/bin/mpichversion" ]; then
            mpi="mpich"
        elif [ -f "${mpi_dir}/bin/ompi_info" ]; then
            mpi="openmpi"
        else
            mpi="unknown"
        fi
    else
        # Use MPICH by default
        mpi="mpich"
    fi
elif [ "${mpi_lower}" != "mpich" ] && [ "${mpi_lower}" != "openmpi" ]; then
    echo "Specified MPI implementation mpi=\"${mpi}\" not recognized.
Will use MPICH" >&2
    mpi="mpich"
fi
mpi="$(echo "${mpi}" | tr '[:upper:]' '[:lower:]')"
# This function sets the variables "name_dir" (if not set already)
# and "name_preinstalled".
set_dir(){
    # Arguments: Program name, install directory.
    # Set "name_preinstalled" if "name_dir" is already set
    eval "${1}_preinstalled=True"
    eval "[ -n \"\${${1}_dir}\" ] || ${1}_preinstalled=\"False\""
    # Set "name_dir" if "name_dir" is not already set
    # or "name" should be installed.
    eval "[ -n \"\${${1}_dir}\" ] || ${1}_dir=\"${2}\""
    eval "(! (   [ \"\${${1}_install}\"      == \"False\" ] \
              && [ \"\${${1}_preinstalled}\" == \"False\" ])) || ${1}_dir=\"\""
}
# The install_explicit_only environment variable, when set to "True",
# disables all implicit installations.
if [ "${install_explicit_only}" == "True" ]; then
    for progname in "concept"           \
                    "blas"              \
                    "class"             \
                    "fftw"              \
                    "fftw_for_gadget"   \
                    "freetype"          \
                    "gadget"            \
                    "gsl"               \
                    "hdf5"              \
                    "libffi"            \
                    "libpng"            \
                    "mpi"               \
                    "ncurses"           \
                    "openssl"           \
                    "perl"              \
                    "python"            \
                    "zlib"              \
                    "blessings"         \
                    "cython"            \
                    "cythongsl"         \
                    "h5py"              \
                    "matplotlib"        \
                    "mpi4py"            \
                    "numpy"             \
                    "pytest"            \
                    "scipy"             \
                    "sphinx"            \
                    "sphinx_copybutton" \
                    "sphinx_rtd_theme"  \
                    "sphinx_tabs"       \
    ; do
        eval "[ -n \"\${${progname}_install}\" ] || ${progname}_install=\"False\""
    done
fi
# Specification of paths. The substring "__top_dir__"
# will later be replaced with the top level directory.
set_dir "class"           "__top_dir__/class"
set_dir "concept"         "__top_dir__/concept"
set_dir "fftw"            "__top_dir__/fftw"
set_dir "freetype"        "__top_dir__/freetype"
set_dir "gadget"          "__top_dir__/gadget"
set_dir "fftw_for_gadget" "${gadget_dir}/fftw"
set_dir "gsl"             "__top_dir__/gsl"
set_dir "hdf5"            "__top_dir__/hdf5"
set_dir "libpng"          "__top_dir__/libpng"
set_dir "mpi"             "__top_dir__/${mpi}"
set_dir "blas"            "__top_dir__/openblas"
set_dir "perl"            "__top_dir__/perl"
set_dir "python"          "__top_dir__/python"
set_dir "ncurses"         "${python_dir}"
set_dir "openssl"         "${python_dir}"
set_dir "libffi"          "${python_dir}"
set_dir "zlib"            "__top_dir__/zlib"
log="__top_dir__/install_log"
env_file="__top_dir__/.env"
paths_file="__top_dir__/.paths"

# This function sets the variable "name_version" if not set already.
# For preinstalled software, set "name_version" to "pre-installed".
# If a third argument is given, this is the version to fall back to,
# in case of unsuccessful retrievel of the link to the first version.
set_version(){
    # Arguments: Program name, version, [fallback version]
    eval "[ -z \"\${${1}_version}\" ] || ${1}_version_specifiedbyuser=\"True\""
    eval "[ -n \"\${${1}_version}\" ] || ${1}_version=\"${2}\""
    eval "[ \"\${${1}_preinstalled}\" != \"True\" ] || ${1}_version=\"pre-installed\""
    if [ -n "${3}" ]; then
        eval "${1}_version_fallback=\"${3}\""
    fi
}
# Specification of software versions.
# The rightmost column are fallbacks, which will be used if the
# link to the version given by the middle column is broken.
# In case of COð˜•CEPT and CLASS, possible versions are the corresponding
# GitHub branches and releases.
set_version "concept"           "master"
set_version "blas"              "0.3.7"   "0.3.7"
set_version "class"             "2.7.2"
set_version "fftw"              "3.3.8"   "3.3.8"
set_version "fftw_for_gadget"   "2.1.5"   "2.1.5"   # Do not change
set_version "freetype"          "2.10.1"  "2.10.1"
set_version "gadget"            "2.0.7"             # Do not change
set_version "gsl"               "2.6"     "2.6"
set_version "hdf5"              "1.10.6"  "1.10.6"
set_version "libffi"            "3.3"     "3.3"
set_version "libpng"            "1.6.37"  "1.6.37"
if [ "${mpi}" == "mpich" ]; then
    set_version "mpi"           "3.3.2"   "3.3.2"
elif [ "${mpi}" == "openmpi" ]; then
    set_version "mpi"           "4.0.2"
fi
set_version "ncurses"           "6.1"     "6.1"
set_version "openssl"           "1.1.1d"  "1.1.1d"
set_version "perl"              "5.30.1"
set_version "python"            "3.8.1"
set_version "zlib"              "1.2.11"  "1.2.11"
# Python packages
set_version "blessings"         "1.7"
set_version "cython"            "0.29.14"
set_version "cythongsl"         "0.2.2"
set_version "h5py"              "2.10.0"
set_version "matplotlib"        "3.1.3"
set_version "mpi4py"            "3.0.3"
set_version "numpy"             "1.18.1"
set_version "pip"               "20.0.2"
set_version "pytest"            "5.3.5"
set_version "scipy"             "1.4.1"
set_version "setuptools"        "45.2.0"
set_version "sphinx"            "2.3.1"
set_version "sphinx_copybutton" "0.2.8"
set_version "sphinx_rtd_theme"  "0.4.3"
set_version "sphinx_tabs"       "1.1.13"
set_version "wheel"             "0.34.2"
# Note that the versions may be changed further down due to known
# compatibility issues between specific versions of the above programs
# and specific versions of system dependencies.



#################
# Initial setup #
#################
# Set up error trapping
ctrl_c(){
    current_step="aborting"
    sleep 0.5
    kill -9 -- -$$ > /dev/null 2>&1 || :
    exit 2
}
abort(){
    sleep 0.5
    kill -9 -- -$$ > /dev/null 2>&1 || :
    exit 1
}
trap 'ctrl_c' SIGINT
trap 'abort' EXIT
set -e

# Set sleep_time, the amount of seconds spend sleeping at various stages
sleep_time=10

# For the terminal to be able to print Unicode characters correctly,
# the terminal character set needs to be compatible. To ensure this,
# we set all locale settings to en_US.UTF-8.
export LC_ALL="en_US.UTF-8"
export LANG="en_US.UTF-8"
# Set the terminal if unset or broken
if [ -z "${TERM}" ] || [ "${TERM}" == "dumb" ]; then
    export TERM="linux"
fi

# ANSI/VT100 escape sequences
esc="\x1b"
# Text formatting
esc_normal="${esc}[0m"
esc_bold="${esc}[1m"
esc_italic="${esc}[3m"
esc_reverted="${esc}[7m"
esc_no_italic="${esc}[23m"
# The name of the program, nicely typesat
if [ -z "${esc_concept}" ]; then
    esc_concept="CO${esc_italic}N${esc_no_italic}CEPT"
else
    esc_concept="${esc_concept//\$\{esc_italic\}/${esc_italic}}"
    esc_concept="${esc_concept//\$\{esc_no_italic\}/${esc_no_italic}}"
fi

# Text colors
esc_red="${esc}[91m"
esc_green="${esc}[92m"
esc_yellow="${esc}[93m"
esc_blue="${esc}[94m"
# Cursor movement
esc_up="${esc}[1A"
esc_erase="${esc}[K"
# Special characters
en_quad="\xE2\x80\x80"
# Functions for pretty printing text
heading(){
    printf "\n${esc_bold}${esc_yellow}${1}${esc_normal}\n"
}
error(){
    printf "\n${esc_bold}${esc_red}${1}${esc_normal}\n" >&2
}

# Print out welcome message
if [ "${say_welcome}" != "False" ]; then
    heading "${esc_bold}${esc_yellow}This is the installation script for ${esc_concept},
the cosmological ${esc_italic}N${esc_no_italic}-body code in Python${esc_normal}"
fi

# Status control sequenses
status="initialization"
status_prefix="__new_status__="
status_prefix_length=${#status_prefix}
status_disable="disable"
status_enable="enable"
status_on="on"
status_off="off"
status_visible="${status_on}"
status_finish="finish_successfully"

# Backup of initial environment variables
env_var_names=(      \
    BLAS             \
    CC               \
    CFLAGS           \
    CPPFLAGS         \
    CXX              \
    CXXFLAGS         \
    F77              \
    F90              \
    F9X              \
    FC               \
    FCFLAGS          \
    FFLAGS           \
    HDF5_DIR         \
    HDF5_MPI         \
    LAPACK           \
    LD_LIBRARY_PATH  \
    LD_PRELOAD       \
    LDFLAGS          \
    LIBS             \
    MPICC            \
    MPILIBS          \
    PATH             \
    PERL             \
    PKG_CONFIG_PATH  \
    PNG_CFLAGS       \
    PNG_LIBS         \
    TMPDIR           \
    ZLIB_CFLAGS      \
    ZLIB_LIBS        \
    ZLIBLIB          \
    ZLIBINC          \
)
for env_var_name in "${env_var_names[@]}"; do
    # Save initial state (set/unset) of the environment variable
    if [ -n "$(eval "echo "\${${env_var_name}+x}"")" ]; then
        eval "${env_var_name}_set=\"True\""
    else
        eval "${env_var_name}_set=\"False\""
    fi
    # Save initial value of the environment variable
    eval "${env_var_name}_backup=\"\${${env_var_name}}\""
done
# Function that resets all above environment
# variables to their initial state.
reset_environment(){
    for env_var_name in "${env_var_names[@]}"; do
        eval "env_var_set=\"\${${env_var_name}_set}\""
        if [ "${env_var_set}" == "True" ]; then
            # env_var_name initially set
            eval "export ${env_var_name}=\"\${${env_var_name}_backup}\""
        else
            # env_var_name initially unset
            unset "${env_var_name}"
        fi
    done
}

# Set test_success variables
blas_test_success="True"
class_test_success="True"
concept_test_success="True"
fftw_test_success="True"
fftw_for_gadget_test_success="True"
freetype_test_success="True"
gadget_test_success="True"
gsl_test_success="True"
hdf5_test_success="True"
libffi_test_success="True"
libpng_test_success="True"
mpi_test_success="True"
ncurses_test_success="True"
openssl_test_success="True"
perl_test_success="True"
python_test_success="True"
zlib_test_success="True"
numpy_test_success="True"
scipy_test_success="True"

# Read in command line arguments
if [ -z "${do_tests}" ]; then
    do_tests="False"
fi
if [ -z "${yes_to_defaults}" ]; then
    yes_to_defaults="False"
fi
if [ -z "${fix_ssh}" ]; then
    fix_ssh="False"
fi
if [ -z "${top_dir_specified}" ]; then
    top_dir_specified="False"
fi
for var in "$@"; do
    # Strip command line argument for brackets, which may have been
    # adeed by users not familiar with this syntax for
    # specifying optional arguments.
    var="${var//\[/}"
    var="${var//\]/}"
    # Parse command line argument
    if     [ "${var}" ==  "-t"     ] \
        || [ "${var}" == "--t"     ] \
        || [ "${var}" == "--te"    ] \
        || [ "${var}" == "--tes"   ] \
        || [ "${var}" == "--test"  ] \
        || [ "${var}" == "--tests" ]; then
        do_tests="True"
    elif   [ "${var}" ==  "-y"   ] \
        || [ "${var}" == "--y"   ] \
        || [ "${var}" == "--ye"  ] \
        || [ "${var}" == "--yes" ]; then
        yes_to_defaults="True"
    elif   [ "${var}" == "--f"         ] \
        || [ "${var}" == "--fi"        ] \
        || [ "${var}" == "--fix"       ] \
        || [ "${var}" == "--fix-"      ] \
        || [ "${var}" == "--fix-s"     ] \
        || [ "${var}" == "--fix-ss"    ] \
        || [ "${var}" == "--fix-ssh"   ]; then
        fix_ssh="True"
    elif [ "${var}" == "--fast" ]; then
        # This is a deprecated option for skipping tests,
        # which is now the default. Allow it but do nothing.
        :
    elif [ "${top_dir_specified}" == "False" ]; then
        top_dir="${var}"
        top_dir_specified="True"
    else
        if [ "${var}" != "${top_dir}" ]; then
            error "Got command line argument \"${var}\", "\
"but the installation path is already set to \"${top_dir}\""
            exit 1
        fi
    fi
done

# Function for converting a path to its absolute form
initial_dir="$(pwd)"  # It is crucial that this line is before any cd
convert_to_abs_path(){
    # Arguments: path
    current_dir="$(pwd)"
    cd "${initial_dir}"
    # Places backslashes before spaces.
    # These are needed when expanding tilde, but they will not persist.
    abs_path="${1//[ ]/\\ }"
    # Expand tilde
    eval abs_path="${abs_path}"
    # Convert to absolute path
    abs_path=$(readlink -m "${abs_path}")
    cd "${current_dir}"
    echo "${abs_path}"
}

# Setup password-less SSH login between nodes (and exit), if requested
if [ "${fix_ssh}" == "True" ]; then
    # Move the preexisting ~/.ssh directory into a directory
    # ~/.ssh_backup/<date>,
    # with <date> the current time.
    if [ -d ~/".ssh" ]; then
        passwordless_ssh_timestamp="$(date)"
        passwordless_ssh_timestamp="${passwordless_ssh_timestamp// /-}"
        passwordless_ssh_backup_dir="$(convert_to_abs_path \
            "~/.ssh_backup/${passwordless_ssh_timestamp}")"
        mkdir -p ~/".ssh_backup/${passwordless_ssh_timestamp}"
        mv ~/".ssh" ~/".ssh_backup/${passwordless_ssh_timestamp}/"
        echo "The existing ~/.ssh directory has been moved to ${passwordless_ssh_backup_dir}/.ssh"
    fi
    mkdir -p ~/".ssh"
    # The type of encryption to use for the ssh keys.
    # Should be "dsa" or "rsa".
    key_type="rsa"
    # Generate a public/private key pair
    ssh-keygen -t "${key_type}" -N "" -f ~/".ssh/id_${key_type}" >/dev/null
    # Add public key to the list of keys allowed to log in
    cat ~/".ssh/id_${key_type}.pub" >> ~/".ssh/authorized_keys"
    cat ~/".ssh/id_${key_type}.pub" >> ~/".ssh/authorized_keys2"
    # Suppress future confirmation dialogs
    echo "Host *
  StrictHostKeyChecking no
  UserKnownHostsFile /dev/null
  LogLevel ERROR
" >> ~/".ssh/config"
    # Remove any previously known hosts (there should be none
    # as the ~/.ssh directory has just been created).
    rm -f "known_hosts"* 2>/dev/null || :
    # Set proper permissions in order for ssh
    # to allow password-less login.
    chmod go-w ~
    chmod 700 ~/".ssh"
    chmod 644 ~/".ssh/authorized_keys"
    chmod 644 ~/".ssh/authorized_keys2"
    chmod go-rwx ~/".ssh/config" || :
    chmod go-rwx ~/".ssh/id_${key_type}"
    chmod go+r ~/".ssh/id_${key_type}.pub"
    # Inform the user on this change
    printf "\nPassword-less ssh login between nodes has been configured\n"
    # Do not install COð˜•CEPT
    trap : 0
    exit 0
fi

# Function which prints the absolute path of a given command.
# If the command is not an executable file on the PATH but instead a
# known function, the input command is printed as is. If the command
# cannot be found at all, nothing is printed and an exit code of 1
# is returned.
get_command(){
    command_name="${1}"
    # Use the type builtin to locate the command
    local path="$(type "${command_name}" 2>/dev/null || :)"
    path="${path##* }"
    if [[ "${path}" == "/"* ]]; then
        # The command is a path
        path="$(readlink -f "${path}")"
        echo "${path}"
        return 0
    elif [ -n "${path}" ]; then
        # The command exists as a function
        echo "${command_name}"
        return 0
    fi
    # The command does not exist
    return 1
}

# This function should be called before any use of sudo and will cache
# the root password to the sudo_command variable. After this, instead of
# invoing sudo, invoke ${sudo_command} (using eval). This way, the root
# password has to be entered at most once.
sudo_command=""
build_sudo_command(){
    if [ -z "${sudo_command}" ]; then
        if get_command "sudo" >/dev/null; then
            if [ ${EUID} -eq 0 ]; then
                sudo_command="sudo"
            else
                sudo -k
                while :; do
                    read -s -p "[sudo] password for $(whoami): " sudo_password
                    echo
                    output="$(echo "${sudo_password}" | sudo -S echo hello 2>&1 || :)"
                    output="${output##* }"
                    if [ "${output}" == "hello" ]; then
                        break
                    fi
                    echo "Sorry, try again."
                done
                sudo_command="echo \"${sudo_password}\" | sudo -S"
                unset sudo_password
            fi
        else
            # No sudo command exist. Assume root privileges by default.
            sudo_command=""
        fi
    fi
}

# Creating top level directory (top_dir)
current_step="setup of top level directory"
if [ "${top_dir_specified}" == "False" ]; then
    printf "\nWhere should the ${esc_concept} code be installed?"
    read -p "$(echo $'\n> ')" -e top_dir
    if [ -z "${top_dir}" ]; then
        # The user hit enter without writing a path.
        # Install in current directory.
        top_dir="."
    fi
fi
top_dir_is_sane="True"
mkdir -p "${top_dir}" 2>/dev/null || top_dir_is_sane="False"
if [ "${top_dir_is_sane}" == "False" ]; then
    error "\nThe installation path \"${top_dir}\" cannot be created."
    exit 1
fi
top_dir="$(convert_to_abs_path "${top_dir}")"
printf "\nThe code will be installed in \"${top_dir}\"\n"
cd "${top_dir}"

# This directory may be created by the fix_path, use_mpi_compilers or
# use_specified_mpi_compilers functions, which use it to store symlinks
# to MPI library files.
mpi_symlinkdir="${top_dir}/.mpi_symlinks"

# Check whether system dependencies are installed and located on PATH
current_step="check for preinstalled system dependencies"
# Check for package manager and set package names
set_package_names(){
    # Arguments: Package name for awk, gcc, g++, gfortran, grep, gzip,
    # make, sed, tar, wget, glibc, as and ld, Linux headers.
    i=0
    for package in      \
        "awk"           \
        "gcc"           \
        "gxx"           \
        "gfortran"      \
        "grep"          \
        "gzip"          \
        "make"          \
        "sed"           \
        "tar"           \
        "wget"          \
        "glibc"         \
        "as_ld"         \
        "linux_headers" \
    ; do
        ((i += 1))
        eval "${package}_package=\${${i}}"
    done
}
set_package_manager_and_names(){
    # This function takes no arguments
    package_manager=""
    for pmanager in \
        "apt"       \
        "apt-get"   \
        "aptitude"  \
        "dnf"       \
        "yum"       \
        "zypper"    \
        "urpmi"     \
        "pacman"    \
        "eopkg"     \
        "emerge"    \
        "slackpkg"  \
        "apk"       \
    ; do
        if get_command "${pmanager}" >/dev/null; then
            # Package manager found
            package_manager="${pmanager}"
            # Package names
            case "${package_manager}" in
                "apt") install_command="${package_manager} install -y"
                    set_package_names               \
                        "gawk"                      \
                        "gcc"                       \
                        "g++"                       \
                        "gfortran"                  \
                        "grep"                      \
                        "gzip"                      \
                        "make"                      \
                        "sed"                       \
                        "tar"                       \
                        "wget"                      \
                        "libc6 libc6-dev"           \
                        "binutils"                  \
                        "linux-headers-$(uname -r)"
                    break
                    ;;
                "apt-get") install_command="${package_manager} -y install"
                    set_package_names               \
                        "gawk"                      \
                        "gcc"                       \
                        "g++"                       \
                        "gfortran"                  \
                        "grep"                      \
                        "gzip"                      \
                        "make"                      \
                        "sed"                       \
                        "tar"                       \
                        "wget"                      \
                        "libc6 libc6-dev"           \
                        "binutils"                  \
                        "linux-headers-$(uname -r)"
                    break
                    ;;
                "aptitude") install_command="${package_manager} -y install"
                    set_package_names               \
                        "gawk"                      \
                        "gcc"                       \
                        "g++"                       \
                        "gfortran"                  \
                        "grep"                      \
                        "gzip"                      \
                        "make"                      \
                        "sed"                       \
                        "tar"                       \
                        "wget"                      \
                        "libc6 libc6-dev"           \
                        "binutils"                  \
                        "linux-headers-$(uname -r)"
                    break
                    ;;
                "dnf") install_command="${package_manager} -y install"
                    set_package_names       \
                        "gawk"              \
                        "gcc"               \
                        "gcc-c++"           \
                        "gcc-gfortran"      \
                        "grep"              \
                        "gzip"              \
                        "make"              \
                        "sed"               \
                        "tar"               \
                        "wget"              \
                        "glibc glibc-devel" \
                        "binutils"          \
                        "kernel-headers"
                    break
                    ;;
                "yum") install_command="${package_manager} -y install"
                    set_package_names       \
                        "gawk"              \
                        "gcc"               \
                        "gcc-c++"           \
                        "gcc-gfortran"      \
                        "grep"              \
                        "gzip"              \
                        "make"              \
                        "sed"               \
                        "tar"               \
                        "wget"              \
                        "glibc glibc-devel" \
                        "binutils"          \
                        "kernel-headers"
                    break
                    ;;
                "zypper") install_command="${package_manager} -n install"
                    set_package_names          \
                        "gawk"                 \
                        "gcc"                  \
                        "gcc-c++"              \
                        "gcc-fortran"          \
                        "grep"                 \
                        "gzip"                 \
                        "make"                 \
                        "sed"                  \
                        "tar"                  \
                        "wget"                 \
                        "glibc glibc-devel"    \
                        "binutils"             \
                        "linux-kernel-headers"
                    break
                    ;;
                "urpmi") install_command="${package_manager} --auto"
                    set_package_names              \
                        "gawk"                     \
                        "gcc"                      \
                        "gcc-c++"                  \
                        "gcc-gfortran"             \
                        "grep"                     \
                        "gzip"                     \
                        "make"                     \
                        "sed"                      \
                        "tar"                      \
                        "wget"                     \
                        "glibc glibc-devel"        \
                        "binutils"                 \
                        "kernel-userspace-headers"
                    break
                    ;;
                "pacman") install_command="${package_manager} -S --noconfirm"
                    set_package_names   \
                        "gawk"          \
                        "gcc"           \
                        "gcc"           \
                        "gcc-fortran"   \
                        "grep"          \
                        "gzip"          \
                        "make"          \
                        "sed"           \
                        "tar"           \
                        "wget"          \
                        "glibc"         \
                        "binutils"      \
                        "linux-headers"
                    break
                    ;;
                "eopkg") install_command="${package_manager} install -y"
                    set_package_names       \
                        "gawk"              \
                        "gcc"               \
                        "g++"               \
                        "gfortran"          \
                        "grep"              \
                        "gzip"              \
                        "make"              \
                        "sed"               \
                        "tar"               \
                        "wget"              \
                        "glibc glibc-devel" \
                        "binutils"          \
                        "linux-headers"
                    break
                    ;;
                "emerge") install_command="${package_manager}"
                    set_package_names       \
                        "gawk"              \
                        "gcc"               \
                        "gcc"               \
                        "fortran"           \
                        "grep"              \
                        "gzip"              \
                        "make"              \
                        "sed"               \
                        "tar"               \
                        "wget"              \
                        "glibc"             \
                        "binutils"          \
                        "linux-headers"
                    break
                    ;;
                "slackpkg") install_command="${package_manager} install"
                    set_package_names       \
                        "gawk"              \
                        "gcc"               \
                        "gcc-g++"           \
                        "gcc-gfortran"      \
                        "grep"              \
                        "gzip"              \
                        "make"              \
                        "sed"               \
                        "tar"               \
                        "wget"              \
                        "glibc"             \
                        "binutils"          \
                        "kernel-headers"
                    break
                    ;;
                "apk") install_command="${package_manager} add"
                    set_package_names         \
                        "gawk"                \
                        "gcc"                 \
                        "g++"                 \
                        "gfortran"            \
                        "grep"                \
                        "gzip"                \
                        "make"                \
                        "sed"                 \
                        "tar"                 \
                        "wget"                \
                        "libc-utils libc-dev" \
                        "binutils"            \
                        "linux-headers"
                    break
                    ;;
            esac
            break
        fi
    done
}
set_package_manager_and_names
# Function for testing whether system dependencies are installed and
# located on PATH. For missing system dependencies, it will attempt to
# figure out the command to install it.
check_system_dependency(){
    # Arguments: Command, package name
    if ! get_command "${1}" >/dev/null; then
        # Package not installed
        if [ -n "${package_manager}" ]; then
            # Package manager found
            if [ "${yes_to_defaults}" == "True" ]; then
                echo "Auto installing '${1}'"
                build_sudo_command
                eval "${sudo_command} ${install_command} ${2}"
                printf "${1} successfully installed\n\n"
            else
                echo "Could not find '${1}'"
                echo "You can install it by typing:"
                if get_command "sudo" >/dev/null; then
                    printf "sudo "
                fi
                echo "${install_command} ${2}"
                while :; do
                    read -p "Run above command now? [Y/n] " yn
                    case "${yn}" in
                        [Yy]* ) build_sudo_command
                                eval "${sudo_command} ${install_command} ${2}"
                                printf "${1} successfully installed\n\n"
                                return
                                ;;
                        [Nn]* ) error "Terminated install due to missing component '${1}'"
                                exit 1
                                ;;
                        ""    ) build_sudo_command
                                eval "${sudo_command} ${install_command} ${2}"
                                printf "${1} successfully installed\n\n"
                                return
                                ;;
                        *     ) error "Terminated install due to missing component '${1}'"
                                exit 1
                                ;;
                    esac
                done
                exit 1
            fi
        else
            # No package manager found
            error "Error: Could not find '${1}'"
            exit 1
        fi
    fi
}
check_system_dependency "awk"      "${awk_package}"
check_system_dependency "gcc"      "${gcc_package}"
check_system_dependency "g++"      "${gxx_package}"
check_system_dependency "gfortran" "${gfortran_package}"
check_system_dependency "grep"     "${grep_package}"
check_system_dependency "gzip"     "${gzip_package}"
check_system_dependency "make"     "${make_package}"
check_system_dependency "sed"      "${sed_package}"
check_system_dependency "tar"      "${tar_package}"
check_system_dependency "wget"     "${wget_package}"

# Though gcc is now guaranteed to be installed,
# it may miss important components, which we check for here.
current_step="check of gcc components"
gcc_test(){
    # Arguments:
    #   - Name of gcc component
    #   - C source code to test
    #   - Expected output
    #   - Text to write if fail
    #   - Name of package to install if fail
    name="$1"
    C_source="$2"
    expected_output="$3"
    message="$4"
    package_name="$5"
    # Prepare for gcc test
    current_dir="$(pwd)"
    gcc_test_dir="${top_dir}/tmp/gcc_test"
    # Test compile and run
    for i in 0 1; do
        # Cleanup
        cd "${current_dir}"
        rm -rf "${gcc_test_dir}" || :
        mkdir -p "${gcc_test_dir}"
        # Write C source to file
        cd "${gcc_test_dir}"
        echo "${C_source}" > main.c
        # Compile
        gcc_test_success="True"
        gcc main.c -o main >/dev/null 2>&1 || gcc_test_success="False"
        if [ "${gcc_test_success}" == "True" ]; then
            # Run
            gcc_test_output="$(./main 2>&1)"
            if [ "${gcc_test_output}" != "${expected_output}" ]; then
                gcc_test_success="False"
            fi
        fi
        if [ "${gcc_test_success}" == "False" ]; then
            if [ $i -eq 0 ]; then
                # Test failed.
                # Prompt for installation of needed package.
                echo
                echo "${message}"
                if [ -z "${package_manager}" ]; then
                    # No package manager found
                    error "Error: Could not find any installed package manager"
                    exit 1
                fi
                if [ "${yes_to_defaults}" == "True" ]; then
                    echo "Auto installing ${name}"
                    eval "${install_command} ${package_name}"
                else
                    echo "To ensure that ${name} are installed, type:"
                    echo "${install_command} ${package_name}"
                    gcc_test_prompt(){
                        while :; do
                            read -p "Run above command now? [Y/n] " yn
                            case "${yn}" in
                                [Yy]* ) eval "${install_command} ${package_name}"
                                        return
                                        ;;
                                [Nn]* ) error \
                                            "Terminated install due to missing component: ${name}"
                                        exit 1
                                        ;;
                                ""    ) eval "${install_command} ${package_name}"
                                        return
                                        ;;
                                *     ) error \
                                            "Terminated install due to missing component: ${name}"
                                        exit 1
                                        ;;
                            esac
                        done
                        exit 1
                    }
                    gcc_test_prompt
                fi
                printf "${name} successfully installed\n\n"
            else
                # Test failed even after installing the needed package
                error "Terminated install due to gcc failing to \
properly compile \"${gcc_test_dir}/main.c\""
                exit 1
            fi
        fi
    done
    # Cleanup after test
    cd "${current_dir}"
    rm -rf "${gcc_test_dir}" || :
}
# Basic gcc test, checking for the standard library,
# the assembler and linker.
gcc_test                                                \
    "the gcc C standard library, assembler and linker"  \
    '
#include <stdio.h>
int main(void){
    printf("hello\n");
    return 0;
}
'                                                       \
    "hello"                                             \
    "gcc could not compile even a simple C program. \
We need to make sure that the gcc C standard library, \
as well as the assembler and linker are all installed." \
    "${glibc_package} ${as_ld_package}"
# Check for the Linux headers
gcc_test                                                \
    "the Linux headers"  \
    '
#include <linux/limits.h>
#include <stdio.h>
int main(void){
    printf("hello\n");
    return 0;
}
'                                                       \
    "hello"                                             \
    "gcc could not find the Linux headers. \
We need to make sure that these are installed."         \
    "${linux_headers_package}"

# Change default versions if they are known not to work
# with the present versions of the system dependencies.
:

# Function which finds files deep inside a directory tree
# (like the GNU find command).
find_recursive(){
    # Arguments: Absolute path to directory,
    # file/directory to find,
    # [type of file to find: "-f" for file (default),
    #  "-d" for directory].
    local dirname="$1"
    local filename="$2"
    local fd="$3"
    if [ -z "${fd}" ]; then
        fd="-f"
    fi
    # Change directory
    local current_dir="$4"
    local primary_call="False"
    if [ -z "${current_dir}" ]; then
        # This is the primary call to this function
        primary_call="True"
        current_dir="$(pwd)"
        found_results=()
    fi
    dirname="$(convert_to_abs_path "${dirname}")"
    if [ ! -d "${dirname}" ]; then
        return
    fi
    cd "${dirname}"
    # Is file at this location?
    if [ ${fd} "${filename}" ]; then
        # Found
        found_results=("${found_results[@]}" "${dirname}/${filename}")
    else
        # Not found. Search in all subdirectories.
        local f
        for f in *; do
            if [ -d "${f}" ]; then
                find_recursive "${dirname}/${f}" "${filename}" "${fd}" "${current_dir}"
                cd "${dirname}"
            fi
        done
    fi
    cd "${current_dir}"
    if [ "${primary_call}" == "True" ]; then
        # Print out the shortest of the found results, where the length
        # is measured by counting the number of / in the paths.
        N=${#found_results[@]}
        if [ ${N} -gt 0 ]; then
            shortest_result="${found_results[0]}"
            n_slashes_shortest=$(echo "${shortest_result}" | awk -F/ '{print NF-1}')
            for ((i = 1; i < ${N}; i += 1)); do
                n_slashes=$(echo "${found_results[$i]}" | awk -F/ '{print NF-1}')
                if [ ${n_slashes} -lt ${n_slashes_shortest} ]; then
                    shortest_result="${found_results[$i]}"
                    n_slashes_shortest=${n_slashes}
                fi
            done
            echo "${shortest_result}"
        fi
    fi
}

# Replace "__top_dir__" in paths with the user specified top_dir.
# Also convert to absolute path and check that this path exist for
# pre-installed libraries.
fix_path(){
    # Arguments: Program name
    progname="${1// /_}"
    progname="$(echo "${progname}" | tr '[:upper:]' '[:lower:]')"
    # Replace "__top_dir__"
    eval "[ \"\${${progname=}_preinstalled}\" == \"True\" ] \
          || ${progname=}_dir=\"\${${progname=}_dir/__top_dir__/${top_dir}}\""
    # Convert to absolute path
    eval "${progname=}_dir=\"\$(convert_to_abs_path \"\${${progname=}_dir}\")\""
    # Check that the path to pre-installed dependencies exist
    if eval "[ \"\${${progname}_preinstalled}\" == \"True\" ] \
             && [ ! -d \"\${${progname}_dir}\" ] \
             && [ ! -f \"\${${progname}_dir}\" ]"; then
        error "The specified directory\n\"$(eval "echo \${${progname}_dir}")\"\n\
for ${1/CONCEPT/$esc_concept} does not exist!"
        exit 1
    fi
    # Check and correct user specified dependency directories
    eval "progname_dir=\"\${${progname=}_dir}\""
    if [ -f "${progname_dir}" ]; then
        progname_dir="$(dirname ${progname_dir})"
    fi
    if [ "${progname}" == 'class' ] && [ "${class_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/class" ]; then
            if [ -f "${progname_dir}/../class" ]; then
                class_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate CLASS at \"${class_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'concept' ] && [ "${concept_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/concept" ]; then
            if [ -f "${progname_dir}/../concept" ]; then
                concept_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate COð˜•CEPT at \"${concept_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'fftw' ] && [ "${fftw_preinstalled}" == "True" ]; then
        if     [ ! -f "${progname_dir}/lib/libfftw3.so" ] \
            && [ ! -f "${progname_dir}/lib/libfftw3f.so" ]; then
            if     [ -f "${progname_dir}/../lib/libfftw3.so" ] \
                || [ -f "${progname_dir}/../lib/libfftw3f.so" ]; then
                fftw_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate FFTW at \"${fftw_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'freetype' ] && [ "${freetype_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/lib/libfreetype.so" ]; then
            if [ -f "${progname_dir}/../lib/libfreetype.so" ]; then
                freetype_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate FreeType at \"${freetype_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'gadget' ] && [ "${gadget_preinstalled}" == "True" ]; then
        if [ ! -d "${progname_dir}/Gadget2" ]; then
            if [ -d "${progname_dir}/../Gadget2" ]; then
                gadget_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate Gadget at \"${gadget_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'gsl' ] && [ "${gsl_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/lib/libgsl.so" ]; then
            if [ -f "${progname_dir}/../lib/libgsl.so" ]; then
                gsl_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate GSL at \"${gsl_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'hdf5' ] && [ "${hdf5_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/lib/libhdf5.so" ]; then
            if [ -f "${progname_dir}/../lib/libhdf5.so" ]; then
                hdf5_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate HDF5 at \"${hdf5_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'libffi' ] && [ "${libffi_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/lib/libffi.so" ]; then
            if [ -f "${progname_dir}/../lib/libffi.so" ]; then
                libffi_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate libffi at \"${libffi_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'libpng' ] && [ "${libpng_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/lib/libpng.so" ]; then
            if [ -f "${progname_dir}/../lib/libpng.so" ]; then
                libpng_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate libpng at \"${libpng_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'mpi' ] && [ "${mpi_preinstalled}" == "True" ]; then
        # As a pre-installed MPI is often used, allow for a rather
        # general directory layout. Find mpi_bindir, mpi_libdir and
        # mpi_includedir and set mpi_dir to the deepest common directory
        # in the path of these three directories.
        # First find the mpicc executable.
        progname_dir_shallow="${progname_dir}"
        for ((i = 0; i < 3; i += 1)); do
            mpicc="$(find_recursive "${progname_dir_shallow}" "mpicc")"
            if [ -n "${mpicc}" ] || [ "${progname_dir_shallow}" == "/" ]; then
                break
            fi
            progname_dir_shallow="$(dirname "${progname_dir_shallow}")"
        done
        if [ -z "${mpicc}" ]; then
            error "Could not locate mpicc at \"${mpi_dir}\""
            exit 1
        fi
        # The directory containing mpicc will be stored
        # in mpi_compilerdir.
        mpi_compilerdir="$(dirname "${mpicc}")"
        # Now use mpicc to locate the lib and include directories
        mpicc_show="$("${mpicc}" -show || :)"
        mpi_libdirs="$(echo "${mpicc_show}" | grep -o '\-L[^ ]*' || :)"
        n_mpi_libdirs=$(echo "${mpi_libdirs}" | wc -l)
        if [ ${n_mpi_libdirs} -eq 1 ]; then
            mpi_libdir="${mpi_libdirs:2}"
        else
            # Several lib directories exist. Merge them via symlinking.
            mpi_libdir_merged="${mpi_symlinkdir}/merged_lib_specified"
            mkdir -p "${mpi_libdir_merged}"
            while read mpi_libdir; do
                mpi_libdir="${mpi_libdir:2}"
                if [ -d "${mpi_libdir}" ]; then
                    for f in "${mpi_libdir}/"*; do
                        f_base="$(basename "${f}")"
                        mpi_symlink_name="${mpi_libdir_merged}/${f_base}"
                        if     [ ! -f "${mpi_symlink_name}" ] \
                            && [ ! -d "${mpi_symlink_name}" ]; then
                            ln -s "${f}" "${mpi_symlink_name}" >/dev/null 2>&1 || :
                        fi
                    done
                fi
            done <<< "${mpi_libdirs}"
            mpi_libdir="${mpi_libdir_merged}"
        fi
        if [ ! -d "${mpi_libdir}" ]; then
            error "Warning: Could not get MPI library information out of \"${mpicc}\""
            mpi_libdir="$(dirname "${mpi_compilerdir}")/lib"
        fi
        mpi_includedirs="$(echo "${mpicc_show}" | grep -o '\-I[^ ]*' || :)"
        n_mpi_includedirs=$(echo "${mpi_includedirs}" | wc -l)
        if [ ${n_mpi_includedirs} -eq 1 ]; then
            mpi_includedir="${mpi_includedirs:2}"
        else
            # Several include directories exist.
            # Merge them via symlinking.
            mpi_includedir_merged="${mpi_symlinkdir}/merged_include_specified"
            mkdir -p "${mpi_includedir_merged}"
            while read mpi_includedir; do
                mpi_includedir="${mpi_includedir:2}"
                if [ -d "${mpi_includedir}" ]; then
                    for f in "${mpi_includedir}/"*; do
                        f_base="$(basename "${f}")"
                        mpi_symlink_name="${mpi_includedir_merged}/${f_base}"
                        if     [ ! -f "${mpi_symlink_name}" ] \
                            && [ ! -d "${mpi_symlink_name}" ]; then
                            ln -s "${f}" "${mpi_symlink_name}" >/dev/null 2>&1 || :
                        fi
                    done
                fi
            done <<< "${mpi_includedirs}"
            mpi_includedir="${mpi_includedir_merged}"
        fi
        if [ ! -d "${mpi_includedir}" ]; then
            error "Warning: Could not get MPI include information out of \"${mpicc}\""
            mpi_includedir="$(dirname "${mpi_compilerdir}")/include"
        fi
        # Find the mpiexec executable, which might not be in the same
        # directory as mpicc. The mpi_bindir directory is set from the
        # mpiexec executable.
        progname_dir_shallow="${progname_dir}"
        for ((i = 0; i < 3; i += 1)); do
            mpi_bindir="$(find_recursive "${progname_dir_shallow}" "mpiexec")"
            if [ -n "${mpi_bindir}" ] || [ "${progname_dir_shallow}" == "/" ]; then
                break
            fi
            progname_dir_shallow="$(dirname "${progname_dir_shallow}")"
        done
        if [ -n "${mpi_bindir}" ]; then
            mpi_bindir="$(dirname "${mpi_bindir}")"
        else
            # Check for mpiexec in PATH
            mpiexec="$(which mpiexec 2>/dev/null || :)"
            if [ -n "${mpiexec}" ]; then
                mpi_bindir="$(dirname "${mpiexec}")"
                printf "\nMPI binary directory set to \"${mpi_bindir}\" (from PATH)\n\n"
            else
                if [ -f "${mpi_bindir}" ]; then
                    mpi_bindir="$(basename "${mpi_bindir}")"
                fi
                error "Warning: Could not locate MPI binaries at \"${mpi_dir}\", \
nor anywhere in the PATH"
                mpi_bindir="${mpi_compilerdir}"
            fi
        fi
        # Set mpi_dir
        mpi_dir_cancidates=(                     \
            "$(readlink -f "${mpi_bindir}"    )" \
            "$(readlink -f "${mpi_libdir}"    )" \
            "$(readlink -f "${mpi_includedir}")" \
        )
        N=${#mpi_dir_cancidates[@]}
        length="${#mpi_dir_cancidates[0]}"
        different="False"
        for ((j = 1; j < ${length}; j += 1)); do
            part0="${mpi_dir_cancidates[0]}"
            part0="${part0::$j}"
            for ((i = 1; i < ${N}; i += 1)); do
                part0_i="${mpi_dir_cancidates[$i]}"
                part0_i="${part0_i::$j}"
                if [ "${part0_i}" != "${part0}" ]; then
                    different="True"
                    break
                fi
            done
            if [ "${different}" == "True" ]; then
                break
            fi
        done
        ((j -= 1)) || :
        if [ ${j} -gt 1 ]; then
            mpi_dir="${mpi_dir_cancidates[0]}"
            mpi_dir="${mpi_dir::$j}"
            if [[ "${mpi_dir}" != *"/" ]]; then
                mpi_dir="$(dirname "${mpi_dir}")"
            fi
        fi
        if [ -f "${mpi_dir}" ]; then
            mpi_dir="$(dirname "${mpi_dir}")"
        fi
        if [ "$(basename "${mpi_dir}")" == "bin" ]; then
            mpi_dir="$(dirname "${mpi_dir}")"
        fi
    fi
    if [ "${progname}" == 'ncurses' ] && [ "${ncurses_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/lib/libncurses.so" ]; then
            if [ -f "${progname_dir}/../lib/libncurses.so" ]; then
                ncurses_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate ncurses at \"${ncurses_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'blas' ] && [ "${blas_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/include/cblas.h" ]; then
            if [ -f "${progname_dir}/../include/cblas.h" ]; then
                blas_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate OpenBLAS at \"${blas_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'openssl' ] && [ "${openssl_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/lib/libssl.so" ]; then
            if [ -f "${progname_dir}/../lib/libssl.so" ]; then
                openssl_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate OpenSSL at \"${openssl_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'perl' ] && [ "${perl_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/bin/perl" ]; then
            if [ -f "${progname_dir}/../bin/perl" ]; then
                perl_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate Perl at \"${perl_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'python' ] && [ "${python_preinstalled}" == "True" ]; then
        if     [ ! -f "${progname_dir}/bin/python" ] \
            && [ ! -f "${progname_dir}/bin/python3" ]; then
            if     [ -f "${progname_dir}/../bin/python" ] \
                || [ -f "${progname_dir}/../bin/python3" ]; then
                python_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate Python at \"${python_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'zlib' ] && [ "${zlib_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/lib/libz.so" ]; then
            if [ -f "${progname_dir}/../lib/libz.so" ]; then
                zlib_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate zlib at \"${zlib_dir}\""
                exit 1
            fi
        fi
    fi
}
fix_path "CLASS"
fix_path "CONCEPT"
fix_path "FreeType"
fix_path "zlib"
fix_path "libpng"
fix_path "ncurses"
fix_path "BLAS"
fix_path "OpenSSL"
fix_path "libffi"
fix_path "Perl"
fix_path "Python"
fix_path "FFTW"
fix_path "GADGET"
fix_path "FFTW for GADGET"
fix_path "GSL"
fix_path "HDF5"
fix_path "MPI"
log="${log/__top_dir__/${top_dir}}"
env_file="${env_file/__top_dir__/${top_dir}}"
paths_file="${paths_file/__top_dir__/${top_dir}}"

# Set mpicc, mpi_compilerdir, mpi_bindir, mpi_libdir and mpi_includedir
# if not already set.
if [ -z "${mpicc}" ]; then
    mpicc="${mpi_dir}/bin/mpicc"
fi
if [ -z "${mpi_compilerdir}" ]; then
    mpi_compilerdir="${mpi_dir}/bin"
fi
if [ -z "${mpi_bindir}" ]; then
    mpi_bindir="${mpi_dir}/bin"
fi
if [ -z "${mpi_libdir}" ]; then
    mpi_libdir="${mpi_dir}/lib"
fi
if [ -z "${mpi_includedir}" ]; then
    mpi_includedir="${mpi_dir}/include"
fi

# Set test_log path variables
blas_test_log="${blas_dir}/test_log"
class_test_log="${class_dir}/test_log"
concept_test_log="${concept_dir}/test_log"
fftw_test_log="${fftw_dir}/test_log"
fftw_for_gadget_test_log="${fftw_for_gadget_dir}/test_log"
freetype_test_log="${freetype_dir}/test_log"
gadget_test_log="${gadget_dir}/test_log"
gsl_test_log="${gsl_dir}/test_log"
hdf5_test_log="${hdf5_dir}/test_log"
libffi_test_log="${libffi_dir}/lib/libffi-${libffi_version}/test_log"
libpng_test_log="${libpng_dir}/test_log"
mpi_test_log="${mpi_dir}/test_log"
ncurses_test_log="${ncurses_dir}/include/ncurses/test_log"
openssl_test_log="${openssl_dir}/include/openssl/test_log"
perl_test_log="${perl_dir}/test_log"
python_test_log="${python_dir}/test_log"
zlib_test_log="${zlib_dir}/test_log"
numpy_test_log="${python_dir}/numpy_test_log"
scipy_test_log="${python_dir}/scipy_test_log"

# Check whether this script is run locally or remotely via ssh
ssh="True"
if [ -z "${SSH_CLIENT}" ] && [ -z "${SSH_TTY}" ]; then
    ssh="False"
fi

# When running locally, set the "make_jobs" variable, holding the -j
# option for future make commands, enabling parallel building.
# Some implementations of make does not support the bare -j option
# without explicitly specifying a number afterwards. If so, we do not
# make use of the -j option.
if [ "${ssh}" == "False" ] && [ -z "${make_jobs}" ]; then
    make_jobs_test_dir="${top_dir}/tmp/make_jobs_test"
    rm -rf "${make_jobs_test_dir}" || :
    mkdir -p "${make_jobs_test_dir}"
    printf "
test:
\t@echo success
" > "${make_jobs_test_dir}/Makefile"
    make_jobs_output="$(cd "${make_jobs_test_dir}" && make -j 2>/dev/null)" || :
    if [ "${make_jobs_output}" == "success" ]; then
        make_jobs="-j"
    fi
    rm -rf "${make_jobs_test_dir}" || :
fi
# Set OMP_NUM_THREADS to 1 when running remotely,
# so that OpenMP runs serially.
if [ "${ssh}" == "True" ] && [ -z "${OMP_NUM_THREADS}" ]; then
    export OMP_NUM_THREADS=1
fi
# In OpenMPI 3 and 4, oversubscription (having more MPI processes
# than physical cores) is disallowed by default.
# We want oversubscription to be allowed during installation.
if [ -z "${OMPI_MCA_rmaps_base_oversubscribe}" ]; then
    export OMPI_MCA_rmaps_base_oversubscribe=1
fi



##########################
# Dependency discovering #
##########################
current_step="discovery of dependencies"
# Flags specifying whether or not any Python packages,
# software (meaning anything but Python packages) or any of those
# should be installed.
install_any_pypackages="False"
install_any_software="False"
install_anything="False"
assume_preinstalled(){
    # Arguments: Program name (lowercase)
    eval "name_preinstalled=\"\${${1}_preinstalled}\""
    if [ "${name_preinstalled}" == "False" ]; then
        eval "${1}_preinstalled=\"True\""
        eval "${1}_dir=\"\""
        eval "${1}_version=\"pre-installed\""
    fi
}
# If Python is pre-installed, assume that OpenSSL,
# libffi and ncurses are also pre-installed.
if [ "${python_preinstalled}" == "True" ]; then
    assume_preinstalled "openssl"
    assume_preinstalled "libffi"
    assume_preinstalled "ncurses"
fi
# If OpenSSL, BLAS and MPI is pre-installed,
# assume that Perl is also pre-installed.
if     [ "${openssl_preinstalled}" == "True" ] \
    && [ "${blas_preinstalled}"    == "True" ] \
    && [ "${mpi_preinstalled}"     == "True" ] \
; then
    assume_preinstalled "perl"
fi

# Function that checks whether a given Python package
# is installed or not.
check_pypackage_installed(){
    # Arguments: Python package name
    current_dir="$(pwd)"
    cd "${top_dir}"
    # Some Python packages may need access to libraries at runtime
    current_LD_LIBRARY_PATH="${LD_LIBRARY_PATH}"
    for lib in "blas" "gsl" "hdf5" "libpng" "mpi" "zlib"; do
        eval "lib_dir=\"\${${lib}_dir}/lib\""
        if [ -d "${lib_dir}" ]; then
            export LD_LIBRARY_PATH="${lib_dir}:${LD_LIBRARY_PATH}"
        fi
    done
    "${python}" -c "
from time import sleep
try:
    if '${1}' == 'cythongsl':
        # CythonGSL has an extra underscore when importing
        import cython_gsl
    elif '${1}' == 'mpi4py':
        # For MPI4Py we do a more thorough test
        import mpi4py.rc; mpi4py.rc.threads = False  # Do not use threads
        from mpi4py import MPI
    else:
        import ${1}
    sleep(1)
    print('\nTrue')
except:
    print('\nFalse')
" 2>/dev/null | tail -n 1
    cd "${current_dir}"
    export LD_LIBRARY_PATH="${current_LD_LIBRARY_PATH}"
}

# Set "pypackage"_preinstalled variables
blessings_preinstalled="False"
cython_preinstalled="False"
cythongsl_preinstalled="False"
h5py_preinstalled="False"
matplotlib_preinstalled="False"
mpi4py_preinstalled="False"
numpy_preinstalled="False"
pytest_preinstalled="False"
scipy_preinstalled="False"
sphinx_preinstalled="False"
sphinx_copybutton_preinstalled="False"
sphinx_rtd_theme_preinstalled="False"
sphinx_tabs_preinstalled="False"
pip_preinstalled="False"
if [ "${python_preinstalled}" == "True" ]; then
    python=$(ls -1 "${python_dir}/bin/python"* | head -n 1)
    for pypackage in blessings         \
                     cython            \
                     cythongsl         \
                     h5py              \
                     matplotlib        \
                     mpi4py            \
                     numpy             \
                     pip               \
                     pytest            \
                     scipy             \
                     sphinx            \
                     sphinx_copybutton \
                     sphinx_rtd_theme  \
                     sphinx_tabs       \
    ; do
        pypackage_preinstalled=$(check_pypackage_installed ${pypackage})
        eval "${pypackage}_preinstalled=\"${pypackage_preinstalled}\""
    done
fi

# Variables telling whether or not a program needs to be installed.
# COð˜•CEPT (install by default)
if [ -z "${concept_install}" ]; then
    concept_install="False"
    if [ "${concept_preinstalled}" == "False" ]; then
        concept_install="True"
    fi
fi
# CLASS (needed by COð˜•CEPT)
if [ -z "${class_install}" ]; then
    class_install="False"
    if [ "${class_preinstalled}" == "False" ] && [ "${concept_install}" == "True" ]; then
        class_install="True"
    fi
fi
# GADGET (needed by COð˜•CEPT)
if [ -z "${gadget_install}" ]; then
    gadget_install="False"
    if [ "${gadget_preinstalled}" == "False" ] && [ "${concept_install}" == "True" ]; then
        gadget_install="True"
    fi
fi
# FFTW for GADGET (needed by GADGET)
if [ -z "${fftw_for_gadget_install}" ]; then
    fftw_for_gadget_install="False"
    if [ "${fftw_for_gadget_preinstalled}" == "False" ] && [ "${gadget_install}" == "True" ]; then
        fftw_for_gadget_install="True"
    fi
fi
# Python (needed by COð˜•CEPT and CLASS)
if [ -z "${python_install}" ]; then
    python_install="False"
    if [ "${python_preinstalled}" == "False" ] \
        && ([ "${concept_install}" == "True" ] || [ "${class_install}" == "True" ]); then
        python_install="True"
    fi
fi
# Python packages (needed by CLASS and COð˜•CEPT)
if [ -z "${pip_install}" ]; then
    # Always install pip if Python is to be installed
    pip_install="False"
    if [ "${python_install}" == "True" ]; then
        pip_install="True"
    fi
fi
for pypackage in blessings         \
                 cython            \
                 cythongsl         \
                 h5py              \
                 matplotlib        \
                 mpi4py            \
                 numpy             \
                 pytest            \
                 scipy             \
                 sphinx            \
                 sphinx_copybutton \
                 sphinx_rtd_theme  \
                 sphinx_tabs       \
; do
    eval "pypackage_install=\"\${${pypackage}_install}\""
    if [ -z "${pypackage_install}" ]; then
        eval "${pypackage}_install=\"False\""
        eval "pypackage_preinstalled=\"\${${pypackage}_preinstalled}\""
        if [ "${pypackage_preinstalled}" == "False" ] && [ "${concept_install}" == "True" ]; then
            eval "${pypackage}_install=\"True\""
        fi
    fi
done
# Do not install pytest unless we are installing with tests
# and either NumPy or SciPy is to be installed.
if [ "${do_tests}" == "False" ] \
    || ([ "${numpy_install}" == "False" ] && [ "${scipy_install}" == "False" ]); then
    pytest_install="False"
fi
# FFTW (needed by COð˜•CEPT)
if [ -z "${fftw_install}" ]; then
    fftw_install="False"
    if [ "${fftw_preinstalled}" == "False" ] && [ "${concept_install}" == "True" ]; then
        fftw_install="True"
    fi
fi
# HDF5 (needed by COð˜•CEPT)
if [ -z "${hdf5_install}" ]; then
    hdf5_install="False"
    if [ "${hdf5_preinstalled}" == "False" ] && [ "${concept_install}" == "True" ]; then
        hdf5_install="True"
    fi
fi
# MPI (needed by COð˜•CEPT, GADGET)
if [ -z "${mpi_install}" ]; then
    mpi_install="False"
    if [ "${mpi_preinstalled}" == "False" ] && \
        (   [ "${concept_install}" == "True" ] \
         || [ "${gadget_install}"  == "True" ]); then
        mpi_install="True"
    fi
fi
# GSL (needed by COð˜•CEPT, GADGET)
if [ -z "${gsl_install}" ]; then
    gsl_install="False"
    if [ "${gsl_preinstalled}" == "False" ] && \
        (   [ "${concept_install}" == "True" ] \
         || [ "${gadget_install}"  == "True" ]); then
        gsl_install="True"
    fi
fi
# libpng (needed by matplotlib)
if [ -z "${libpng_install}" ]; then
    libpng_install="False"
    if [ "${libpng_preinstalled}" == "False" ] && [ "${matplotlib_install}" == "True" ]; then
        libpng_install="True"
    fi
fi
# zlib (needed by HDF5, libpng and Python)
if [ -z "${zlib_install}" ]; then
    zlib_install="False"
    if [ "${zlib_preinstalled}" == "False" ] && \
        (   [ "${hdf5_install}"   == "True" ] \
         || [ "${libpng_install}" == "True" ] \
         || [ "${python_install}" == "True" ]); then
        zlib_install="True"
    fi
fi
# FreeType (needed by matplotlib)
if [ -z "${freetype_install}" ]; then
    freetype_install="False"
    if [ "${freetype_preinstalled}" == "False" ] && [ "${matplotlib_install}" == "True" ]; then
        freetype_install="True"
    fi
fi
# ncurses (needed by Python, if Python is needed by COð˜•CEPT)
if [ -z "${ncurses_install}" ]; then
    ncurses_install="False"
    if [ "${ncurses_preinstalled}" == "False" ] && [ "${python_install}"  == "True" ] \
        && [ "${concept_install}" == "True" ]; then
        ncurses_install="True"
    fi
fi
# BLAS (needed by NumPy and SciPy)
if [ -z "${blas_install}" ]; then
    blas_install="False"
    if [ "${blas_preinstalled}" == "False" ] \
        && ([ "${numpy_install}" == "True" ] || [ "${scipy_install}" == "True" ]); then
        blas_install="True"
    fi
fi
# OpenSSL (needed by pip)
if [ -z "${openssl_install}" ]; then
    openssl_install="False"
    if [ "${openssl_preinstalled}" == "False" ] && [ "${pip_install}" == "True" ]; then
        openssl_install="True"
    fi
fi
# libffi (needed by pip)
if [ -z "${libffi_install}" ]; then
    libffi_install="False"
    if [ "${libffi_preinstalled}" == "False" ] && [ "${pip_install}" == "True" ]; then
        libffi_install="True"
    fi
fi
# Perl (needed by OpenSSL, OpenBLAS and MPICH/OpenMPI)
if [ -z "${perl_install}" ]; then
    perl_install="False"
    if [ "${perl_preinstalled}" == "False" ]      \
        && (                                      \
               [ "${openssl_install}" == "True" ] \
            || [ "${blas_install}"    == "True" ] \
            || [ "${mpi_install}"     == "True" ] \
        )                                         \
    ; then
        perl_install="True"
    fi
fi
# The install_any_software, install_any_pypackages
# and install_anything variables.
if     [ "${concept_install}"           == "True" ] \
    || [ "${blas_install}"              == "True" ] \
    || [ "${class_install}"             == "True" ] \
    || [ "${gadget_install}"            == "True" ] \
    || [ "${fftw_for_gadget_install}"   == "True" ] \
    || [ "${python_install}"            == "True" ] \
    || [ "${fftw_install}"              == "True" ] \
    || [ "${hdf5_install}"              == "True" ] \
    || [ "${mpi_install}"               == "True" ] \
    || [ "${gsl_install}"               == "True" ] \
    || [ "${libpng_install}"            == "True" ] \
    || [ "${zlib_install}"              == "True" ] \
    || [ "${freetype_install}"          == "True" ] \
    || [ "${ncurses_install}"           == "True" ] \
    || [ "${openssl_install}"           == "True" ] \
    || [ "${libffi_install}"            == "True" ] \
    || [ "${perl_install}"              == "True" ] \
; then
        install_any_software="True"
fi
if     [ "${blessings_install}"         == "True" ] \
    || [ "${cython_install}"            == "True" ] \
    || [ "${cythongsl_install}"         == "True" ] \
    || [ "${h5py_install}"              == "True" ] \
    || [ "${matplotlib_install}"        == "True" ] \
    || [ "${mpi4py_install}"            == "True" ] \
    || [ "${numpy_install}"             == "True" ] \
    || [ "${pytest_install}"            == "True" ] \
    || [ "${scipy_install}"             == "True" ] \
    || [ "${sphinx_install}"            == "True" ] \
    || [ "${sphinx_copybutton_install}" == "True" ] \
    || [ "${sphinx_rtd_theme_install}"  == "True" ] \
    || [ "${sphinx_tabs_install}"       == "True" ] \
; then
        install_any_pypackages="True"
fi
if [ "${install_any_software}" == "True" ] || [ "${install_any_pypackages}" == "True" ]; then
    install_anything="True"
fi



###########################
# Beginning of subprocess #
log_file_lines_before_install=0
if [ -f "${log}" ]; then
    log_file_lines_before_install=$(wc -l "${log}" | awk '{print $1}')
fi
# The stdout of the (background) subprocess below will be redirected
# into ${log}, which in read back in and echoed to the TTY. The system
# will keep track of the current installation step and always display
# this at the bottom, which is the whole reason for not just tee'ing
# stdout directly to ${log}.
# To also log stderr, we tee this into ${log}_err.
( ( (
# Set up error trapping
ctrl_c_subprocess(){
    trap : 0
    ctrl_c
    exit 0
}
abort_subprocess(){
    trap : 0
    if [ "${current_step}" != "aborting" ]; then
        error "An error occurred during ${current_step}!"
    fi
    abort
    exit 0
}
trap 'ctrl_c_subprocess' SIGINT
trap 'abort_subprocess' EXIT
set -e

# Ensure new line in log after possible previous failed attempt
echo

# Functions for controlling the current status
set_status(){
    echo "${status_prefix}${1}"
}
disable_status(){
    echo "${status_prefix}${status_disable}"
}
enable_status(){
    echo "${status_prefix}${status_enable}"
}
successfully_finish_status(){
    echo "${status_prefix}${status_finish_successfully}"
}
# These are needed to get the spacing right in the output
current_step="initialisation"
set_status "Initialising"



#############################
# URL's to all the software #
#############################
# In this section, ${progame_url} are defined for each program.
# In order for the rest of this script to work, these URLs must point
# to archives containing a single top-level directory.

# Function for checking that a given url actually exists
validate_url(){
    # Arguments: Program name, [exit on error ("True" or "False")]
    progname="$(echo "${1}" | tr '[:upper:]' '[:lower:]')"
    progname="${progname// /_}"
    exit_on_error="True"
    if [ -n "$2" ]; then
        exit_on_error="$2"
    fi
    if [ "${progname}" == "mpi" ]; then
        if [ "${mpi}" == "mpich" ]; then
            current_step="validation of MPICH link"
            set_status "Validating MPICH link"
        elif [ "${mpi}" == "openmpi" ]; then
            current_step="validation of OpenMPI link"
            set_status "Validating OpenMPI link"
        fi
    else
        current_step="validation of ${1/CONCEPT/$esc_concept} link"
        set_status "Validating ${1/CONCEPT/${esc_concept}} link"
    fi
    url="$(eval "echo \"\${${progname}_url}\"")"
    filename="$(basename "${url}")"
    mkdir -p "${top_dir}/tmp"
    for n in {1..3}; do
        for spider in "True" "False"; do
            for ipv in "--inet4-only" "--inet6-only" ""; do
                for no_dns_cache in "--no-dns-cache" ""; do
                    wget_status="success"
                    if [ "${spider}" == "True" ]; then
                        if [[ "${url}" == "ftp://"* ]]; then
                            # wget do not always return with a non-zero
                            # status on failure when using ftp.
                            (cd "${top_dir}/tmp"
                             wget -t 1 --timeout 30 --no-check-certificate ${no_dns_cache} \
                                --spider --no-remove-listing ${ipv} "${url}"               \
                                > "${top_dir}/tmp/.wget" 2>&1                              \
                                || :)
                            grep "${filename}" "${top_dir}/tmp/.listing" > /dev/null 2>&1 \
                                 || wget_status="error"
                            rm -f "${top_dir}/tmp/.listing" || :
                        else
                            wget -t 1 --timeout 30 --no-check-certificate ${no_dns_cache} \
                                --spider ${ipv} "${url}" > "${top_dir}/tmp/.wget" 2>&1 \
                                || wget_status="error"
                        fi
                        if [ "${wget_status}" == "error" ]; then
                            # Heavy scraping can result in bans,
                            # indicated by a "429 Too Many Requests"
                            # error. This does not mean that we cannot
                            # download the file, just that the spider
                            # has been disallowed by the server.
                            if grep "429" "${top_dir}/tmp/.wget" >/dev/null 2>&1; then
                                wget_status="success"
                            fi
                        fi
                        rm -f "${top_dir}/tmp/.wget" || :
                        if [ "${wget_status}" == "success" ]; then
                            break
                        fi
                    else
                        # Some times --spider just does not succeed in
                        # correctly reporting the existence of the
                        # remote file, even though it exists. As a last
                        # resort, try downloading the file completelte,
                        # without using --spider (and throw away the
                        # downloaded file).
                        wget -t 1 --timeout 30 --no-check-certificate ${no_dns_cache} ${ipv} -O - \
                            "${url}" >/dev/null 2>&1 || wget_status="error"
                    fi
                done
                if [ "${wget_status}" == "success" ]; then
                    break
                fi
            done
            if [ "${wget_status}" == "success" ]; then
                break
            fi
        done
        if [ "${wget_status}" == "success" ]; then
            break
        fi
        sleep 1
    done
    validate_url_status="${wget_status}"
    if [ "${exit_on_error}" == "True" ]; then
        if [ "${wget_status}" != "success" ]; then
            error "Error: The ${1} link is broken: ${url}"
            exit 1
        fi
    fi
}

# Function for letting versions fall back to their secondary,
# fallback values, in case of unsuccessful retrievel of primary version.
fallback(){
    # Arguments: Program name
    progname="$(echo "${1}" | tr '[:upper:]' '[:lower:]')"
    progname="${progname// /_}"
    eval "progname_version=\"\${${progname}_version}\""
    eval "progname_version_fallback=\"\${${progname}_version_fallback}\""
    if [ "${progname}" == "mpi" ]; then
        if [ "${mpi}" == "mpich" ]; then
            realname="MPICH"
        elif [ "${mpi}" == "openmpi" ]; then
            realname="OpenMPI"
        fi
    else
        realname="${1}"
    fi
    if [ "${progname_version}" != "${progname_version_fallback}" ]; then
        echo "Falling back to ${realname} version ${progname_version_fallback}"
    fi
    progname_version="${progname_version_fallback}"
    eval "${progname}_version=\"\${progname_version}\""
    eval "${progname}_version_fallback=\"\${progname_version_fallback}\""
}

# Function which checks the download and installation progress
# of all the programs based on helper files created by previous
# invocations of this script. The function is called with the program
# name (progname) as the argument and it will set the variables
# progname_downloaded, progname_installed and progname_test_success
# to either "True" or "False".
check_progress(){
    # Arguments: Program name
    progname_display="${1/CONCEPT/${esc_concept}}"
    progname="${1// /_}"
    progname="$(echo "${progname}" | tr '[:upper:]' '[:lower:]')"
    # The program installation directory
    eval "progdir=\"\${${progname}_dir}\""
    # COð˜•CEPT itself will not have a .installation_finished file in its
    # directory. Instead it uses the .installation_finished in the
    # GADGET directory.
    if [ "${progname}" == "concept" ]; then
        progdir="${gadget_dir}"
        # If ${concept_dir} is missing (e.g. manually deleted), info
        # about COð˜•CEPT from ${gadget_dir}/.installation_finished
        # should not be used. Remove such info if present, and if
        # ${concept_dir} indeed is missing.
        if ([ ! -d "${concept_dir}" ] || [ -z "$(ls "${concept_dir}")" ]) \
            && [ -f "${progdir}/.installation_finished" ]; then
            linenr=$(awk "\$0 ~ \"CONCEPT\" {print NR}" \
                "${progdir}/.installation_finished" | head -n 1)
            if [ -n "${linenr}" ]; then
                linenr_first=${linenr}
                while :; do
                    line="$(sed -n "${linenr_first}p" "${progdir}/.installation_finished")"
                    if [ -z "${line}" ]; then
                        ((linenr_first += 1))
                        break
                    fi
                    ((linenr_first -= 1))
                    if [ ${linenr_first} -eq 0 ]; then
                        ((linenr_first += 1))
                        break
                    fi
                done
                linenr_last=${linenr}
                while :; do
                    line="$(sed -n "${linenr_last}p" "${progdir}/.installation_finished")"
                    if [ -z "${line}" ]; then
                        ((linenr_last -= 1))
                        break
                    fi
                    ((linenr_last += 1))
                done
                sed -i "${linenr_first},${linenr_last}d" "${progdir}/.installation_finished"
            fi
        fi
    fi
    # The program version
    eval "progversion=\"\${${progname}_version}\""
    # If the program has already been fully installed, a file called
    # .installation_finished will be placed in the program installation
    # directory. Note that some programs share a common installation
    # directory and thefore also a common .installation_finished file.
    eval "${progname}_installed=\"False\""
    if [ -f "${progdir}/.installation_finished" ]; then
        while read line; do
            prog_prev="$(echo "${line}" | grep  '^Program:*'     \
                                        | sed 's/^Program:\s//g' \
                                        | sed 's/^ *//')"
            if [ -n "${prog_prev}" ]; then
                prog_prev_real="${prog_prev// /_}"
                prog_prev_real="$(echo "${prog_prev_real}" | tr '[:upper:]' '[:lower:]')"
            fi
            version_prev="$(echo "${line}" | grep  '^Version:*'     \
                                           | sed 's/^Version:\s//g' \
                                           | sed 's/^ *//')"
            if [ -n "${version_prev}" ]; then
                version_prev_real="${version_prev}"
            fi
            test_results_prev="$(echo "${line}" | grep  '^Test results:*'     \
                                                | sed 's/^Test results:\s//g' \
                                                | sed 's/^ *//')"
            if [ -n "${test_results_prev}" ]; then
                test_results_prev_real="${test_results_prev}"
            fi
            if [ "${prog_prev_real}" == "${progname}" ]; then
                if [ "${version_prev_real}" == "${progversion}" ]; then
                    eval "${progname}_installed=\"True\""
                    if [ -n "${test_results_prev_real}" ]; then
                        if [ "${test_results_prev}" == "Success" ]; then
                            eval "${progname}_test_success=\"True\""
                        elif [ "${test_results_prev_real}" == "Failure" ]; then
                            eval "${progname}_test_success=\"False\""
                        fi
                    fi
                    # Installed programs should always count
                    # as downloaded.
                    eval "${progname}_downloaded=\"True\""
                    return
                fi
                # Progam already installed but of incorrect version.
                # Count as uninstalled.
                break
            fi
        done <<< "$(tac "${progdir}/.installation_finished")"
    fi
    # If the program is not yet installed fully, remove its directory,
    # cleaning up after any previous failed installation attempts.
    if [ "${progname}" == "gadget" ]; then
        # FFTW for GADGET is placed inside the GADGET directory
        if [ -d "${gadget_dir}/fftw" ]; then
            mv "${gadget_dir}/fftw" "${gadget_dir}/.fftw"
        fi
        if [ -d "${gadget_dir}" ] && [ -n "$(ls "${gadget_dir}")" ]; then
            printf "Cleaning up ${progname_display} directory ..."
            rm -rf "${gadget_dir}/"* || :
            printf " done\n"
        fi
        if [ -d "${gadget_dir}/.fftw" ]; then
            mv "${gadget_dir}/.fftw" "${gadget_dir}/fftw"
        fi
        if [ -d "${gadget_dir}" ] && [ -z "$(ls -A "${gadget_dir}")" ]; then
            rm -rf "${gadget_dir}" || :
        fi
    elif [ "${progname}" == "python" ]; then
        # Files from ncurses, OpenSSL and libffi are placed all around
        # in ${python_dir}, so we cannot just delete this directory.
        :
    elif [ "${progname}" == "ncurses" ]; then
        if [ -d "${python_dir}/include/ncurses" ]; then
            printf "Cleaning up ${progname_display} directory ..."
            rm -rf "${python_dir}/include/ncurses" || :
            printf " done\n"
        fi
    elif [ "${progname}" == "openssl" ]; then
        if [ -d "${python_dir}/include/openssl" ]; then
            printf "Cleaning up ${progname_display} directory ..."
            rm -rf "${python_dir}/include/openssl" || :
            printf " done\n"
        fi
    elif [ "${progname}" == "libffi" ]; then
        for f in "${python_dir}/lib/libffi"*; do
            if [ -d "${f}" ]; then
                printf "Cleaning up ${progname_display} directory ..."
                rm -rf "${python_dir}/lib/libffi"* || :
                printf " done\n"
                break
            fi
        done
    elif [ "${progname}" == "concept" ]; then
        # In the case of COð˜•CEPT, ${progdir} is set to
        # the GADGET directory.
        if [ -d "${concept_dir}" ]; then
            printf "Cleaning up ${progname_display} directory ..."
            rm -rf "${concept_dir}" || :
            printf " done\n"
        fi
    else
        # The files of all other programs live isolated
        # in their very own dedicated directory.
        if [ -d "${progdir}" ]; then
            printf "Cleaning up ${progname_display} directory ..."
            rm -rf "${progdir}" || :
            printf " done\n"
        fi
    fi
    # The url to the installation file for this program
    eval "url=\"\${${progname}_url}\""
    # The directory for the downloaded file
    download_dir="${top_dir}/tmp/${progname}"
    # If the source file has already been downloaded fully, a file
    # called .download_finished will be placed in the download_dir with
    # information about this file.
    eval "${progname}_downloaded=\"False\""
    if [ -f "${download_dir}/.download_finished" ]; then
        file_prev="$(grep "^File:*" "${download_dir}/.download_finished" | sed 's/^File:\s//g' \
                                                                         | sed 's/^ *//')"
        url_prev="$( grep "^URL:*"  "${download_dir}/.download_finished" | sed 's/^URL:\s//g' \
                                                                         | sed 's/^ *//')"
        if [ -f "${download_dir}/${file_prev}" ] && [ "${url_prev}" == "${url}" ]; then
            eval "${progname}_downloaded=\"True\""
        fi
    fi
}

# COð˜•CEPT
if [ "${concept_install}" == "True" ]; then
    # Either download the current state of the master branch
    # or a specific release.
    if [ "${concept_version}" == "master" ]; then
        concept_url="https://github.com/jmd-dk/concept/archive/${concept_version}.tar.gz"
    else
        concept_version="${concept_version/v/}"
        concept_url="https://github.com/jmd-dk/concept/archive/v${concept_version}.tar.gz"
    fi
    # Check if already downloaded/installed
    check_progress "CONCEPT"
    # If not yet downloaded, validate the URL
    if [ "${concept_downloaded}" != "True" ]; then
        validate_url "CONCEPT" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary COð˜•CEPT link broken: ${concept_url}"
            error "Error: The installer does not know of a secondary COð˜•CEPT link"
            exit 1
        fi
    fi
fi

# CLASS
if [ "${class_install}" == "True" ]; then
    # Either download specific release or specific branch
    current_step="processing of CLASS link"
    dots="${class_version//[^.]}"
    ndots="${#dots}"
    if [ "${ndots}" == 1 ]; then
        class_url="https://github.com/lesgourg/class_public/archive/${class_version}.tar.gz"
    elif [ "${ndots}" == 2 ]; then
        class_version=${class_version/v/}
        class_url="https://github.com/lesgourg/class_public/archive/v${class_version}.tar.gz"
    else
        error "No CLASS URL known for version ${class_version}"
        exit 1
    fi
    # Check if already installed/downloaded
    check_progress "CLASS"
    # If not yet downloaded, validate the URL
    if [ "${class_downloaded}" != "True" ]; then
        validate_url "CLASS" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary CLASS link broken: ${class_url}"
            error "Error: The installer does not know of a secondary CLASS link"
            exit 1
        fi
    fi
fi

# FFTW
if [ "${fftw_install}" == "True" ]; then
    fftw_url="http://www.fftw.org/fftw-${fftw_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "FFTW"
    # If not yet downloaded, validate the URL
    if [ "${fftw_downloaded}" != "True" ]; then
        validate_url "FFTW" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary FFTW link broken: ${fftw_url}"
            fallback "FFTW"
            fftw_url="ftp://ftp.fftw.org/pub/fftw/fftw-${fftw_version}.tar.gz"
            echo "Using secondary FFTW link: ${fftw_url}"
            # Check if already installed and/or downloaded
            check_progress "FFTW"
            # If not yet downloaded, validate the URL
            if [ "${fftw_downloaded}" != "True" ]; then
                validate_url "FFTW"
            fi
        fi
    fi
fi

# FFTW for GADGET
if [ "${fftw_for_gadget_install}" == "True" ]; then
    fftw_for_gadget_url="http://www.fftw.org/fftw-${fftw_for_gadget_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "FFTW for GADGET"
    # If not yet downloaded, validate the URL
    if [ "${fftw_for_gadget_downloaded}" != "True" ]; then
        validate_url "FFTW for GADGET" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary FFTW 2 link broken: ${fftw_for_gadget_url}"
            fallback "FFTW for GADGET"
            fftw_for_gadget_url="ftp://ftp.fftw.org/pub/fftw/\
fftw-${fftw_for_gadget_version}.tar.gz"
            echo "Using secondary FFTW 2 link: ${fftw_for_gadget_url}"
            # Check if already installed and/or downloaded
            check_progress "FFTW for GADGET"
            # If not yet downloaded, validate the URL
            if [ "${fftw_for_gadget_downloaded}" != "True" ]; then
                validate_url "FFTW for GADGET"
            fi
        fi
    fi
fi

# FreeType
if [ "${freetype_install}" == "True" ]; then
    freetype_url="http://download.savannah.gnu.org/releases/freetype/\
freetype-${freetype_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "FreeType"
    # If not yet downloaded, validate the URL
    if [ "${freetype_downloaded}" != "True" ]; then
        validate_url "FreeType" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary FreeType link broken: ${freetype_url}"
            fallback "freetype"
            freetype_url="http://sourceforge.net/projects/freetype/files/freetype2/\
${freetype_version}/freetype-${freetype_version}.tar.gz"
            echo "Using secondary FreeType link: ${freetype_url}"
            # Check if already installed and/or downloaded
            check_progress "FreeType"
            # If not yet downloaded, validate the URL
            if [ "${freetype_downloaded}" != "True" ]; then
                validate_url "FreeType"
            fi
        fi
    fi
fi

# GADGET
if [ "${gadget_install}" == "True" ]; then
    gadget_url="http://www.mpa-garching.mpg.de/gadget/gadget-${gadget_version}.tar.gz"
    # Check if already installed/downloaded
    check_progress "GADGET"
    # If not yet downloaded, validate the URL
    if [ "${gadget_downloaded}" != "True" ]; then
        validate_url "GADGET" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary GADGET link broken: ${gadget_url}"
            error "Error: The installer does not know of a secondary GADGET link"
            exit 1
        fi
    fi
fi

# GSL
if [ "${gsl_install}" == "True" ]; then
    gsl_url="ftp://ftp.gnu.org/gnu/gsl/gsl-${gsl_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "GSL"
    # If not yet downloaded, validate the URL
    if [ "${gsl_downloaded}" != "True" ]; then
        validate_url "GSL" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary GSL link broken: ${gsl_url}"
            fallback "GSL"
            gsl_url="http://ftpmirror.gnu.org/gsl/gsl-${gsl_version}.tar.gz"
            echo "Using secondary gsl link: ${gsl_url}"
            # Check if already installed and/or downloaded
            check_progress "GSL"
            # If not yet downloaded, validate the URL
            if [ "${gsl_downloaded}" != "True" ]; then
                validate_url "GSL"
            fi
        fi
    fi
fi

# HDF5
if [ "${hdf5_install}" == "True" ]; then
    hdf5_version_major="$(echo "${hdf5_version}" | grep -o '[0-9]\.[0-9]*')"
    hdf5_url="https://support.hdfgroup.org/ftp/HDF5/releases/hdf5-${hdf5_version_major}/\
hdf5-${hdf5_version}/src/hdf5-${hdf5_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "HDF5"
    # If not yet downloaded, validate the URL
    if [ "${hdf5_downloaded}" != "True" ]; then
        validate_url "HDF5" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary HDF5 link broken: ${hdf5_url}"
            fallback "HDF5"
            hdf5_version_major="$(echo "${hdf5_version}" | grep -o '[0-9]\.[0-9]*')"
            hdf5_url="https://support.hdfgroup.org/ftp/HDF5/releases/hdf5-${hdf5_version_major}/\
hdf5-${hdf5_version}/src/hdf5-${hdf5_version}.tar.gz"
            echo "Using secondary HDF5 link: ${hdf5_url}"
            # Check if already installed and/or downloaded
            check_progress "HDF5"
            # If not yet downloaded, validate the URL
            if [ "${hdf5_downloaded}" != "True" ]; then
                validate_url "HDF5"
            fi
        fi
    fi
fi

# libpng
if [ "${libpng_install}" == "True" ]; then
    # For e.g. libpng_version 1.6.18, libpng_version_majors is 16
    libpng_url="https://github.com/glennrp/libpng/archive/v${libpng_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "libpng"
    # If not yet downloaded, validate the URL
    if [ "${libpng_downloaded}" != "True" ]; then
        validate_url "libpng" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary libpng link broken: ${libpng_url}"
            fallback "libpng"
            libpng_url="http://prdownloads.sourceforge.net/libpng/libpng-${libpng_version}.tar.gz"
            echo "Using secondary libpng link: ${libpng_url}"
            # Check if already installed and/or downloaded
            check_progress "libpng"
            # If not yet downloaded, validate the URL
            if [ "${libpng_downloaded}" != "True" ]; then
                validate_url "libpng"
            fi
        fi
    fi
fi

# MPI
if [ "${mpi_install}" == "True" ]; then
    if [ "${mpi}" == "mpich" ]; then
        # MPICH
        mpi_url="http://www.mpich.org/static/downloads/${mpi_version}/mpich-${mpi_version}.tar.gz"
        # Check if already installed and/or downloaded
        check_progress "MPI"
        # If not yet downloaded, validate the URL
        if [ "${mpi_downloaded}" != "True" ]; then
            validate_url "MPI" "False"
            if [ "${validate_url_status}" != "success" ]; then
                echo "Primary MPICH link broken: ${mpi_url}"
                fallback "MPI"
                mpi_url="http://fossies.org/linux/misc/mpich-${mpi_version}.tar.gz"
                echo "Using secondary MPICH link: ${mpi_url}"
                # Check if already installed and/or downloaded
                check_progress "MPI"
                # If not yet downloaded, validate the URL
                if [ "${mpi_downloaded}" != "True" ]; then
                    validate_url "MPI"
                fi
            fi
        fi
    elif [ "${mpi}" == "openmpi" ]; then
        # OpenMPI
        mpi_version_major_dot_minor="${mpi_version%.*}"
        mpi_version_major="${mpi_version_major_dot_minor%.*}"
        mpi_url="https://www.open-mpi.org/software/ompi/v${mpi_version_major_dot_minor}/\
downloads/openmpi-${mpi_version}.tar.gz"
        # Check if already installed and/or downloaded
        check_progress "MPI"
        # If not yet downloaded, validate the URL
        if [ "${mpi_downloaded}" != "True" ]; then
            validate_url "MPI" "False"
            if [ "${validate_url_status}" != "success" ]; then
                echo "Primary OpenMPI link broken: ${mpi_url}"
                error "Error: The installer does not know of a secondary OpenMPI link"
                exit 1
            fi
        fi
    fi
fi

# ncurses
if [ "${ncurses_install}" == "True" ]; then
    ncurses_url="http://ftp.gnu.org/gnu/ncurses/ncurses-${ncurses_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "ncurses"
    # If not yet downloaded, validate the URL
    if [ "${ncurses_downloaded}" != "True" ]; then
        validate_url "ncurses" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary ncurses link broken: ${ncurses_url}"
            fallback "ncurses"
            ncurses_url="http://ftpmirror.gnu.org/ncurses/ncurses-${ncurses_version}.tar.gz"
            echo "Using secondary ncurses link: ${ncurses_url}"
            # Check if already installed and/or downloaded
            check_progress "ncurses"
            # If not yet downloaded, validate the URL
            if [ "${ncurses_downloaded}" != "True" ]; then
                validate_url "ncurses"
            fi
        fi
    fi
fi

# BLAS
if [ "${blas_install}" == "True" ]; then
    blas_url="https://github.com/xianyi/OpenBLAS/archive/v${blas_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "BLAS"
    # If not yet downloaded, validate the URL
    if [ "${blas_downloaded}" != "True" ]; then
        validate_url "BLAS" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary OpenBLAS link broken: ${blas_url}"
            fallback "blas"
            blas_url="https://sourceforge.net/projects/openblas/files/v${blas_version}/\
OpenBLAS%20${blas_version}%20version.tar.gz"
            echo "Using secondary BLAS link: ${blas_url}"
            # Check if already installed and/or downloaded
            check_progress "BLAS"
            # If not yet downloaded, validate the URL
            if [ "${blas_downloaded}" != "True" ]; then
                validate_url "BLAS"
            fi
        fi
    fi
fi

# OpenSSL
if [ "${openssl_install}" == "True" ]; then
    openssl_url="https://www.openssl.org/source/openssl-${openssl_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "OpenSSL"
    # If not yet downloaded, validate the URL
    if [ "${openssl_downloaded}" != "True" ]; then
        validate_url "OpenSSL" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary OpenSSL link broken: ${openssl_url}"
            fallback "openssl"
            openssl_version_underscores="$(echo "${openssl_version}" | tr '.' '_')"
            openssl_url="https://github.com/openssl/openssl/archive/\
OpenSSL_${openssl_version_underscores}.tar.gz"
            echo "Using secondary OpenSSL link: ${openssl_url}"
            # Check if already installed and/or downloaded
            check_progress "OpenSSL"
            # If not yet downloaded, validate the URL
            if [ "${openssl_downloaded}" != "True" ]; then
                validate_url "OpenSSL"
            fi
        fi
    fi
fi

# libffi
if [ "${libffi_install}" == "True" ]; then
    libffi_url="ftp://sourceware.org/pub/libffi/libffi-${libffi_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "libffi"
    # If not yet downloaded, validate the URL
    if [ "${libffi_downloaded}" != "True" ]; then
        validate_url "libffi" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary libffi link broken: ${libffi_url}"
            fallback "libffi"
            libffi_url="https://sourceware.org/ftp/libffi/libffi-${libffi_version}.tar.gz"
            echo "Using secondary libffi link: ${libffi_url}"
            # Check if already installed and/or downloaded
            check_progress "libffi"
            # If not yet downloaded, validate the URL
            if [ "${libffi_downloaded}" != "True" ]; then
                validate_url "libffi"
            fi
        fi
    fi
fi

# Perl
if [ "${perl_install}" == "True" ]; then
    perl_url="http://www.cpan.org/src/5.0/perl-${perl_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "Perl"
    # If not yet downloaded, validate the URL
    if [ "${perl_downloaded}" != "True" ]; then
        validate_url "Perl" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary Perl link broken: ${perl_url}"
            error "Error: The installer does not know of a secondary Perl link"
            exit 1
        fi
    fi
fi

# Python
if [ "${python_install}" == "True" ]; then
    python_url="https://www.python.org/ftp/python/${python_version}/Python-${python_version}.tgz"
    # Check if already installed and/or downloaded
    check_progress "Python"
    # If not yet downloaded, validate the URL
    if [ "${python_downloaded}" != "True" ]; then
        validate_url "Python" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary Python link broken: ${python_url}"
            error "Error: The installer does not know of a secondary Python link"
            exit 1
        fi
    fi
fi

# zlib
if [ "${zlib_install}" == "True" ]; then
    zlib_url="http://sourceforge.net/projects/libpng/files/zlib/${zlib_version}/\
zlib-${zlib_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "zlib"
    # If not yet downloaded, validate the URL
    if [ "${zlib_downloaded}" != "True" ]; then
        validate_url "zlib" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary zlib link broken: ${zlib_url}"
            fallback "zlib"
            zlib_url="http://zlib.net/zlib-${zlib_version}.tar.gz"
            echo "Using secondary zlib link: ${zlib_url}"
            # Check if already installed and/or downloaded
            check_progress "zlib"
            # If not yet downloaded, validate the URL
            if [ "${zlib_downloaded}" != "True" ]; then
                validate_url "zlib"
            fi
        fi
    fi
fi

# Set "pypackage"_installed variables
blessings_installed="False"
cython_installed="False"
cythongsl_installed="False"
h5py_installed="False"
matplotlib_installed="False"
mpi4py_installed="False"
numpy_installed="False"
pytest_installed="False"
scipy_installed="False"
sphinx_installed="False"
sphinx_copybutton_installed="False"
sphinx_rtd_theme_installed="False"
sphinx_tabs_installed="False"
pip_installed="False"
if [ -n "${python_dir}" ]; then
    for python_version_major in 3 2; do
        if [ -f "${python_dir}/bin/python${python_version_major}" ]; then
            python_version_major_dot_minor=$("${python_dir}/bin/python${python_version_major}" -c \
                "from sys import version_info as v; print(str(v.major) + '.' + str(v.minor))")
            python="${python_dir}/bin/python${python_version_major_dot_minor}"
            break
        fi
    done
fi
if [ -n "${python}" ] && [ "${python_installed}" == "True" ]; then
    for pypackage in blessings         \
                     cython            \
                     cythongsl         \
                     h5py              \
                     matplotlib        \
                     mpi4py            \
                     numpy             \
                     pytest            \
                     scipy             \
                     sphinx            \
                     sphinx_copybutton \
                     sphinx_rtd_theme  \
                     sphinx_tabs       \
                     pip               \
    ; do
        pypackage_installed=$(check_pypackage_installed ${pypackage})
        eval "${pypackage}_installed=\"${pypackage_installed}\""
    done
fi

# Functions for printing out nice tables (these are superior to the
# "column" command on older systems, as this does not handle
# formatted output very well).
modify_element(){
    # Arguments: Character to be replaced, character to replace with
    for ((i = 0; i < nelements; i += 1)); do
        element="${table_to_print[i]}"
        table_to_print[i]="${element//$1/$2}"
    done
}
print_table(){
    # Arguments: Array to be printed (passed as array[@]),
    #            number of columns.
    table_to_print=("${!1}")
    nelements=${#table_to_print[@]}
    nc=${2}
    # Replace spaces with tildes
    modify_element " " "~"
    # Backup of table
    table_with_esc=("${table_to_print[@]}")
    # Remove escape sequences in table
    for format in "normal" "bold" "italic" "no_italic" "green" "blue"; do
        eval "esc_format=\${esc_${format}}"
        modify_element "$(echo "${esc_format}" | sed 's,\\,\\\\,g')" ""
    done
    # Determine largest length of each column
    maxlengths=($(for i in $(eval "echo {1..${nc}}"); do echo 0; done))
    c=0
    for ((i = 0; i < nelements; i += 1)); do
        length=${#table_to_print[i]}
        [ ${length} -gt ${maxlengths[c]} ] && maxlengths[c]=${length}
        ((c += 1))
        [ ${c} == ${nc} ] && c=0
    done
    # Count number of missing right spaces for each element
    c=0
    for ((i = 0; i < nelements; i += 1)); do
        element="${table_to_print[i]}"
        nspaces[i]=$((${maxlengths[${c}]} - ${#element}))
        ((c += 1))
        [ ${c} == ${nc} ] && c=0
    done
    # Reinsert spaces
    table_to_print=("${table_with_esc[@]}")
    modify_element "~" " "
    # Print the table
    c=0
    for ((i = 0; i < nelements; i += 1)); do
        printf "${table_to_print[i]}"  # Print element
        [ ${nspaces[i]} -gt 0 ] && printf ' %.0s' $(eval "echo {1..${nspaces[i]}}")  # Print spaces
        ((c += 1))
        [ ${c} == ${nc} ] ||        printf "  "  # Print extra spaces
        [ ${c} == ${nc} ] && c=0 && printf "\n"  # Print newline
    done
}

# Write out installation overview.
# This overview take the form of the following tables.
# Programs which should not be installed will not be shown.
# Programs already installed and programs to be patched by this
# installer will be noted.
#
# The following software will be installed
# Name           Version  Installation path
# COð˜•CEPT        ...      "/..."
# OpenBLAS       ...      "/..."
# CLASS          ...      "/..."
# FFTW           ...      "/..."
# FFTW           ...      "/..."
# FreeType       ...      "/..."
# Gadget         ...      "/..."
# GSL            ...      "/..."
# HDF5           ...      "/..."
# libffi         ...      "/..."
# libpng         ...      "/..."
# MPICH/OpenMPI  ...      "/..."
# ncurses        ...      "/..."
# OpenSSL        ...      "/..."
# Perl           ...      "/..."
# Python         ...      "/..."
# zlib           ...      "/..."
#
# The following Python packages will be installed
# Name               Version
# Blessings          ...
# Cython             ...
# CythonGSL          ...
# H5Py               ...
# Matplotlib         ...
# MPI4Py             ...
# NumPy              ...
# pytest             ...
# SciPy              ...
# Sphinx             ...
# sphinx_copybutton  ...
# sphinx_rtd_theme   ...
# sphinx_tabs        ...
blas_patch="False"
class_patch="True"
concept_patch="False"
fftw_patch="False"
fftw_for_gadget_patch="False"
freetype_patch="False"
gadget_patch="False"
gsl_patch="False"
hdf5_patch="False"
libffi_patch="False"
libpng_patch="False"
if [ "${mpi}" == "mpich" ]; then
    mpi_patch="False"
elif [ "${mpi}" == "openmpi" ]; then
    mpi_patch="False"
fi
openmpi_patch="False"
ncurses_patch="False"
openssl_patch="False"
perl_patch="False"
python_patch="False"
zlib_patch="False"
blessings_patch="False"
cython_patch="False"
cythongsl_patch="False"
h5py_patch="False"
matplotlib_patch="False"
mpi4py_patch="False"
numpy_patch="False"
pytest_patch="False"
scipy_patch="False"
sphinx_patch="False"
sphinx_copybutton_patch="False"
sphinx_rtd_theme_patch="False"
sphinx_tabs_patch="False"
footnote_patch="${esc_blue}*${esc_normal}"
footnote_installed="${esc_green}â€ ${esc_normal}"
insert_footnote_patch(){
    # Argument: Program/Python package name
    eval "program_installed=\"\${${1}_installed}\""
    eval "program_patch=\"\${${1}_patch}\""
    if [ "${program_installed}" == "False" ] && [ "${program_patch}" == "True" ]; then
        echo "${footnote_patch}"
    fi
}
insert_footnote_installed(){
    # Argument: Program/Python package name
    eval "program_installed=\"\${${1}_installed}\""
    if [ "${program_installed}" == "True" ]; then
        echo "${footnote_installed}"
    fi
}
if [ "${install_anything}" == "True" ]; then
    disable_status
    current_step="presentation of installation overview"
    heading "Installation overview"
fi
# Print out software installation overview
if [ "${install_any_software}" == "True" ]; then
    # Title
    table=("${esc_bold}Name${esc_normal}"    \
           "${esc_bold}Version${esc_normal}" \
           "${esc_bold}Installation path${esc_normal}")
    # COð˜•CEPT
    if [ "${concept_install}" == "True" ]; then
        table=("${table[@]}"                                       \
            "${esc_concept}$(insert_footnote_installed 'concept')" \
            "${concept_version}$(insert_footnote_patch 'concept')" \
            "\"${concept_dir}\"")
    fi
    # OpenBLAS
    if [ "${blas_install}" == "True" ]; then
        table=("${table[@]}"                                 \
            "OpenBLAS$(insert_footnote_installed 'blas')"    \
            "${blas_version}$(insert_footnote_patch 'blas')" \
            "\"${blas_dir}\"")
    fi
    # CLASS (which will be patched)
    if [ "${class_install}" == "True" ]; then
        table=("${table[@]}"                                   \
            "CLASS$(insert_footnote_installed 'class')"        \
            "${class_version}$(insert_footnote_patch 'class')" \
            "\"${class_dir}\"")
    fi
    # FFTW
    if [ "${fftw_install}" == "True" ]; then
        table=("${table[@]}"                                 \
            "FFTW$(insert_footnote_installed 'fftw')"        \
            "${fftw_version}$(insert_footnote_patch 'fftw')" \
            "\"${fftw_dir}\"")
    fi
    # FFTW for gadget
    if [ "${fftw_for_gadget_install}" == "True" ]; then
        table=("${table[@]}"                                                       \
            "FFTW$(insert_footnote_installed 'fftw_for_gadget')"                   \
            "${fftw_for_gadget_version}$(insert_footnote_patch 'fftw_for_gadget')" \
            "\"${fftw_for_gadget_dir}\"")
    fi
    # FreeType
    if [ "${freetype_install}" == "True" ]; then
        table=("${table[@]}"                                         \
            "FreeType$(insert_footnote_installed 'freetype')"        \
            "${freetype_version}$(insert_footnote_patch 'freetype')" \
            "\"${freetype_dir}\"")
    fi
    # Gadget
    if [ "${gadget_install}" == "True" ]; then
        table=("${table[@]}"                                     \
            "Gadget$(insert_footnote_installed 'gadget')"        \
            "${gadget_version}$(insert_footnote_patch 'gadget')" \
            "\"${gadget_dir}\"")
    fi
    # GSL
    if [ "${gsl_install}" == "True" ]; then
        table=("${table[@]}"                               \
            "GSL$(insert_footnote_installed 'gsl')"        \
            "${gsl_version}$(insert_footnote_patch 'gsl')" \
            "\"${gsl_dir}\"")
    fi
    # HDF5
    if [ "${hdf5_install}" == "True" ]; then
        table=("${table[@]}"                                 \
            "HDF5$(insert_footnote_installed 'hdf5')"        \
            "${hdf5_version}$(insert_footnote_patch 'hdf5')" \
            "\"${hdf5_dir}\"")
    fi
    # libffi
    if [ "${libffi_install}" == "True" ]; then
        table=("${table[@]}"                                     \
            "libffi$(insert_footnote_installed 'libffi')"        \
            "${libffi_version}$(insert_footnote_patch 'libffi')" \
            "\"${libffi_dir}\"")
    fi
    # libpng
    if [ "${libpng_install}" == "True" ]; then
        table=("${table[@]}"                                     \
            "libpng$(insert_footnote_installed 'libpng')"        \
            "${libpng_version}$(insert_footnote_patch 'libpng')" \
            "\"${libpng_dir}\"")
    fi
    # MPICH/OpenMPI
    if [ "${mpi_install}" == "True" ]; then
        if [ "${mpi}" == "mpich" ]; then
            table=("${table[@]}"                               \
                "MPICH$(insert_footnote_installed 'mpi')"      \
                "${mpi_version}$(insert_footnote_patch 'mpi')" \
                "\"${mpi_dir}\"")
        elif [ "${mpi}" == "openmpi" ]; then
            table=("${table[@]}"                               \
                "OpenMPI$(insert_footnote_installed 'mpi')"    \
                "${mpi_version}$(insert_footnote_patch 'mpi')" \
                "\"${mpi_dir}\"")
        fi
    fi
    # ncurses
    if [ "${ncurses_install}" == "True" ]; then
        table=("${table[@]}"                                       \
            "ncurses$(insert_footnote_installed 'ncurses')"        \
            "${ncurses_version}$(insert_footnote_patch 'ncurses')" \
            "\"${ncurses_dir}\"")
    fi
    # OpenSSL
    if [ "${openssl_install}" == "True" ]; then
        table=("${table[@]}"                                       \
            "OpenSSL$(insert_footnote_installed 'openssl')"        \
            "${openssl_version}$(insert_footnote_patch 'openssl')" \
            "\"${openssl_dir}\"")
    fi
    # Perl
    if [ "${perl_install}" == "True" ]; then
        table=("${table[@]}"                                 \
            "Perl$(insert_footnote_installed 'perl')"        \
            "${perl_version}$(insert_footnote_patch 'perl')" \
            "\"${perl_dir}\"")
    fi
    # Python
    if [ "${python_install}" == "True" ]; then
        table=("${table[@]}"                                     \
            "Python$(insert_footnote_installed 'python')"        \
            "${python_version}$(insert_footnote_patch 'python')" \
            "\"${python_dir}\"")
    fi
    # zlib
    if [ "${zlib_install}" == "True" ]; then
        table=("${table[@]}"                                 \
            "zlib$(insert_footnote_installed 'zlib')"        \
            "${zlib_version}$(insert_footnote_patch 'zlib')" \
            "\"${zlib_dir}\"")
    fi
    echo "The following software will be installed"
    print_table table[@] 3
    N_to_be_patched=0
    for (( i=4; i<${#table[@]}; i+=3 )); do
        if [[ "${table[i]}" == *"${footnote_patch}" ]]; then
            ((N_to_be_patched += 1))
        fi
    done
    N_installed=0
    for (( i=3; i<${#table[@]}; i+=3 )); do
        if [[ "${table[i]}" == *"${footnote_installed}" ]]; then
            ((N_installed += 1))
        fi
    done
fi

# Print out Python package installation overview
if [ "${install_any_pypackages}" == "True" ]; then
    # Title
    table=("${esc_bold}Name${esc_normal}" "${esc_bold}Version${esc_normal}" "")
    # Blessings
    if [ "${blessings_install}" == "True" ]; then
        table=("${table[@]}"                                           \
            "Blessings$(insert_footnote_installed 'blessings')"        \
            "${blessings_version}$(insert_footnote_patch 'blessings')" \
            "")
    fi
    # Cython
    if [ "${cython_install}" == "True" ]; then
        table=("${table[@]}"                                     \
            "Cython$(insert_footnote_installed 'cython')"        \
            "${cython_version}$(insert_footnote_patch 'cython')" \
            "")
    fi
    # CythonGSL
    if [ "${cythongsl_install}" == "True" ]; then
           table=("${table[@]}"                                        \
            "CythonGSL$(insert_footnote_installed 'cythongsl')"        \
            "${cythongsl_version}$(insert_footnote_patch 'cythongsl')" \
            "")
    fi
    # H5Py
    if [ "${h5py_install}" == "True" ]; then
        table=("${table[@]}"                                 \
            "H5Py$(insert_footnote_installed 'h5py')"        \
            "${h5py_version}$(insert_footnote_patch 'h5py')" \
            "")
    fi
    # Matplotlib
    if [ "${matplotlib_install}" == "True" ]; then
        table=("${table[@]}"                                             \
            "Matplotlib$(insert_footnote_installed 'matplotlib')"        \
            "${matplotlib_version}$(insert_footnote_patch 'matplotlib')" \
            "")
    fi
    # MPI4Py
    if [ "${mpi4py_install}" == "True" ]; then
        table=("${table[@]}"                                     \
            "MPI4Py$(insert_footnote_installed 'mpi4py')"        \
            "${mpi4py_version}$(insert_footnote_patch 'mpi4py')" \
            "")
    fi
    # NumPy
    if [ "${numpy_install}" == "True" ]; then
        table=("${table[@]}"                                   \
            "NumPy$(insert_footnote_installed 'numpy')"        \
            "${numpy_version}$(insert_footnote_patch 'numpy')" \
            "")
    fi
    # Pytest
    if [ "${pytest_install}" == "True" ]; then
        table=("${table[@]}"                                     \
            "pytest$(insert_footnote_installed 'pytest')"        \
            "${pytest_version}$(insert_footnote_patch 'pytest')" \
            "")
    fi
    # SciPy
    if [ "${scipy_install}" == "True" ]; then
        table=("${table[@]}"                                   \
            "SciPy$(insert_footnote_installed 'scipy')"        \
            "${scipy_version}$(insert_footnote_patch 'scipy')" \
            "")
    fi
    # Sphinx
    if [ "${sphinx_install}" == "True" ]; then
        table=("${table[@]}"                                     \
            "Sphinx$(insert_footnote_installed 'sphinx')"        \
            "${sphinx_version}$(insert_footnote_patch 'sphinx')" \
            "")
    fi
    # sphinx_copybutton
    if [ "${sphinx_copybutton_install}" == "True" ]; then
        table=("${table[@]}"                                                           \
            "sphinx_copybutton$(insert_footnote_installed 'sphinx_copybutton')"        \
            "${sphinx_copybutton_version}$(insert_footnote_patch 'sphinx_copybutton')" \
            "")
    fi
    # sphinx_rtd_theme
    if [ "${sphinx_rtd_theme_install}" == "True" ]; then
        table=("${table[@]}"                                                         \
            "sphinx_rtd_theme$(insert_footnote_installed 'sphinx_rtd_theme')"        \
            "${sphinx_rtd_theme_version}$(insert_footnote_patch 'sphinx_rtd_theme')" \
            "")
    fi
    # sphinx_tabs
    if [ "${sphinx_tabs_install}" == "True" ]; then
        table=("${table[@]}"                                               \
            "sphinx_tabs$(insert_footnote_installed 'sphinx_tabs')"        \
            "${sphinx_tabs_version}$(insert_footnote_patch 'sphinx_tabs')" \
            "")
    fi
    if [ "${install_any_software}" ]; then
        echo
    fi
    echo "The following Python packages will be installed"
    print_table table[@] 3
    for (( i=3; i<${#table[@]}; i+=3 )); do
        if [[ "${table[i]}" == *"${footnote_patch}" ]]; then
            ((N_installed += 1))
        fi
    done
    for (( i=4; i<${#table[@]}; i+=3 )); do
        if [[ "${table[i]}" == *"${footnote_installed}" ]]; then
            ((N_to_be_patched += 1))
        fi
    done
fi
echo
if [ -n "${N_to_be_patched}" ]; then
    if [ ${N_to_be_patched} -eq 1 ]; then
        printf "${footnote_patch} This will be patched by the installer\n"
    elif [ ${N_to_be_patched} -gt 1 ]; then
        printf "${footnote_patch} These will be patched by the installer\n"
    fi
fi
if [ -n "${N_installed}" ]; then
    if [ ${N_installed} -eq 1 ]; then
        printf "${footnote_installed} This is already installed and will not be reinstalled\n"
    elif [ ${N_installed} -gt 1 ]; then
        printf "${footnote_installed} These are already installed and will not be reinstalled\n"
    fi
fi

# Find possible C, C++ and Fortran compilers to try out when building
# the various programs. The compiler possibilities will be gathered in
# the array "compiler_possibilities". An empty value corresponds to
# whatever compilers (if any) were set in the environment at the time of
# invocation of this script. For each compiler (e.g. "gnu") detected,
# there must be declared a corresponding function
# (e.g. "use_gnu_compilers"), the job of which is to set compiler
# environment variables such as CC, CXX and FC.
# Altering PATH-like environment variables is also allowed.
# The order in which the compilers appear in compiler_possibilities is
# the order in which they will be tried out when installing programs.
# This ordering may be set by the compiler_precedence
# environment variable.
compiler_precedence="$(echo "${compiler_precedence}" | tr '[:upper:]' '[:lower:]')"
IFS=' ' read -r -a compiler_precedence_arr <<< "${compiler_precedence}"
compiler_precedence=("${compiler_precedence_arr[@]}")
compiler_precedence_default=( \
    "specified_mpi" "default" "gnu" "clang" "mpi" "intel" "cray" "portland" "generic" "unset")
for compiler in "${compiler_precedence_default[@]}"; do
    present=False
    for compiler_present in "${compiler_precedence[@]}"; do
        if [ "${compiler_present}" == "${compiler}" ]; then
            present=True
            break
        fi
    done
    if [ "${present}" == "False" ]; then
        compiler_precedence=("${compiler_precedence[@]}" "${compiler}")
    fi
done
discover_specified_mpi_compilers(){
    if [ "${mpi_preinstalled}" == "True" ]; then
        compiler_possibilities=("${compiler_possibilities[@]}" "specified_mpi")
    fi
}
discover_default_compilers(){
    compiler_possibilities=("${compiler_possibilities[@]}" "default")
}
discover_gnu_compilers(){
    for program in "gcc" "g++" "gfortran"; do
        program_path="$(get_command "${program}")" || :
        if [ -n "${program_path}" ]; then
            compiler_possibilities=("${compiler_possibilities[@]}" "gnu")
            break
        fi
    done
}
discover_clang_compilers(){
    for program in "clang" "clang++"; do
        program_path="$(get_command "${program}")" || :
        if [ -n "${program_path}" ]; then
            compiler_possibilities=("${compiler_possibilities[@]}" "clang")
            break
        fi
    done
}
discover_mpi_compilers(){
    for program in "mpicc" "mpiCC" "mpicxx" "mpic++" "mpifort" "mpif90"; do
        program_path="$(get_command "${program}")" || :
        if [ -n "${program_path}" ]; then
            compiler_possibilities=("${compiler_possibilities[@]}" "mpi")
            break
        fi
    done
}
discover_intel_compilers(){
    for program in "icc" "icpc" "ifort"; do
        program_path="$(get_command "${program}")" || :
        if [ -n "${program_path}" ]; then
            compiler_possibilities=("${compiler_possibilities[@]}" "intel")
            break
        fi
    done
}
discover_cray_compilers(){
    for program in "craycc" "crayCC" "crayftn"; do
        program_path="$(get_command "${program}")" || :
        if [ -n "${program_path}" ]; then
            compiler_possibilities=("${compiler_possibilities[@]}" "cray")
            break
        fi
    done
}
discover_portland_compilers(){
    for program in "pgcc" "pgCC" "pgf77" "pgf90"; do
        program_path="$(get_command "${program}")" || :
        if [ -n "${program_path}" ]; then
            compiler_possibilities=("${compiler_possibilities[@]}" "portland")
            break
        fi
    done
}
discover_generic_compilers(){
    for program in "cc" "c89" "c99" "CC" "c++" "ftn" "f77" "f90" "fortran"; do
        program_path="$(get_command "${program}")" || :
        if [ -n "${program_path}" ]; then
            compiler_possibilities=("${compiler_possibilities[@]}" "generic")
            break
        fi
    done
}
discover_unset_compilers(){
    compiler_possibilities=("${compiler_possibilities[@]}" "unset")
}
compiler_possibilities=()
for compiler in "${compiler_precedence[@]}"; do
    eval "discover_${compiler}_compilers"
done
printf "\n${esc_bold}Compiler precedence${esc_normal}\n"
printf "${compiler_possibilities[0]}"
for ((i = 1; i < ${#compiler_possibilities[@]}; i += 1)); do
    compiler="${compiler_possibilities[$i]}"
    printf " > ${compiler}"
done
printf "\n"
if [ "${install_anything}" == "True" ]; then
    echo
    sleep ${sleep_time}
    enable_status
fi
use_default_compilers(){
    # This dummy function must exist
    :
}
use_specified_mpi_compilers(){
    local program program_path bin_path include_path lib_path
    if [ -n "${mpi_dir}" ]; then
        compiler_path="${mpi_compilerdir}"
        bin_path="${mpi_bindir}"
        include_path="${mpi_includedir}"
        lib_path="${mpi_libdir}"
        for program in "mpicc" "mpiCC"; do
            program_path="${compiler_path}/${program}"
            if [ -f "${program_path}" ]; then
                export CC="${program_path}"
                break
            fi
            program_path="${bin_path}/${program}"
            if [ -f "${program_path}" ]; then
                export CC="${program_path}"
                break
            fi
        done
        for program in "mpicxx" "mpic++"; do
            program_path="${compiler_path}/${program}"
            if [ -f "${program_path}" ]; then
                export CXX="${program_path}"
                break
            fi
            program_path="${bin_path}/${program}"
            if [ -f "${program_path}" ]; then
                export CXX="${program_path}"
                break
            fi
        done
        for program in "mpif77"; do
            program_path="${compiler_path}/${program}"
            if [ -f "${program_path}" ]; then
                export FC="${program_path}"
                export F77="${program_path}"
                break
            fi
            program_path="${bin_path}/${program}"
            if [ -f "${program_path}" ]; then
                export FC="${program_path}"
                export F77="${program_path}"
                break
            fi
        done
        for program in "mpifort" "mpif90"; do
            program_path="${compiler_path}/${program}"
            if [ -f "${program_path}" ]; then
                export FC="${program_path}"
                export F90="${program_path}"
                export F9X="${program_path}"
                break
            fi
            program_path="${bin_path}/${program}"
            if [ -f "${program_path}" ]; then
                export FC="${program_path}"
                export F90="${program_path}"
                export F9X="${program_path}"
                break
            fi
        done
        if [ -d "${compiler_path}" ]; then
            export PATH="${compiler_path}:${PATH}"
        fi
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export CFLAGS="-I${include_path} ${CFLAGS}"
            export CXXFLAGS="-I${include_path} ${CXXFLAGS}"
            export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
            export FFLAGS="-I${include_path} ${FFLAGS}"
            export FCFLAGS="-I${include_path} ${FCFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
        # When mixing MPICH and Intel MPI, some symlinking is required
        # due to different library names, as described in section 11 of
        # https://www.mpich.org/static/downloads/3.1/mpich-3.1-README.txt
        mkdir -p "${mpi_symlinkdir}"
        mpi_symlink_pairs=(                      \
            "libmpi.so"      "libmpich.so.12"    \
            "libmpi_dbg.so"  "libmpich.so.12"    \
            "libmpigc4.so"   "libmpichcxx.so.12" \
            "libmpigc4.so"   "libmpichcxx.so.12" \
            "libmpigf.so"    "libfmpich.so.12"   \
            "libmpigf.so"    "libmpichf90.so.12" \
            "libmpi_dbg.so"  "libmpl.so.1"       \
            "libmpi.so"      "libmpl.so.1"       \
            "libmpi.so"      "libopa.so.1"       \
            "libmpi_dbg.so"  "libopa.so.1"       \
            "libmpich.so"    "libmpi.so.5"       \
            "libmpich.so"    "libmpi_dbg.so.5"   \
            "libmpichcxx.so" "libmpigc4.so.5"    \
            "libmpichf90.so" "libmpigf.so.5"     \
            "libmpi.so"      "libmpi.so"         \
            "libmpi.so"      "libmpi.so.5"       \
            "libmpi.so"      "libmpi.so.12"      \
            "libmpi.so.5"    "libmpi.so"         \
            "libmpi.so.5"    "libmpi.so.5"       \
            "libmpi.so.5"    "libmpi.so.12"      \
            "libmpi.so.12"   "libmpi.so"         \
            "libmpi.so.12"   "libmpi.so.5"       \
            "libmpi.so.12"   "libmpi.so.12"      \
        )
        any_mpi_symlinks="False"
        for ((mpi_symlink_index=0; mpi_symlink_index<${#mpi_symlink_pairs[@]}; \
            mpi_symlink_index+=2)); do
            ((mpi_symlink_name_index = mpi_symlink_index + 1))
            mpi_symlink="${lib_path}/${mpi_symlink_pairs[${mpi_symlink_index}]}"
            mpi_symlink_name="${mpi_symlinkdir}/${mpi_symlink_pairs[${mpi_symlink_name_index}]}"
            if [ -f "${mpi_symlink}" ]; then
                any_mpi_symlinks="True"
                if [ ! -f "${mpi_symlink_name}" ]; then
                    ln -s "${mpi_symlink}" "${mpi_symlink_name}" >/dev/null 2>&1 || :
                fi
            fi
        done
        if [ "${any_mpi_symlinks}" == "True" ]; then
            export LDFLAGS="${LDFLAGS} -L${mpi_symlinkdir}"
            export LD_LIBRARY_PATH="${LD_LIBRARY_PATH}:${mpi_symlinkdir}"
            # Using MVAPICH2 together with Python (or Fortran) can cause
            # trouble as described in section 9.1.1 of
            # http://mvapich.cse.ohio-state.edu/static/media/mvapich/
            # mvapich2-2.3b-userguide.html#x1-1280009.1.1
            # Setting the LD_PRELOAD variable should fix this.
            if [ ! -f "${mpi_symlinkdir}/ld_preload.so" ]; then
                current_dir="$(pwd)"
                cd "${mpi_symlinkdir}"
                f_lib=""
                n_lib=""
                for f in *; do
                    if [[ "${f}" == "libmpi.so"* ]]; then
                        n="${f#*.}"
                        if [ "${n}" == "so" ]; then
                            f_lib="${f}"
                            break
                        fi
                        n="${n#*.}"
                        if [ -z "${n_lib}" ] || [[ "${n_lib}" == *"."* ]] \
                            || [ "${n}" -lt "${n_lib}" ]; then
                            f_lib="${f}"
                            n_lib="${n}"
                        fi
                    fi
                done
                cd "${current_dir}"
                if [ -n "${f_lib}" ]; then
                    ln -s "${mpi_symlinkdir}/${f_lib}" "${mpi_symlinkdir}/ld_preload.so" \
                        >/dev/null 2>&1 || :
                fi
            fi
            if [ -f "${mpi_symlinkdir}/ld_preload.so" ]; then
                export LD_PRELOAD="${LD_PRELOAD} ${mpi_symlinkdir}/ld_preload.so"
            fi
        else
            rm -rf "${mpi_symlinkdir}"
        fi
        # Test whether the MPI environment is sane.
        # If not, a warning will be printed,
        # but the installation will carry on regardless.
        current_dir="$(pwd)"
        MPI_LIBS_backup="${MPI_LIBS}"
        if [ -d "${mpi_libdir}" ]; then
            MPI_LIBS="${MPI_LIBS} -L${mpi_libdir} -Wl,-rpath=${mpi_libdir}"
        fi
        if [ -d "${mpi_symlinkdir}" ]; then
            MPI_LIBS="${MPI_LIBS} -L${mpi_symlinkdir} -Wl,-rpath=${mpi_symlinkdir}"
        fi
        if [ -d "${mpi_libdir}" ]; then
            cd "${mpi_libdir}"
            mpi_lib_found="False"
            for f in *; do
                if [[ "${f}" == libmpi.* ]]; then
                    MPI_LIBS="${MPI_LIBS} -lmpi"
                    mpi_lib_found="True"
                    break
                fi
            done
            if [ "${mpi_lib_found}" == "False" ]; then
                for f in *; do
                    if [[ "${f}" == libmpich.* ]]; then
                        MPI_LIBS="${MPI_LIBS} -lmpich"
                        mpi_lib_found="True"
                        break
                    fi
                done
            fi
            cd "${current_dir}"
        fi
        mpi_test_dir="${top_dir}/tmp/mpi_test"
        rm -rf "${mpi_test_dir}" || :
        mkdir -p "${mpi_test_dir}"
        cd "${mpi_test_dir}"
        echo '
#include <mpi.h>
#include <stdio.h>
int main(int argc, char *argv[]) {
  MPI_Init(&argc, &argv);
  int master_rank = 0;
  int rank, number, sum;
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  if (rank == 0) {
    number = 22;
    MPI_Send(&number, 1, MPI_INT, 1, 0, MPI_COMM_WORLD);
  } else if (rank == 1) {
    MPI_Recv(&number, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
  } else {
    number = -1;
  }
  MPI_Reduce(&number, &sum, 1, MPI_INT, MPI_SUM, master_rank, MPI_COMM_WORLD);
  if (rank == 0) {
    printf("\nMPI test result = %d\n", sum);
  }
  MPI_Finalize();
  return 0;
}
' > "test.c"
        mpicc ${CFLAGS} -c -o "test.o" "test.c" >/dev/null 2>&1 || :
        mpicc "test.o" -o "test" ${LDFLAGS} ${MPI_LIBS} >/dev/null 2>&1 || :
        mpi_environment_test_success="False"
        mpi_environment_result="$("${mpi_bindir}/mpiexec" -n 4 "./test" 2>/dev/null \
            | grep 'MPI test result =' | awk '{print $NF}' || :)"
        if [ "${mpi_environment_result}" == "42" ]; then
            mpi_environment_test_success="True"
        fi
        cd "${current_dir}"
        rm -rf "${mpi_test_dir}" || :
        MPI_LIBS="${MPI_LIBS_backup}"
        if [ "${mpi_environment_test_success}" == "False" ]; then
            printf "\n\nWarning: The MPI environment does not appear sane!\n\n"
        fi
    fi
}
use_gnu_compilers(){
    local program_path bin_path include_path lib_path
    program_path="$(get_command "gcc")" || :
    if [ -n "${program_path}" ]; then
        export CC="${program_path}"
        export CXX="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export CFLAGS="-I${include_path} ${CFLAGS}"
            export CXXFLAGS="-I${include_path} ${CXXFLAGS}"
            export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    program_path="$(get_command "g++")" || :
    if [ -n "${program_path}" ]; then
        export CXX="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export CXXFLAGS="-I${include_path} ${CXXFLAGS}"
            export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    program_path="$(get_command "gfortran")" || :
    if [ -n "${program_path}" ]; then
        export FC="${program_path}"
        export F77="${program_path}"
        export F90="${program_path}"
        export F9X="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export FFLAGS="-I${include_path} ${FFLAGS}"
            export FCFLAGS="-I${include_path} ${FCFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
}
use_clang_compilers(){
    local program_path bin_path include_path lib_path
    program_path="$(get_command "clang")" || :
    if [ -n "${program_path}" ]; then
        export CC="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export CFLAGS="-I${include_path} ${CFLAGS}"
            export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    program_path="$(get_command "clang++")" || :
    if [ -n "${program_path}" ]; then
        export CXX="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export CXXFLAGS="-I${include_path} ${CXXFLAGS}"
            export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    # Clang does not have a Fortran compiler
}
use_mpi_compilers(){
    local program program_path bin_path include_path lib_path
    for program in "mpicc" "mpiCC"; do
        program_path="$(get_command "${program}")" || :
        if [ -n "${program_path}" ]; then
            export CC="${program_path}"
            bin_path="$(dirname "${program_path}")"
            mpicc_show="$("${CC}" -show || :)"
            lib_paths="$(echo "${mpicc_show}" | grep -o '\-L[^ ]*' || :)"
            n_lib_paths=$(echo "${lib_paths}" | wc -l)
            if [ ${n_lib_paths} -eq 1 ]; then
                lib_path="${lib_paths:2}"
            else
                # Several lib directories exist.
                # Merge them via symlinking.
                lib_path_merged="${mpi_symlinkdir}/merged_lib"
                mkdir -p "${lib_path_merged}"
                while read lib_path; do
                    lib_path="${lib_path:2}"
                    if [ -d "${lib_path}" ]; then
                        for f in "${lib_path}/"*; do
                            f_base="$(basename "${f}")"
                            mpi_symlink_name="${lib_path_merged}/${f_base}"
                            if     [ ! -f "${mpi_symlink_name}" ] \
                                && [ ! -d "${mpi_symlink_name}" ]; then
                                ln -s "${f}" "${mpi_symlink_name}" >/dev/null 2>&1 || :
                            fi
                        done
                    fi
                done <<< "${lib_paths}"
                lib_path="${lib_path_merged}"
            fi
            if [ ! -d "${lib_path}" ]; then
                lib_path="$(dirname "${bin_path}")/lib"
            fi
            include_paths="$(echo "${mpicc_show}" | grep -o '\-I[^ ]*' || :)"
            n_include_paths=$(echo "${include_paths}" | wc -l)
            if [ ${n_include_paths} -eq 1 ]; then
                include_path="${include_paths:2}"
            else
                # Several include directories exist.
                # Merge them via symlinking.
                include_path_merged="${mpi_symlinkdir}/merged_include"
                mkdir -p "${include_path_merged}"
                while read include_path; do
                    include_path="${include_path:2}"
                    if [ -d "${include_path}" ]; then
                        for f in "${include_path}/"*; do
                            f_base="$(basename "${f}")"
                            mpi_symlink_name="${include_path_merged}/${f_base}"
                            if     [ ! -f "${mpi_symlink_name}" ] \
                                && [ ! -d "${mpi_symlink_name}" ]; then
                                ln -s "${f}" "${mpi_symlink_name}" >/dev/null 2>&1 || :
                            fi
                        done
                    fi
                done <<< "${include_paths}"
                include_path="${include_path_merged}"
            fi
            if [ ! -d "${include_path}" ]; then
                include_path="$(dirname "${bin_path}")/include"
            fi
            if [ -d "${bin_path}" ]; then
                export PATH="${bin_path}:${PATH}"
            fi
            if [ -d "${include_path}" ]; then
                export CFLAGS="-I${include_path} ${CFLAGS}"
                export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
            fi
            if [ -d "${lib_path}" ]; then
                export LDFLAGS="-L${lib_path} ${LDFLAGS}"
                export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
            fi
            break
        fi
    done
    for program in "mpicxx" "mpic++"; do
        program_path="$(get_command "${program}")" || :
        if [ -n "${program_path}" ]; then
            export CXX="${program_path}"
            bin_path="$(dirname "${program_path}")"
            include_path="${bin_path}/../include"
            lib_path="${bin_path}/../lib"
            if [ -d "${bin_path}" ]; then
                export PATH="${bin_path}:${PATH}"
            fi
            if [ -d "${include_path}" ]; then
                export CXXFLAGS="-I${include_path} ${CXXFLAGS}"
                export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
            fi
            if [ -d "${lib_path}" ]; then
                export LDFLAGS="-L${lib_path} ${LDFLAGS}"
                export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
            fi
            break
        fi
    done
    program_path="$(get_command "mpif77")" || :
    if [ -n "${program_path}" ]; then
        export FC="${program_path}"
        export F77="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export FFLAGS="-I${include_path} ${FFLAGS}"
            export FCFLAGS="-I${include_path} ${FCFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    for program in "mpifort" "mpif90"; do
        program_path="$(get_command "${program}")" || :
        if [ -n "${program_path}" ]; then
            export FC="${program_path}"
            export F90="${program_path}"
            export F9X="${program_path}"
            bin_path="$(dirname "${program_path}")"
            include_path="${bin_path}/../include"
            lib_path="${bin_path}/../lib"
            if [ -d "${bin_path}" ]; then
                export PATH="${bin_path}:${PATH}"
            fi
            if [ -d "${include_path}" ]; then
                export FFLAGS="-I${include_path} ${FFLAGS}"
                export FCFLAGS="-I${include_path} ${FCFLAGS}"
            fi
            if [ -d "${lib_path}" ]; then
                export LDFLAGS="-L${lib_path} ${LDFLAGS}"
                export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
            fi
            break
        fi
    done
}
use_intel_compilers(){
    local program_path bin_path include_path lib_path
    program_path="$(get_command "icc")" || :
    if [ -n "${program_path}" ]; then
        export CC="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export CFLAGS="-I${include_path} ${CFLAGS}"
            export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    program_path="$(get_command "icpc")" || :
    if [ -n "${program_path}" ]; then
        export CXX="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export CXXFLAGS="-I${include_path} ${CXXFLAGS}"
            export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    program_path="$(get_command "ifort")" || :
    if [ -n "${program_path}" ]; then
        export FC="${program_path}"
        export F77="${program_path}"
        export F90="${program_path}"
        export F9X="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export FFLAGS="-I${include_path} ${FFLAGS}"
            export FCFLAGS="-I${include_path} ${FCFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
}
use_cray_compilers(){
    local program_path bin_path include_path lib_path
    program_path="$(get_command "craycc")" || :
    if [ -n "${program_path}" ]; then
        export CC="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export CFLAGS="-I${include_path} ${CFLAGS}"
            export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    program_path="$(get_command "crayCC")" || :
    if [ -n "${program_path}" ]; then
        export CXX="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export CXXFLAGS="-I${include_path} ${CXXFLAGS}"
            export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    program_path="$(get_command "crayftn")" || :
    if [ -n "${program_path}" ]; then
        export FC="${program_path}"
        export F77="${program_path}"
        export F90="${program_path}"
        export F9X="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export FFLAGS="-I${include_path} ${FFLAGS}"
            export FCFLAGS="-I${include_path} ${FCFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
}
use_portland_compilers(){
    local program_path bin_path include_path lib_path
    program_path="$(get_command "pgcc")" || :
    if [ -n "${program_path}" ]; then
        export CC="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export CFLAGS="-I${include_path} ${CFLAGS}"
            export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    program_path="$(get_command "pgCC")" || :
    if [ -n "${program_path}" ]; then
        export CXX="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export CXXFLAGS="-I${include_path} ${CXXFLAGS}"
            export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    program_path="$(get_command "pgf77")" || :
    if [ -n "${program_path}" ]; then
        export FC="${program_path}"
        export F77="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export FFLAGS="-I${include_path} ${FFLAGS}"
            export FCFLAGS="-I${include_path} ${FCFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    program_path="$(get_command "pgf90")" || :
    if [ -n "${program_path}" ]; then
        export FC="${program_path}"
        export F90="${program_path}"
        export F9X="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export FFLAGS="-I${include_path} ${FFLAGS}"
            export FCFLAGS="-I${include_path} ${FCFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
}
use_generic_compilers(){
    local program program_path bin_path include_path lib_path
    for program in "cc" "c89" "c99"; do
        program_path="$(get_command "${program}")" || :
        if [ -n "${program_path}" ]; then
            export CC="${program_path}"
            bin_path="$(dirname "${program_path}")"
            include_path="${bin_path}/../include"
            lib_path="${bin_path}/../lib"
            if [ -d "${bin_path}" ]; then
                export PATH="${bin_path}:${PATH}"
            fi
            if [ -d "${include_path}" ]; then
                export CFLAGS="-I${include_path} ${CFLAGS}"
                export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
            fi
            if [ -d "${lib_path}" ]; then
                export LDFLAGS="-L${lib_path} ${LDFLAGS}"
                export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
            fi
            break
        fi
    done
    for program in "CC" "c++"; do
        program_path="$(get_command "${program}")" || :
        if [ -n "${program_path}" ]; then
            export CXX="${program_path}"
            bin_path="$(dirname "${program_path}")"
            include_path="${bin_path}/../include"
            lib_path="${bin_path}/../lib"
            if [ -d "${bin_path}" ]; then
                export PATH="${bin_path}:${PATH}"
            fi
            if [ -d "${include_path}" ]; then
                export CXXFLAGS="-I${include_path} ${CXXFLAGS}"
                export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
            fi
            if [ -d "${lib_path}" ]; then
                export LDFLAGS="-L${lib_path} ${LDFLAGS}"
                export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
            fi
            break
        fi
    done
    program_path="$(get_command "f77")" || :
    if [ -n "${program_path}" ]; then
        export FC="${program_path}"
        export F77="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export FFLAGS="-I${include_path} ${FFLAGS}"
            export FCFLAGS="-I${include_path} ${FCFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    for program in "ftn" "f90" "f9x" "fortran"; do
        program_path="$(get_command "${program}")" || :
        if [ -n "${program_path}" ]; then
            export FC="${program_path}"
            export F90="${program_path}"
            export F9X="${program_path}"
            bin_path="$(dirname "${program_path}")"
            include_path="${bin_path}/../include"
            lib_path="${bin_path}/../lib"
            if [ -d "${bin_path}" ]; then
                export PATH="${bin_path}:${PATH}"
            fi
            if [ -d "${include_path}" ]; then
                export FFLAGS="-I${include_path} ${FFLAGS}"
                export FCFLAGS="-I${include_path} ${FCFLAGS}"
            fi
            if [ -d "${lib_path}" ]; then
                export LDFLAGS="-L${lib_path} ${LDFLAGS}"
                export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
            fi
            break
        fi
    done
}
use_unset_compilers(){
    unset CC CXX FC F90 F9X CFLAGS CXXFLAGS CPPFLAGS FCFLAGS FFLAGS LDFLAGS
}



#################################
# Download COð˜•CEPT dependencies #
#################################
# Function for downloading compressed archives
download(){
    # Arguments: Program name, [print_heading]
    progname_formatted="$1"
    progname="${progname_formatted// /_}"
    progname="$(echo "${progname}" | tr '[:upper:]' '[:lower:]')"
    print_heading="${2}"
    if [ -z "${print_heading}" ]; then
        print_heading="True"
    fi
    # Do not download if already fully downloaded
    eval "prog_downloaded=\"\${${progname}_downloaded}\""
    if [ "${prog_downloaded}" == "True" ]; then
        return
    fi
    eval "progversion=\"\${${progname}_version}\""
    if [ "${print_heading}" != "False" ]; then
        if [ "${progname}" == "fftw_for_gadget" ]; then
            # When downloading FFTW for GADGET, the version number should
            # be printed together with FFTW, not GADGET.
            current_step="the downloading of FFTW ${progversion} for GADGET"
            heading "Downloading FFTW ${progversion} for GADGET"
        elif [ "${progname}" == "mpi" ]; then
            if [ "${mpi}" == "mpich" ]; then
                current_step="the downloading of MPICH ${progversion}"
                heading "Downloading MPICH ${progversion}"
            elif [ "${mpi}" == "openmpi" ]; then
                current_step="the downloading of OpenMPI ${progversion}"
                heading "Downloading OpenMPI ${progversion}"
            fi
        else
            current_step="the downloading of ${1/CONCEPT/$esc_concept} ${progversion}"
            heading "Downloading ${1/CONCEPT/$esc_concept} ${progversion}"
        fi
    fi
    eval "url=\"\${${progname}_url}\""
    # Download
    mkdir -p "${top_dir}/tmp/${progname}"
    cd "${top_dir}/tmp/${progname}"
    for n in {1..10}; do
        for ipv in "--inet4-only" "--inet6-only" ""; do
            for no_dns_cache in "--no-dns-cache" ""; do
                for progressbar in "--progress=bar:force" ""; do
                    wget_status="success"
                    wget ${progressbar} -t 1 --timeout 60 -c --no-check-certificate \
                        ${no_dns_cache} ${ipv} "${url}" || wget_status="error"
                    if [ "${wget_status}" == "success" ]; then
                        break
                    fi
                done
                if [ "${wget_status}" == "success" ]; then
                    break
                fi
            done
            if [ "${wget_status}" == "success" ]; then
                break
            fi
        done
        if [ "${wget_status}" == "success" ]; then
            break
        fi
        sleep 5
    done
    if [ "${wget_status}" == "error" ]; then
        error "Error downloading \"${url}\""
        exit 1
    fi
    # Write out success notice
    echo "The following has been fully downloaded:
File:    $(ls -t -1 | head -n 1)
URL:     ${url}
Program: ${progname_formatted}
Version: ${progversion}
Date:    $(date)
" > ".download_finished"
    cd "${top_dir}"
}

# Make the directory in which to dump all downloaded archives
mkdir -p "${top_dir}/tmp"
# Download the source code for all programs that should be installed
disable_status
if [ "${concept_install}" == "True" ] && [ "${concept_downloaded}" == "False" ]; then
    download "CONCEPT"
fi
if [ "${blas_install}" == "True" ] && [ "${blas_downloaded}" == "False" ]; then
    download "BLAS"
fi
if [ "${class_install}" == "True" ] && [ "${class_downloaded}" == "False" ]; then
    download "CLASS"
fi
if [ "${fftw_install}" == "True" ] && [ "${fftw_downloaded}" == "False" ]; then
    download "FFTW"
fi
if [ "${fftw_for_gadget_install}" == "True" ] \
    && [ "${fftw_for_gadget_downloaded}" == "False" ]; then
    download "FFTW for GADGET"
fi
if [ "${freetype_install}" == "True" ] && [ "${freetype_downloaded}" == "False" ]; then
    download "FreeType"
fi
if [ "${gadget_install}" == "True" ] && [ "${gadget_downloaded}" == "False" ]; then
    download "GADGET"
fi
if [ "${gsl_install}" == "True" ] && [ "${gsl_downloaded}" == "False" ]; then
    download "GSL"
fi
if [ "${hdf5_install}" == "True" ] && [ "${hdf5_downloaded}" == "False" ]; then
    download "HDF5"
fi
if [ "${libpng_install}" == "True" ] && [ "${libpng_downloaded}" == "False" ]; then
    download "libpng"
fi
if [ "${mpi_install}" == "True" ] && [ "${mpi_downloaded}" == "False" ]; then
    download "MPI"
fi
if [ "${ncurses_install}" == "True" ] && [ "${ncurses_downloaded}" == "False" ]; then
    download "ncurses"
fi
if [ "${openssl_install}" == "True" ] && [ "${openssl_downloaded}" == "False" ]; then
    download "OpenSSL"
fi
if [ "${libffi_install}" == "True" ] && [ "${libffi_downloaded}" == "False" ]; then
    download "libffi"
fi
if [ "${perl_install}" == "True" ] && [ "${perl_downloaded}" == "False" ]; then
    download "Perl"
fi
if [ "${python_install}" == "True" ] && [ "${python_downloaded}" == "False" ]; then
    download "Python"
fi
if [ "${zlib_install}" == "True" ] && [ "${zlib_downloaded}" == "False" ]; then
    download "zlib"
fi
enable_status



################################
# Install COð˜•CEPT dependencies #
################################
# Function for extracting compressed files
extract(){
    # Arguments: Program name, [is_file]
    # Here, the optional is_file argument can be set to "True" if
    # the first argument is a filename rather than a program name.
    # In that case, the working directory will not be changed.
    if [ "$2" == "True" ]; then
        archive="$1"
    else
        progname="${1// /_}"
        progname="$(echo "${progname}" | tr '[:upper:]' '[:lower:]')"
        cd "${top_dir}/tmp/${progname}"
        # We assume that any directories placed here is from a similar
        # previous call which went wrong. Delete any of these
        # directories before extracting.
        n_files=0
        for f in *; do
            if [ -d "${f}" ]; then
                for n in {1..720}; do
                    rm_success="True"
                    rm -rf "${f}" || rm_success="False"
                    if [ "${rm_success}" == "True" ]; then
                        break
                    fi
                    sleep 5
                done
            else
                archive="${f}"
                ((n_files += 1))
            fi
        done
        if [ -z "${archive}" ]; then
            error "Did not find any files in \"${top_dir}/tmp/${progname}\""
            exit 1
        elif [ ${n_files} -gt 1 ]; then
            error "Found multiple files in \"${top_dir}/tmp/${progname}\"."
            error "I am confused about which to extract. Exiting."
            exit 1
        fi
    fi
    # Extract
    if [ -z "${extract_tar_options}" ]; then
        extract_tar_options="-ixvf"
    fi
    extract_success="True"
    case "${archive}" in
        # 7zip
        *.tar.7zip)  7z       -so  x   "${archive}" | tar ${extract_tar_options} -;;
        *.tar.7z)    7z       -so  x   "${archive}" | tar ${extract_tar_options} -;;
        *.t7zip)     7z       -so  x   "${archive}" | tar ${extract_tar_options} -;;
        *.t7z)       7z       -so  x   "${archive}" | tar ${extract_tar_options} -;;
        *.7zip)      7z            x   "${archive}"                               ;;
        *.7z)        7z            x   "${archive}"                               ;;
        # ar
        *.ar)        ar       -xv      "${archive}"                               ;;
        *.a)         ar       -xv      "${archive}"                               ;;
        # bzip2
        *.tar.bzip2) bzip2    -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.tar.bz2)   bzip2    -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.tbzip2)    bzip2    -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.tbz2)      bzip2    -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.bzip2)     bzip2    -d       "${archive}"                               ;;
        *.bz2)       bzip2    -d       "${archive}"                               ;;
        *.tar.bzip)  bzip2    -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.tar.bz)    bzip2    -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.tbzip)     bzip2    -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.tbz)       bzip2    -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.bzip)      bzip2    -d       "${archive}"                               ;;
        *.bz)        bzip2    -d       "${archive}"                               ;;
        # cbz
        *.cbz)       unzip             "${archive}"                               ;;
        # compress
        *.tar.Z)     compress -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.tZ)        compress -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.Z)         compress -d       "${archive}"                               ;;
        # cpio
        *.cpio)      cpio     -idv     "${archive}"                               ;;
        # exe
        *.exe)       "$(readlink -f    "${archive}")"                             ;;
        # gzip
        *.tar.gzip)  gzip     -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.tar.gz)    gzip     -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.tar.z)     gzip     -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.tgzip)     gzip     -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.tgz)       gzip     -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.tz)        gzip     -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.gzip)      gzip     -d       "${archive}"                               ;;
        *.gz)        gzip     -d       "${archive}"                               ;;
        # iso
        *.7z)        7z            x   "${archive}"                               ;;
        # jar
        *.jar)       jar      -xvf     "${archive}"                               ;;
        # lzip
        *.tar.lzip)  lzip     -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.tar.lz)    lzip     -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.tlzip)     lzip     -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.tlz)       lzip     -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.lzip)      lzip     -d       "${archive}"                               ;;
        *.lz)        lzip     -d       "${archive}"                               ;;
        # lzma
        *.tar.lzma)  lzma     -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.tlzma)     lzma     -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.lzma)      lzma     -d       "${archive}"                               ;;
        # lzop
        *.tar.lzop)  lzop     -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.tar.lzo)   lzop     -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.tlzop)     lzop     -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.tlzo)      lzop     -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.lzop)      lzop     -d       "${archive}"                               ;;
        *.lzo)       lzop     -d       "${archive}"                               ;;
        # pack
        *.z)         pack          u   "${archive}" out                           ;;
        # rar
        *.rar)       unrar         x   "${archive}"                               ;;
        # rzip
        *.tar.rzip)  rzip     -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.tar.rz)    rzip     -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.trzip)     rzip     -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.trz)       rzip     -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.rzip)      rzip     -d       "${archive}"                               ;;
        *.rz)        rzip     -d       "${archive}"                               ;;
        # shar
        *.shar)      unshar            "${archive}"                               ;;
        # snappy
        *.sz)        snzip    -d       "${archive}"                               ;;
        # tar
        *.tar)       cat               "${archive}" | tar ${extract_tar_options} -;;
        # xz
        *.tar.xz)    xz       -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.txz)       xz       -d     < "${archive}" | tar ${extract_tar_options} -;;
        *.xz)        xz       -d       "${archive}"                               ;;
        # zip
        *tar.zip)    unzip    -p       "${archive}" | tar ${extract_tar_options} -;;
        *tzip)       unzip    -p       "${archive}" | tar ${extract_tar_options} -;;
        *.zip)       unzip             "${archive}"                               ;;
        # unknown
        *) error "Could not understand the compression format of \"${archive}\""
           exit 1
           ;;
    esac || extract_success="False"
    if [ "$2" != "True" ]; then
        cd "${top_dir}"
    fi
    if [ "${extract_success}" == "False" ]; then
        if [ "${extract_tar_options}" == "-ixvf" ]; then
            # If the extraction failed it may be because the tar
            # implementation in use do not support -i. Try without.
            extract_tar_options="-xvf"
            extract "$1" "$2"
        else
            error "Failed to extract \"${archive}\""
            exit 1
        fi
    fi
}

# Function which initializes installations (extracts the pre-
# downloaded archive and change to the extracted directory).
init_install(){
    # Arguments: Program name, ["Attempting to install" text]
    progname_formatted="$1"
    progname="$(echo "${progname_formatted// /_}" | tr '[:upper:]' '[:lower:]')"
    attempting_to_install_text="$2"
    eval "progversion=\"\${${progname}_version}\""
    if [ "${progname}" != "${progname_last_init_install}" ]; then
        if [ "${progname}" == "fftw_for_gadget" ]; then
            # When installing FFTW for GADGET, the version number should
            # be printed together with FFTW, not GADGET.
            current_step="the installation of FFTW ${progversion} for GADGET"
            heading "Installing FFTW ${progversion} for GADGET"
            set_status "Installing FFTW ${progversion} for GADGET"
        else
            if [ "${progname}" == "mpi" ]; then
                if [ "${mpi}" == "mpich" ]; then
                    progname_formatted="MPICH"
                elif [ "${mpi}" == "openmpi" ]; then
                    progname_formatted="OpenMPI"
                fi
            elif [ "${progname}" == "blas" ]; then
                progname_formatted="OpenBLAS"
            else
                progname_formatted=${progname_formatted/CONCEPT/${esc_concept}}
            fi
            current_step="the installation of ${progname_formatted} ${progversion}"
            heading "Installing ${progname_formatted} ${progversion}"
            set_status "Installing ${progname_formatted} ${progversion}"
        fi
    fi
    # Extract the downloaded archive
    extract "${progname}"
    # Change to the directory which contain the archive
    # and the extracted folder.
    cd "${top_dir}/tmp/${progname}"
    # The current directory should contain only a single directory.
    # Change to this directory.
    for f in *; do
        if [ -d "${f}" ]; then
            cd "${f}"
            break
        fi
    done
    # Print out the "Attempting to install" text
    if [ -n "${attempting_to_install_text}" ]; then
        printf "\nAttempting to install ${progname_formatted} \
with ${attempting_to_install_text}\n\n"
    fi
    # Save a copy of the program name
    progname_last_init_install="${progname}"
}

# Function for detecting when the current process appears to hang.
# When an apparent hang is detected, a soothing message is displayed.
# This should be used when installing Python packages, as pip/setuptools
# sometimes has this bad hanging behaviour, especially for particular
# packages, such as h5py. This function should not be called in a
# situation where you do not believe that the hang is only apparent.
soothe(){
    # Argument: PID of background process on which to wait,
    # [time in seconds after which PID is killed].
    soothe_pid=$1
    kill_time=$2
    if [ -z "${kill_time}" ]; then
        # If any process appears to hang for longer than the time below,
        # we will kill it.
        kill_time=7200  # 2 hours
    fi
    # A long wait is detected by repeatedly
    # checking the size of the log file generated
    # by this installation script.
    soothe_update_time=60
    if [ ${kill_time} -lt ${soothe_update_time} ]; then
        error "soothe() called with kill_time=${kill_time} < \
soothe_update_time=${soothe_update_time}"
        exit 1
    fi
    (
    log_size_last=-1;                                                              \
    log_size=$(du -b "${log}" | awk '{print $1}');                                 \
    time_slept=0;                                                                  \
    while :; do                                                                    \
        sleep ${soothe_update_time};                                               \
        log_size_new=$(du -b "${log}" | awk '{print $1}');                         \
        if [ ${log_size} -eq ${log_size_new} ]; then                               \
            ((time_slept += ${soothe_update_time}));                               \
            if [ ${log_size} -ne ${log_size_last} ]; then                          \
                printf "\n\nThe next step may take an unreasonable amount of time.
Please be patient ...\n";                                                          \
                sleep 5;                                                           \
                log_size_new=$(du -b "${log}" | awk '{print $1}');                 \
                log_size_last=${log_size_new};                                     \
            elif [ ${time_slept} -gt ${kill_time} ]; then \
                echo "Process assumed to be hanging. Killing it";                  \
                kill -9 ${soothe_pid} >/dev/null 2>&1;                             \
                wait    ${soothe_pid} >/dev/null 2>&1;                             \
            fi;                                                                    \
        else                                                                       \
            time_slept=0;                                                          \
        fi;                                                                        \
        log_size=${log_size_new};                                                  \
    done                                                                           \
    ) & soothe_killer_pid=$!
    wait ${soothe_pid} >/dev/null 2>&1 || :
    kill ${soothe_killer_pid} >/dev/null 2>&1 || :  # No forcefull kill (no -9)
    wait ${soothe_killer_pid} >/dev/null 2>&1 || :
}

# Function for writing out installation notices to files in the
# installation directories of the various programs.
install_notice(){
    # Arguments: Program name, program_dir
    progname_formatted="$1"
    progdir="$2"
    progname="${progname_formatted// /_}"
    progname="$(echo "${progname}" | tr '[:upper:]' '[:lower:]')"
    eval "progversion=\"\${${progname}_version}\""
    test_results="None"
    if [ "${do_tests}" == "True" ]; then
        eval "test_success=\"\${${progname}_test_success}\""
        if [ "${test_success}" == "True" ]; then
            test_results="Success"
        elif [ "${test_success}" == "False" ]; then
            test_results="Failure"
        fi
    fi
    echo "The following has been fully installed:
Program:      ${progname_formatted}
Version:      ${progversion}
Test results: ${test_results}
Date:         $(date)
" >> "${progdir}/.installation_finished"
}



# zlib
if [ "${zlib_install}" == "True" ] && [ "${zlib_installed}" == "False" ]; then
    install_success="False"
    for compiler in "${compiler_possibilities[@]}"; do
        reset_environment
        eval "use_${compiler}_compilers" || continue
        init_install "zlib" "compiler=${compiler}"
        ./configure --shared --prefix="${zlib_dir}" 2>&1 || continue
        if [ "${do_tests}" == "True" ]; then
            make ${make_jobs} test 2>&1 | tee "test_log"
            [ ${PIPESTATUS[0]} -eq 0 ] || zlib_test_success="False"
        fi
        if [ "${zlib_test_success}" == "False" ]; then
            mkdir -p "$(dirname "${zlib_test_log}")"
            cp "test_log" "${zlib_test_log}"
        fi
        make ${make_jobs} install 2>&1 || continue
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install zlib"
        exit 1
    fi
    reset_environment
    cp "README" "${zlib_dir}/"
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/zlib" || :
    install_notice "zlib" "${zlib_dir}"
fi

# libpng
if [ "${libpng_install}" == "True" ] && [ "${libpng_installed}" == "False" ]; then
    install_success="False"
    for compiler in "${compiler_possibilities[@]}"; do
        reset_environment
        eval "use_${compiler}_compilers" || continue
        init_install "libpng" "compiler=${compiler}"
        export CPPFLAGS="-I${zlib_dir}/include ${CPPFLAGS}"
        export LD_LIBRARY_PATH="${zlib_dir}/lib:${LD_LIBRARY_PATH}"
        export LDFLAGS="-L${zlib_dir}/lib ${LDFLAGS}"
        export ZLIBLIB="${zlib_dir}/lib"
        export ZLIBINC="${zlib_dir}/include"
        ./configure --prefix="${libpng_dir}" 2>&1 || continue
        if [ "${do_tests}" == "True" ]; then
            make ZLIBLIB="${ZLIBLIB}" ZLIBINC="${ZLIBINC}" ${make_jobs} check 2>&1 | tee "test_log"
            [ ${PIPESTATUS[0]} -eq 0 ] || libpng_test_success="False"
        fi
        if [ "${libpng_test_success}" == "False" ]; then
            mkdir -p "$(dirname "${libpng_test_log}")"
            cp "test_log" "${libpng_test_log}"
        fi
        make ZLIBLIB="${ZLIBLIB}" ZLIBINC="${ZLIBINC}" ${make_jobs} install 2>&1 || continue
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install libpng"
        exit 1
    fi
    reset_environment
    cp "LICENSE" "${libpng_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/libpng" || :
    install_notice "libpng" "${libpng_dir}"
fi

# GSL
if [ "${gsl_install}" == "True" ] && [ "${gsl_installed}" == "False" ]; then
    install_success="False"
    for compiler in "${compiler_possibilities[@]}"; do
        reset_environment
        eval "use_${compiler}_compilers" || continue
        init_install "GSL" "compiler=${compiler}"
        ./configure --prefix="${gsl_dir}" 2>&1 || continue
        make ${make_jobs} 2>&1 || continue
        if [ "${do_tests}" == "True" ]; then
            make ${make_jobs} check 2>&1 | tee "test_log"
            [ ${PIPESTATUS[0]} -eq 0 ] || gsl_test_success="False"
        fi
        if [ "${gsl_test_success}" == "False" ]; then
            mkdir -p "$(dirname "${gsl_test_log}")"
            cp "test_log" "${gsl_test_log}"
        fi
        make ${make_jobs} install 2>&1 || continue
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install GSL"
        exit 1
    fi
    reset_environment
    cp "COPYING" "README" "${gsl_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/gsl" || :
    install_notice "GSL" "${gsl_dir}"
fi

# Perl
if [ "${perl_install}" == "True" ] && [ "${perl_installed}" == "False" ]; then
    # Sometimes make fails to build due to #include of poll.h from a
    # wrong location. A fix for this is implemented below. First we try
    # without the fix, then with the fix.
    # Furthermore, sometimes the installation will complain that the
    # Perl libraries should have been compiled statically.
    # Thus, we try with and witouth the -fPIC C flag.
    install_success="False"
    for compiler in "${compiler_possibilities[@]}"; do
        libimf_dumped="False"
        for dump_libimf in "True" "False"; do
            if [ "${dump_libimf}" == "False" ] && [ "${libimf_dumped}" == "False" ]; then
                # libimf was not found, so dump_libimf == True is
                # equivalent to dump_libimf == False.
                continue
            fi
            for perl_poll_fix in "False" "True"; do
                for perl_cflags in "" "-fPIC"; do
                    reset_environment
                    eval "use_${compiler}_compilers" || continue
                    init_install "Perl" "compiler=${compiler}, dump_libimf=${dump_libimf}, \
perl_poll_fix=${perl_poll_fix}, perl_cflags=${perl_cflags}"
                    # When an Intel C compiler is used, some libraries
                    # like libimf may not be found by the perl
                    # executable. We can fix this by dropping symlinks
                    # to all Intel libraries into the build directory.
                    # For whatever reason, updating LD_LIBRARY_PATH
                    # has no effect.
                    if [ "${dump_libimf}" == "True" ]; then
                        while IFS=':' read -ra library_paths; do
                            for library_path in "${library_paths[@]}"; do
                                is_intel_lib_dir="False"
                                for f in "${library_path}"/*; do
                                    f_base="$(basename "${f}")"
                                    if     [[ "${f_base}" == libimf*.a    ]] \
                                        || [[ "${f_base}" == libimf*.so   ]] \
                                        || [[ "${f_base}" == libimd*.so.* ]]; then
                                        is_intel_lib_dir="True"
                                        break
                                    fi
                                done
                                if [ "${is_intel_lib_dir}" == "False" ]; then
                                    continue
                                fi
                                libimf_dumped="True"
                                for f in "${library_path}"/*; do
                                    f_base="$(basename "${f}")"
                                    if (   [[ "${f_base}" == *.a    ]] \
                                        || [[ "${f_base}" == *.so   ]] \
                                        || [[ "${f_base}" == *.so.* ]] \
                                       ) && [ ! -f "./${f_base}" ]; then
                                        ln -s "${f}" ./ >/dev/null 2>&1 || :
                                    fi
                                done
                            done
                        done <<< "${LD_LIBRARY_PATH}"
                    fi
                    perl_config_options="-de -Dprefix=${perl_dir}"
                    if [ "${compiler}" != "default" ] && [ -n "${CC}" ]; then
                        perl_config_options="${perl_config_options} -Dcc=${CC}"
                    fi
                    if [ -n "${perl_cflags}" ]; then
                        perl_config_options="${perl_config_options} -Accflags=${perl_cflags}"
                    fi
                    ./Configure ${perl_config_options} 2>&1 || : continue
                    if [ "${perl_poll_fix}" == "True" ]; then
                        sed -i 's/<poll\.h>/<sys\/poll\.h>/' 'dist/IO/poll.h' || continue
                    fi
                    make ${make_jobs} 2>&1 || continue
                    if [ "${do_tests}" == "True" ]; then
                        # On some systems, the Perl test hangs indefinitely.
                        # To counteract this, kill the process if it still
                        # runs after ${perl_test_max_time} seconds.
                        perl_test_max_time=3600
                        exit_code_filename="${top_dir}/tmp/.exit_code_perl"
                        (make ${make_jobs} test 2>&1 | tee "test_log"; \
                         echo "${PIPESTATUS[0]}" > "${exit_code_filename}") & perl_test_pid=$!
                        soothe ${perl_test_pid} ${perl_test_max_time}
                        sleep 1
                        kill -9 ${perl_test_pid} >/dev/null 2>&1 || :
                        wait    ${perl_test_pid} >/dev/null 2>&1 || :
                        exit_code="$(wait ${perl_test_pid} >/dev/null 2>&1 || echo $?)"
                        if [ -n "${exit_code}" ]; then
                            perl_test_success="False"
                        else
                            exit_code="$(cat "${exit_code_filename}" 2>/dev/null || :)"
                            if [ "${exit_code}" != "0" ]; then
                                perl_test_success="False"
                            fi
                        fi
                        # The text "Failed" will be present in the test log
                        # file if any of the tests failed.
                        if grep 'Failed' "test_log" >/dev/null 2>&1; then
                            perl_test_success="False"
                        fi
                        rm -f "${exit_code_filename}" || :
                    fi
                    if [ "${perl_test_success}" == "False" ]; then
                        mkdir -p "$(dirname "${perl_test_log}")"
                        cp "test_log" "${perl_test_log}"
                    fi
                    make ${make_jobs} install 2>&1 || continue
                    install_success="True"
                    break
                done
                if [ "${install_success}" == "True" ]; then
                    break
                fi
            done
            if [ "${install_success}" == "True" ]; then
                break
            fi
        done
        if [ "${install_success}" == "True" ]; then
            break
        fi
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install Perl"
        exit 1
    fi
    reset_environment
    cp "AUTHORS" "Copying" "README" "${perl_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/perl" || :
    install_notice "Perl" "${perl_dir}"
fi

# MPI
if [ "${mpi_install}" == "True" ] && [ "${mpi_installed}" == "False" ]; then
    install_success="False"
    compiler_possibilities_mpi=()
    compiler_possibilities_specified_mpi=""
    for compiler in "${compiler_possibilities[@]}"; do
        if [ "${compiler}" == "specified_mpi" ]; then
            compiler_possibilities_specified_mpi="${compiler}"
        else
            compiler_possibilities_mpi=("${compiler_possibilities_mpi[@]}" "${compiler}")
        fi
    done
    if [ -n "${compiler_possibilities_specified_mpi}" ]; then
        compiler_possibilities_mpi=("${compiler_possibilities_mpi[@]}" \
            "${compiler_possibilities_specified_mpi}")
    fi
    if [ "${mpi}" == "mpich" ]; then
        # MPICH
        for compiler in "${compiler_possibilities_mpi[@]}"; do
            reset_environment
            eval "use_${compiler}_compilers" || continue
            init_install "MPI" "compiler=${compiler}"
            export PATH="${perl_dir}/bin:${PATH}"
            ./configure --enable-shared --prefix="${mpi_dir}" 2>&1 || continue
            if [ "${make_jobs}" == "-j" ]; then
                # Building in parallel takes up a lot of resources
                make -j 2 2>&1 || continue
            else
                make 2>&1 || continue
            fi
            if [ "${do_tests}" == "True" ]; then
                make check 2>&1 | tee "test_log"
                [ ${PIPESTATUS[0]} -eq 0 ] || mpi_test_success="False"
            fi
            if [ "${mpi_test_success}" == "False" ]; then
                mkdir -p "$(dirname "${mpi_test_log}")"
                cp "test_log" "${mpi_test_log}"
            fi
            if [ "${make_jobs}" == "-j" ]; then
                # Building in parallel takes up a lot of resources
                make -j 2 install 2>&1 || continue
            else
                make install 2>&1 || continue
            fi
            install_success="True"
            break
        done
    elif [ "${mpi}" == "openmpi" ]; then
        # OpenMPI
        for compiler in "${compiler_possibilities_mpi[@]}"; do
            reset_environment
            eval "use_${compiler}_compilers" || continue
            init_install "MPI" "compiler=${compiler}"
            export PATH="${perl_dir}/bin:${PATH}"
            ./configure --prefix="${mpi_dir}" 2>&1 || continue
            if [ "${make_jobs}" == "-j" ]; then
                # Building in parallel takes up a lot of resources
                make -j 2 2>&1 || continue
            else
                make 2>&1 || continue
            fi
            if [ "${do_tests}" == "True" ]; then
                make check 2>&1 | tee "test_log"
                [ ${PIPESTATUS[0]} -eq 0 ] || mpi_test_success="False"
            fi
            if [ "${mpi_test_success}" == "False" ]; then
                mkdir -p "$(dirname "${mpi_test_log}")"
                cp "test_log" "${mpi_test_log}"
            fi
            if [ "${make_jobs}" == "-j" ]; then
                # Building in parallel takes up a lot of resources
                make -j 2 install 2>&1 || continue
            else
                make 2>&1 install || continue
            fi
            install_success="True"
            break
        done
    fi
    if [ "${install_success}" == "False" ]; then
        if [ "${mpi}" == "mpich" ]; then
            error "Failed to install MPICH"
        elif [ "${mpi}" == "openmpi" ]; then
            error "Failed to install OpenMPI"
        fi
        exit 1
    fi
    reset_environment
    if [ "${mpi}" == "mpich" ]; then
        cp "COPYRIGHT" "${mpi_dir}/" || :
    elif [ "${mpi}" == "openmpi" ]; then
        cp "AUTHORS" "LICENSE" "${mpi_dir}/" || :
    fi
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/mpi" || :
    install_notice "MPI" "${mpi_dir}"
fi

# HDF5
if [ "${hdf5_install}" == "True" ] && [ "${hdf5_installed}" == "False" ]; then
    install_success="False"
    hdf5_test_success_backup="${hdf5_test_success}"
    # Attempt to configure using multiple MPI link flags
    for extra_LIBS in "" "-lmpi" "-lmpich"; do
        reset_environment
        init_install "HDF5" "extra_LIBS=${extra_LIBS}"
        # Set environment variables and configure options used
        # when building againts MPI and zlib.
        enable_parallel=""
        if [ -n "${mpi_dir}" ]; then
            use_specified_mpi_compilers
            enable_parallel="--enable-parallel"
        elif [ -n "${extra_LIBS}" ]; then
            break
        fi
        with_zlib=""
        if [ -n "${zlib_dir}" ]; then
            export LDFLAGS="-L${zlib_dir}/lib ${LDFLAGS}"
            export LD_LIBRARY_PATH="${zlib_dir}/lib:${LD_LIBRARY_PATH}"
            export CFLAGS="-I${zlib_dir}/include ${CFLAGS}"
            with_zlib=--with-zlib="${zlib_dir}/include","${zlib_dir}/lib"
        fi
        # A bug in HDF5 makes the code crash on certain file systems.
        # A workaround is to set an environment variable as below.
        # The bug is documented here:
        # http://www.nersc.gov/users/data-analytics
        # /data-management/i-o-libraries/hdf5-2/hdf5/
        export HDF5_USE_FILE_LOCKING=FALSE
        if [ -n "${enable_parallel}" ]; then
            export LIBS="${extra_LIBS} ${LIBS}"
        fi
        ./configure                \
            --enable-shared        \
            ${enable_parallel}     \
            ${with_zlib}           \
            --prefix="${hdf5_dir}" \
            2>&1 || continue
        # Newer versions of gcc (e.g. 8.1.0) do not allow attributes to
        # be specified after the declarator in function definitions.
        # At least in some versions of HDF5 (e.g. 1.10.2), this rule is
        # broken by src/H5detect.c. If the original build fail, we edit
        # src/H5detect.c to be compliant with this rule and try again.
        hdf5_make_success="True"
        make 2>&1 || hdf5_make_success="False"  # Building in parallel takes up a lot of resources
        if [ "${hdf5_make_success}" == "False" ]; then
            mv "src/H5detect.c" "src/H5detect.c_cp"
            if [ -z "${IFS+x}" ]; then
                IFS_ori="__unset__"
            else
                IFS_ori="${IFS}"
            fi
            IFS=''
            while read -r line; do
                if [ "${line}" == "static void" ] || [ "${line}" == "int" ] ; then
                    printf "${line} " >> "src/H5detect.c"
                else
                    echo "${line}" >> "src/H5detect.c"
                fi
            done <<< "$(cat "src/H5detect.c_cp")"
            if [ "${IFS_ori}" == "__unset__" ]; then
                unset IFS
            else
                IFS="${IFS_ori}"
            fi
            rm -f "src/H5detect.c_cp" || :
            sed -i 's/^static void \(.*\) HDF_NO_UBSAN/static void HDF_NO_UBSAN \1/' \
                "src/H5detect.c"
            sed -i 's/^int \(.*\) HDF_NO_UBSAN/int HDF_NO_UBSAN \1/' "src/H5detect.c"
            hdf5_make_success="True"
            make 2>&1 || continue  # Building in parallel takes up a lot of resources
        fi
        # On some systems, the HDF5 test (make check) hangs
        # indefinitely. To counteract this, kill the process if it still
        # runs after ${hdf5_test_max_time} seconds.
        if [ "${do_tests}" == "True" ]; then
            hdf5_test_success="${hdf5_test_success_backup}"
            hdf5_test_max_time=3600
            exit_code_filename="${top_dir}/tmp/.exit_code_hdf5"
            # Perform serial + parallel tests if build against MPI
            # or normal tests otherwise.
            if [ -n "${mpi_dir}" ]; then
                # Serial tests
                (make ${make_jobs} check-s 2>&1 | tee "test_log"; \
                 echo "${PIPESTATUS[0]}" > "${exit_code_filename}") & hdf5_test_pid=$!
                soothe ${hdf5_test_pid} ${hdf5_test_max_time}
                sleep 1
                kill -9 ${hdf5_test_pid} >/dev/null 2>&1 || :
                wait    ${hdf5_test_pid} >/dev/null 2>&1 || :
                exit_code="$(wait ${hdf5_test_pid} >/dev/null 2>&1 || echo $?)"
                if [ -n "${exit_code}" ]; then
                    hdf5_test_success="False"
                else
                    exit_code="$(cat "${exit_code_filename}" 2>/dev/null || :)"
                    if [ "${exit_code}" != "0" ]; then
                        hdf5_test_success="False"
                    fi
                fi
                # Parallel tests
                printf "\n\n\nParallel tests below\n\n\n\n" >> "test_log"
                (make ${make_jobs} check-p 2>&1 | tee "test_log"; \
                 echo "${PIPESTATUS[0]}" > "${exit_code_filename}") & hdf5_test_pid=$!
                soothe ${hdf5_test_pid} ${hdf5_test_max_time}
                sleep 1
                kill -9 ${hdf5_test_pid} >/dev/null 2>&1 || :
                wait    ${hdf5_test_pid} >/dev/null 2>&1 || :
                exit_code="$(wait ${hdf5_test_pid} >/dev/null 2>&1 || echo $?)"
                if [ -n "${exit_code}" ]; then
                    hdf5_test_success="False"
                else
                    exit_code="$(cat "${exit_code_filename}" 2>/dev/null || :)"
                    if [ "${exit_code}" != "0" ]; then
                        hdf5_test_success="False"
                    fi
                fi
            else
                (make ${make_jobs} check 2>&1 | tee "test_log"; \
                 echo "${PIPESTATUS[0]}" > "${exit_code_filename}") & hdf5_test_pid=$!
                soothe ${hdf5_test_pid} ${hdf5_test_max_time}
                sleep 1
                kill -9 ${hdf5_test_pid} >/dev/null 2>&1 || :
                wait    ${hdf5_test_pid} >/dev/null 2>&1 || :
                exit_code="$(wait ${hdf5_test_pid} >/dev/null 2>&1 || echo $?)"
                if [ -n "${exit_code}" ]; then
                    hdf5_test_success="False"
                else
                    exit_code="$(cat "${exit_code_filename}" 2>/dev/null || :)"
                    if [ "${exit_code}" != "0" ]; then
                        hdf5_test_success="False"
                    fi
                fi
            fi
            rm -f "${exit_code_filename}" || :
        fi
        make install 2>&1 || continue  # Building in parallel takes up a lot of resources
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install HDF5"
        exit 1
    fi
    if [ "${do_tests}" == "True" ]; then
        printf "\n\n\nInstall tests below\n\n\n\n" >> "test_log"
        make ${make_jobs} check-install 2>&1 | tee -a "test_log"
        # The text "*FAILED*" will be present in the test log file
        # if any of the tests failed.
        [ ${PIPESTATUS[0]} -eq 0 ] || hdf5_test_success="False"
        if grep '\*FAILED\*' "test_log" >/dev/null 2>&1; then
            hdf5_test_success="False"
        fi
    fi
    if [ "${hdf5_test_success}" == "False" ]; then
        mkdir -p "$(dirname "${hdf5_test_log}")"
        cp "test_log" "${hdf5_test_log}"
    fi
    reset_environment
    cp "COPYING" "README.txt" "${hdf5_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/hdf5" || :
    install_notice "HDF5" "${hdf5_dir}"
fi

# FFTW
if [ "${fftw_install}" == "True" ] && [ "${fftw_installed}" == "False" ]; then
    install_success="False"
    fftw_test_success_backup="${fftw_test_success}"
    enable_mpi=""
    if [ -n "${mpi_dir}" ]; then
        enable_mpi="--enable-mpi"
    fi
    for extra_optimizations in "True" "False"; do
        for enable_shared in "--enable-shared" ""; do
            for shared in "" "-shared"; do
                if [ -z "${enable_shared}" ] && [ -n "${shared}" ]; then
                    continue
                fi
                for with_pic in "" "--with-pic"; do
                    for PIC in "-fPIC" ""; do
                        for extra_MPILIBS in "" "-lmpi" "-lmpich"; do
                            if [ -z "${enable_mpi}" ] && [ -n "${extra_MPILIBS}" ]; then
                                continue
                            fi
                            reset_environment
                            init_install "FFTW" "extra_optimizations=${extra_optimizations}, \
enable_shared=${enable_shared}, shared=${shared}, with_pic=${with_pic}, \
PIC=${PIC}, extra_MPILIBS=${extra_MPILIBS}"
                            if [ -n "${enable_mpi}" ]; then
                                use_specified_mpi_compilers
                                export MPICC="${CC}"
                                export MPILIBS="${extra_MPILIBS} ${MPILIBS}"
                            fi
                            export CFLAGS="-O3 ${PIC} ${CFLAGS}"
                            export CXXFLAGS="-O3 ${PIC} ${CXXFLAGS}"
                            export LDFLAGS="${LDFLAGS} -Wl,-O3 ${shared} ${PIC}"
                            if [ "${extra_optimizations}" == "True" ]; then
                                export CFLAGS="${CFLAGS} -march=native"
                                info="$("${CC}" --version | head -n 1 || :)"
                                if echo "${info}" | grep -i icc >/dev/null; then
                                    # icc
                                    export CFLAGS="${CFLAGS} \
-fp-model fast=2 -inline-factor=200"
                                else
                                    # Assume gcc
                                    export CFLAGS="${CFLAGS} \
-ffast-math --param max-inline-insns-auto=100 --param early-inlining-insns=200"
                                fi
                            fi
                            # Double-precision
                            ./configure ${enable_shared}  \
                                        ${enable_mpi}     \
                                        --disable-fortran \
                                        ${with_pic}       \
                                        --prefix="${fftw_dir}" 2>&1 || continue
                            make 2>&1 || continue
                            fftw_test_max_time=600
                            if [ "${extra_optimizations}" == "True" ]; then
                                exit_code_filename="${top_dir}/tmp/.exit_code_fftw"
                                (make check 2>&1 | tee "test_log";                    \
                                    echo "${PIPESTATUS[0]}" > "${exit_code_filename}" \
                                ) & fftw_test_pid=$!
                                soothe ${fftw_test_pid} ${fftw_test_max_time}
                                sleep 1
                                kill -9 ${fftw_test_pid} >/dev/null 2>&1 || :
                                wait    ${fftw_test_pid} >/dev/null 2>&1 || :
                                exit_code="$(wait ${fftw_test_pid} >/dev/null 2>&1 || echo $?)"
                                if [ -n "${exit_code}" ]; then
                                    rm -f "${exit_code_filename}" "test_log" || :
                                    continue
                                else
                                    exit_code="$(cat "${exit_code_filename}" 2>/dev/null || :)"
                                    if [ "${exit_code}" != "0" ]; then
                                        rm -f "${exit_code_filename}" "test_log" || :
                                        continue
                                    fi
                                fi
                            fi
                            if [ "${do_tests}" == "True" ]; then
                                fftw_test_success="${fftw_test_success_backup}"
                                exit_code_filename="${top_dir}/tmp/.exit_code_fftw"
                                (make check 2>&1 | tee "test_log";                    \
                                    echo "${PIPESTATUS[0]}" > "${exit_code_filename}" \
                                ) & fftw_test_pid=$!
                                soothe ${fftw_test_pid} ${fftw_test_max_time}
                                sleep 1
                                kill -9 ${fftw_test_pid} >/dev/null 2>&1 || :
                                wait    ${fftw_test_pid} >/dev/null 2>&1 || :
                                exit_code="$(wait ${fftw_test_pid} >/dev/null 2>&1 || echo $?)"
                                if [ -n "${exit_code}" ]; then
                                    fftw_test_success="False"
                                else
                                    exit_code="$(cat "${exit_code_filename}" 2>/dev/null || :)"
                                    if [ "${exit_code}" != "0" ]; then
                                        fftw_test_success="False"
                                    fi
                                fi
                                rm -f "${exit_code_filename}" || :
                            fi
                            make install 2>&1 || continue
                            # Single-precision
                            make clean || :
                            ./configure ${enable_shared}  \
                                        ${enable_mpi}     \
                                        --enable-float    \
                                        --disable-fortran \
                                        ${with_pic}       \
                                        --prefix="${fftw_dir}" 2>&1 || continue
                            make         2>&1 || continue
                            make install 2>&1 || continue
                            install_success="True"
                            break
                        done
                        if [ "${install_success}" == "True" ]; then
                            break
                        fi
                    done
                    if [ "${install_success}" == "True" ]; then
                        break
                    fi
                done
                if [ "${install_success}" == "True" ]; then
                    break
                fi
            done
            if [ "${install_success}" == "True" ]; then
                break
            fi
        done
        if [ "${install_success}" == "True" ]; then
            break
        fi
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install FFTW"
        exit 1
    fi
    if [ "${fftw_test_success}" == "False" ]; then
        mkdir -p "$(dirname "${ftw_test_log}")"
        cp "test_log" "${fftw_test_log}"
    fi
    reset_environment
    cp "COPYING" "README" "${fftw_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/fftw" || :
    install_notice "FFTW" "${fftw_dir}"
fi

# FreeType
if [ "${freetype_install}" == "True" ] && [ "${freetype_installed}" == "False" ]; then
    install_success="False"
    for compiler in "${compiler_possibilities[@]}"; do
        reset_environment
        eval "use_${compiler}_compilers" || continue
        init_install "FreeType" "compiler=${compiler}"
        ./configure --prefix="${freetype_dir}" \
                    --with-zlib=no             \
                    --with-bzip2=no            \
                    --with-png=no              \
                    --with-harfbuzz=no 2>&1 || continue
        make ${make_jobs} 2>&1 || continue
        # FreeType does not come with a test suite
        make ${make_jobs} install 2>&1 || continue
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install FreeType"
        exit 1
    fi
    reset_environment
    (cd docs; cp "FTL.TXT" "GPLv2.TXT" "LICENSE.TXT" "${freetype_dir}/" || :)
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/freetype" || :
    install_notice "FreeType" "${freetype_dir}"
fi

# ncurses
if [ "${ncurses_install}" == "True" ] && [ "${ncurses_installed}" == "False" ]; then
    install_success="False"
    for compiler in "${compiler_possibilities[@]}"; do
        reset_environment
        eval "use_${compiler}_compilers" || continue
        init_install "ncurses" "compiler=${compiler}"
        # Due to a bug in (at least) ncurses 6.0, this is needed on
        # some systems. See https://trac.sagemath.org/ticket/19762
        export CPPFLAGS="-P ${CPPFLAGS}"
        ./configure --with-shared --prefix="${ncurses_dir}" 2>&1 || continue
        make ${make_jobs} 2>&1 || continue
        make ${make_jobs} install 2>&1 || continue
        if [ "${do_tests}" == "True" ]; then
            disable_status
            (sleep ${sleep_time}; echo "q") | "test/worm" -n 7 > "/dev/tty" 2>&1 \
                || ncurses_test_success="False"
            enable_status
        fi
        # Additional test run needed (if the first failed), as the one
        # above do not use tee (as it ruins the display).
        if [ "${do_tests}" == "True" ] && [ "${ncurses_test_success}" == "False" ]; then
            disable_status
            (sleep ${sleep_time}; echo "q") | "test/worm" -n 7 > "test_log" 2>&1 || :
            enable_status
        fi
        if [ "${ncurses_test_success}" == "False" ]; then
            mkdir -p "$(dirname "${ncurses_test_log}")"
            cp "test_log" "${ncurses_test_log}"
        fi
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install ncurses"
        exit 1
    fi
    reset_environment
    cp "AUTHORS" "COPYING" "${ncurses_dir}/include/ncurses/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/ncurses" || :
    install_notice "ncurses" "${ncurses_dir}"
fi

# OpenSSL
if [ "${openssl_install}" == "True" ] && [ "${openssl_installed}" == "False" ]; then
    install_success="False"
    for compiler in "${compiler_possibilities[@]}"; do
        reset_environment
        eval "use_${compiler}_compilers" || continue
        init_install "OpenSSL" "compiler=${compiler}"
        export PATH="${perl_dir}/bin:${PATH}"
        export PERL="${perl_dir}/bin/perl"
        ./config shared --prefix="${openssl_dir}" \
            --openssldir="${openssl_dir}/openssl" 2>&1 || continue
        make 2>&1 || continue  # Should not be run in parallel!
        if [ "${do_tests}" == "True" ]; then
            make test 2>&1 | tee "test_log"  # Should not be run in parallel!
            [ ${PIPESTATUS[0]} -eq 0 ] || openssl_test_success="False"
        fi
        if [ "${openssl_test_success}" == "False" ]; then
            mkdir -p "$(dirname "${openssl_test_log}")"
            cp "test_log" "${openssl_test_log}"
        fi
        make install 2>&1 || continue  # Should not be run in parallel!
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install OpenSSL"
        exit 1
    fi
    reset_environment
    cp "LICENSE" "README" "${openssl_dir}/include/openssl/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/openssl" || :
    install_notice "OpenSSL" "${openssl_dir}"
fi

# libffi
if [ "${libffi_install}" == "True" ] && [ "${libffi_installed}" == "False" ]; then
    install_success="False"
    for compiler in "${compiler_possibilities[@]}"; do
        reset_environment
        eval "use_${compiler}_compilers" || continue
        init_install "libffi" "compiler=${compiler}"
        ./configure --prefix="${libffi_dir}" 2>&1 || continue
        make ${make_jobs} 2>&1 || continue
        if [ "${do_tests}" == "True" ]; then
            make check 2>&1 | tee "test_log"
            [ ${PIPESTATUS[0]} -eq 0 ] || libffi_test_success="False"
        fi
        if [ "${libffi_test_success}" == "False" ]; then
            mkdir -p "$(dirname "${libffi_test_log}")"
            cp "test_log" "${libffi_test_log}"
        fi
        make ${make_jobs} install 2>&1 || continue
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install libffi"
        exit 1
    fi
    reset_environment
    cp "LICENSE" "README" "${libffi_dir}/lib/libffi-${libffi_version}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/libffi" || :
    install_notice "libffi" "${libffi_dir}"
fi

# OpenBLAS
if [ "${blas_install}" == "True" ] && [ "${blas_installed}" == "False" ]; then
    # Due to the threading behaviour of Python,
    # we install a non-threaded version of OpenBLAS.
    # We wish to use the gfortran Fortran compiler. We try out all the
    # compiler environments but overwriting the Fortran compiler.
    # If this fails, we retry without overwriting the Fortran compiler.
    # On 32 bit systems we need to set BINARY=32. First we try without,
    # then with this option.
    # On Haswell architectures the -mavx2 C and Fortran compiler flag
    # is added, though not all compilers accept these. We first try
    # with both, then we switch them out for -mavx, then only with the C
    # flag -mavx2, then only with the C flag -mavx. If all fail we
    # disable AVX2 entirely. If this fails as well we additionally
    # disable AVX.
    # Note that OpenBLAS runs its test suite during this build.
    install_success="False"
    mavx_C_options=("-mavx2" "-mavx" "-mavx2" "-mavx" "NO_AVX2" "NO_AVX")
    mavx_F_options=("-mavx2" "-mavx" ""       ""      "NO_AVX2" "NO_AVX")
    for ((mavx_index=0; mavx_index<${#mavx_C_options[@]}; mavx_index++)); do
        mavx_C="${mavx_C_options[${mavx_index}]}"
        mavx_F="${mavx_F_options[${mavx_index}]}"
        for openblas_gfortran in "True" "False"; do
            for compiler in "${compiler_possibilities[@]}"; do
                for openblas_BINARY in "" "32"; do
                    reset_environment
                    eval "use_${compiler}_compilers" || continue
                    init_install "BLAS" "mavx_C=${mavx_C}, mavx_F=${mavx_F}, \
openblas_gfortran=${openblas_gfortran}, compiler=${compiler}, \
openblas_BINARY=${openblas_BINARY}"
                    openblas_make_options="USE_THREAD=0"
                    if [ "${mavx_C}" == "NO_AVX2" ]; then
                        # Disable AVX2 completely
                        openblas_make_options="${openblas_make_options} NO_AVX2=1"
                    elif [ "${mavx_C}" == "NO_AVX" ]; then
                        # Disable AVX2 and AVX completely
                        openblas_make_options="${openblas_make_options} NO_AVX2=1 NO_AVX=1"
                    else
                        # Handle the C mavx flag
                        pattern='CCOMMON_OPT *\\+= *-mavx2'
                        linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
                            "Makefile.x86_64" | head -n 1)
                        if [ "${mavx_C}" != "-mavx2" ] && [ -z "${linenr}" ]; then
                            continue
                        fi
                        if [ -z "${mavx_C}" ]; then
                            sed -i "${linenr}d" "Makefile.x86_64"
                        elif [ "${mavx_C}" == "-mavx" ]; then
                            sed -i "${linenr}s/.*/CCOMMON_OPT += -mavx/" "Makefile.x86_64"
                        fi
                        # Handle the F mavx flag
                        pattern='FCOMMON_OPT *\\+= *-mavx2'
                        linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
                            "Makefile.x86_64" | head -n 1)
                        if [ "${mavx_F}" != "-mavx2" ] && [ -z "${linenr}" ]; then
                            continue
                        fi
                        if [ -z "${mavx_F}" ]; then
                            sed -i "${linenr}d" "Makefile.x86_64"
                        elif [ "${mavx_F}" == "-mavx" ]; then
                            sed -i "${linenr}s/.*/FCOMMON_OPT += -mavx/" "Makefile.x86_64"
                        fi
                    fi
                    if [ "${openblas_gfortran}" == "True" ]; then
                        export FC="gfortran"
                        export F77="gfortran"
                        export F90="gfortran"
                        export F9X="gfortran"
                    fi
                    if ([ "${compiler}" != "default" ] && [ -n "${FC}" ]) \
                        || [ "${openblas_gfortran}" == "True" ]; then
                        openblas_make_options="${openblas_make_options} FC=${FC}"
                    fi
                    if [ "${compiler}" != "default" ] && [ -n "${CC}" ]; then
                        openblas_make_options="${openblas_make_options} CC=${CC}"
                    fi
                    if [ -n "${openblas_BINARY}" ]; then
                        openblas_make_options="${openblas_make_options} BINARY=${openblas_BINARY}"
                    fi
                    export PATH="${perl_dir}/bin:${PATH}"
                    make ${openblas_make_options} || continue
                    make PREFIX="${blas_dir}" install || continue
                    install_success="True"
                    break
                done
                if [ "${install_success}" == "True" ]; then
                    break
                fi
            done
            if [ "${install_success}" == "True" ]; then
                break
            fi
        done
        if [ "${install_success}" == "True" ]; then
            break
        fi
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install OpenBLAS"
        exit 1
    fi
    reset_environment
    cp "LICENSE" "${blas_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/blas" || :
    install_notice "BLAS" "${blas_dir}"
fi

# Python
if [ "${python_install}" == "True" ]; then
    # If the path to an already installed Python distribution is set in
    # the PYTHONPATH variable, it may conflict with the installation
    # provided by this script. Specifically, issues have been noted when
    # updating pip. Here we make sure to unset PYTHONPATH, and we do not
    # set it again, not even through the reset_environment function.
    unset PYTHONPATH
    # Similarly unset PYTHONHOME
    unset PYTHONHOME
    # As we are installing Python from scratch, we remove the user site
    # directory (~/.local/lib/python3.x/site-packages) from the searched
    # paths when importing modules in Python. In this way, other Python
    # distributions on the system cannot interfere with this one.
    export PYTHONNOUSERSITE="True"
fi
if [ "${python_install}" == "True" ] && [ "${python_installed}" == "False" ]; then
    install_success="False"
    # Build with pip if both openssl and zlib are installed.
    # For Python >=3.7, a standalone libffi is also required,
    # though we do not check explicitly for this.
    with_ensurepip_install=""
    if [ -n "${openssl_dir}" ] && [ -n "${zlib_dir}" ]; then
        with_ensurepip_install="--with-ensurepip=install"
    fi
    for compiler in "${compiler_possibilities[@]}"; do
        # The -O3 (set by default by Python) and -O2 (default in icc)
        # may produce a buggy build which segfaults when run, under the
        # Intel compilers. If the installation fails while using the
        # Intel compilers, we try with a low optimization level of -O1.
        for inteloptimizations in "" "-O1"; do
            # The configure script will check whether atomic operations
            # may be used. Some compilers (e.g. Intel 2019) only
            # implement a subset of the needed atomic operations, and so
            # may falsely pass this check. On failure, we try again
            # while claiming that we do not support atomic operations
            # at all.
            for disable_atomic_operations in "False" "True"; do
                # Try building with optimizations (both profile guided
                # compile time optimization (pgo) and link time
                # optimization (lto)). If it fails for whatever reason,
                # fall back to a non-optimized build.
                for pyoptimizations in "pgo lto" "pgo" "lto" ""; do
                    reset_environment
                    eval "use_${compiler}_compilers" || continue
                    # If inteloptimizations are specified, append them
                    # to CFLAGS if we are using the Intel C compiler.
                    # If we are not, skip this installation attempt.
                    if [ -n "${inteloptimizations}" ]; then
                        info="$("${CC}" --version 2>/dev/null | head -n 1 || :)"
                        if echo "${info}" | grep -i icc >/dev/null; then
                            export CFLAGS="${CFLAGS} ${inteloptimizations}"
                        else
                            continue
                        fi
                    fi
                    init_install "Python" "compiler=${compiler}, \
inteloptimizations=${inteloptimizations}, disable_atomic_operations=${disable_atomic_operations}, \
pyoptimizations=${pyoptimizations}"
                    # Set up environment variables and configure options
                    if [ "${disable_atomic_operations}" == "True" ]; then
                        sed -i '/have_stdatomic_h *= *yes/c\have_stdatomic_h=no' configure
                    fi
                    with_pgo=""
                    if [[ "${pyoptimizations}" == *"pgo"* ]]; then
                        with_pgo="--enable-optimizations"
                    fi
                    with_lto=""
                    if [[ "${pyoptimizations}" == *"lto"* ]]; then
                        with_lto="--with-lto"
                    fi
                    if [ -n "${ncurses_dir}" ]; then
                        export CPPFLAGS="-I${ncurses_dir}/include \
-I${ncurses_dir}/include/ncurses ${CPPFLAGS}"
                        export LD_LIBRARY_PATH="${ncurses_dir}/lib:${LD_LIBRARY_PATH}"
                        export LDFLAGS="-L${ncurses_dir}/lib -Wl,-rpath=${ncurses_dir}/lib ${LDFLAGS}"
                    fi
                    with_openssl=""
                    if [ -n "${openssl_dir}" ]; then
                        export CPPFLAGS="-I${openssl_dir}/include/openssl ${CPPFLAGS}"
                        export LD_LIBRARY_PATH="${openssl_dir}/lib:${LD_LIBRARY_PATH}"
                        export LDFLAGS="-L${openssl_dir}/lib -Wl,-rpath=${openssl_dir}/lib ${LDFLAGS}"
                        with_openssl="--with-openssl=${openssl_dir}"
                        # Modify Modules/Setup (Modules/Setup.dist in older
                        # Python versions) in order for Python to use the
                        # custom SSL library.
                        modules_setup_filename=""
                        for setup_filename in "Setup" "Setup.dist"; do
                            if [ -f "Modules/${setup_filename}" ]; then
                                modules_setup_filename="Modules/${setup_filename}"
                                break
                            fi
                        done
                        if [ -n "${modules_setup_filename}" ]; then
                            first_line="$(grep -n "SSL=" "${modules_setup_filename}")"
                            first_line=${first_line%:*}
                            ((last_line = first_line + 3))
                            sed -i "${first_line},${last_line}s/.//" "${modules_setup_filename}"
                            sed -i "${first_line}s/.*/SSL=${openssl_dir//\//\\/}/" \
                                "${modules_setup_filename}"
                        fi
                    fi
                    if [ -n "${zlib_dir}" ]; then
                        export CPPFLAGS="-I${zlib_dir}/include ${CPPFLAGS}"
                        export LD_LIBRARY_PATH="${zlib_dir}/lib:${LD_LIBRARY_PATH}"
                        export LDFLAGS="-L${zlib_dir}/lib -Wl,-rpath=${zlib_dir}/lib ${LDFLAGS}"
                    fi
                    with_system_ffi=""
                    if [ -n "${libffi_dir}" ]; then
                        current_dir="$(pwd)"
                        for lib_dir in "lib" "lib64"; do
                            if [ ! -d "${libffi_dir}/${lib_dir}" ]; then
                                continue
                            fi
                            cd "${libffi_dir}/${lib_dir}"
                            for f in *; do
                                if     [ -d "${f}" ] \
                                    && [[ "${f}" == "libffi"* ]] \
                                    && [ -d "${libffi_dir}/${lib_dir}/${f}/include" ]; then
                                    export CPPFLAGS="-I${libffi_dir}/${lib_dir}/${f}/include \
${CPPFLAGS}"
                                    break
                                fi
                            done
                            export LD_LIBRARY_PATH="${libffi_dir}/${lib_dir}:${LD_LIBRARY_PATH}"
                            export LDFLAGS="-L${libffi_dir}/${lib_dir} \
-Wl,-rpath=${libffi_dir}/${lib_dir} ${LDFLAGS}"
                        done
                        cd "${current_dir}"
                        with_system_ffi="--with-system-ffi"
                    fi
                    export LDFLAGS="-L${python_dir}/lib -Wl,--rpath=${python_dir}/lib ${LDFLAGS}"
                    # Configure.
                    # When pgo optimizations are enabled, some of the
                    # tests which are performed may hang. It appears
                    # that the configure script allows each test to take
                    # up to an hour before they are forcefully killed.
                    # We thus do not need to kill any such hanging
                    # process manually. We do however write out a
                    # soothing message in the case of such hangs,
                    # letting the user know that everything
                    # will be all right.
                    pyconfigure_success="True"
                    ./configure --enable-shared ${with_pgo} ${with_lto} --prefix="${python_dir}" \
                        ${with_ensurepip_install}                                                \
                        ${with_openssl}                                                          \
                        ${with_system_ffi}                                                       \
                        2>&1 || pyconfigure_success="False" & python_configure_pid=$!
                    soothe ${python_configure_pid}
                    if [ "${pyconfigure_success}" == "False" ]; then
                        continue
                    fi
                    # Make
                    make ${make_jobs} 2>&1 || continue
                    # Test
                    if [ "${do_tests}" == "True" ]; then
                        make ${make_jobs} test 2>&1 | tee "test_log"
                        [ ${PIPESTATUS[0]} -eq 0 ] || python_test_success="False"
                    fi
                    if [ "${python_test_success}" == "False" ]; then
                        mkdir -p "$(dirname "${python_test_log}")"
                        cp "test_log" "${python_test_log}"
                    else
                        rm -f "${python_test_log}" || :
                    fi
                    # Make install
                    make install 2>&1 || continue  # Should be run serially
                    install_success="True"
                    break
                done
                if [ "${install_success}" == "True" ]; then
                    break
                fi
            done
            if [ "${install_success}" == "True" ]; then
                break
            fi
        done
        if [ "${install_success}" == "True" ]; then
            break
        fi
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install Python"
        exit 1
    fi
    reset_environment
    cp "LICENSE" "README.rst" "${python_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/python" || :
    install_notice "Python" "${python_dir}"
fi
# Create a python variable, storing the path to the Python interpreter
if [ -n "${python_dir}" ]; then
    found_python_interpreter="False"
    for python_version_major in 3 2; do
        if [ -f "${python_dir}/bin/python${python_version_major}" ]; then
            found_python_interpreter="True"
            break
        fi
    done
    if [ "${found_python_interpreter}" == "True" ]; then
        python_version_major_dot_minor=$("${python_dir}/bin/python${python_version_major}" -c \
            "from sys import version_info as v; print(str(v.major) + '.' + str(v.minor))")
        python="${python_dir}/bin/python${python_version_major_dot_minor}"
    fi
fi



###########################
# Install Python packages #
###########################
# Set "pypackage"_installed variables
blessings_installed="False"
cython_installed="False"
cythongsl_installed="False"
h5py_installed="False"
matplotlib_installed="False"
mpi4py_installed="False"
numpy_installed="False"
pytest_installed="False"
scipy_installed="False"
sphinx_installed="False"
sphinx_copybutton_installed="False"
sphinx_rtd_theme_installed="False"
sphinx_tabs_installed="False"
if [ -n "${python}" ]; then
    current_step="checking of installed Python packages"
    set_status "Checking for installed Python packages"
    for pypackage in blessings         \
                     cython            \
                     cythongsl         \
                     h5py              \
                     matplotlib        \
                     mpi4py            \
                     numpy             \
                     pytest            \
                     scipy             \
                     sphinx            \
                     sphinx_copybutton \
                     sphinx_rtd_theme  \
                     sphinx_tabs       \
                     pip               \
    ; do
        pypackage_installed=$(check_pypackage_installed ${pypackage})
        eval "${pypackage}_installed=\"${pypackage_installed}\""
    done
fi

# Function for downloading Python packages, utilizing pip
pip_download(){
    # Arguments: Python package name, version, pip_download_time.
    # No second argument, blank second argument or a second argument of
    # "upgrade" means newest version. The second argument can also be a
    # version string that pip understands, e.g. ">=1.4".
    # The third argument determines how many seconds pip shoul get
    # to download the package before it is killed. This can be helpful
    # if pip (for whatever reason) decides to run the setup.py file of
    # the package after a successful download, and that process ends
    # up hanging. If no third argument is given, or if the third
    # argument is 0, no time limit is set.
    local command_end=""
    if [ -n "${2}" ] && [ "${2}" != "upgrade" ]; then
        if [[ "${2}" == [0-9]* ]]; then
            # Second argument is a specific version
            command_end="==${2}"
        else
            # Second argument is a version string that pip understands
            command_end="${2}"
        fi
    fi
    pip_name="$(echo "${1}" | tr '[:upper:]' '[:lower:]')"
    pip_name_nodashes="${pip_name//-/}"
    pip_name_nodashes="${pip_name_nodashes//_/}"
    tmp_pip_dir="${top_dir}/tmp/pip"
    mkdir -p "${tmp_pip_dir}"
    tmp_pip_dir="${tmp_pip_dir// /\\ }"  # Add backslashes before spaces
    # Maximum allowed time (in seconds) for download. After this time,
    # the download process will be killed. This is needed because the
    # process sometimes hang after an otherwise successful download.
    pip_download_time=3600
    if [ -n "${3}" ]; then
        pip_download_time=${3}
    fi
    # Download the Python package
    for n in {1..10}; do
        pip_status="error"
        # Dependent on the version of pip, different calling conventions
        # are used to download (and not install) the source code
        # of a Python package.
        for pip_args in \
            "download -v -v -v        \
                --no-cache-dir        \
                --no-binary=:all:     \
                --dest=${tmp_pip_dir} \
                ${pip_name}${command_end}" \
            "install -v -v -v     \
                --no-cache-dir    \
                --no-binary=:all: \
                --download        \
                ${tmp_pip_dir}    \
                ${pip_name}${command_end}" \
            "install -v -v -v  \
                --no-cache-dir \
                --no-use-wheel \
                --download     \
                ${tmp_pip_dir} \
                ${pip_name}${command_end}" \
            "install -v -v -v  \
                --no-use-wheel \
                --download     \
                ${tmp_pip_dir} \
                ${pip_name}${command_end}" \
        ; do
            # Problems after adoption of PEP 517 can cause packages that
            # fail to build to be cleaned up, even when we just want the
            # bare source (happens for e.g. pip 20.0.2 and scipy 1.4.1).
            # On failure we try disregarding PEP 517.
            for extra_pip_arg in "" "--no-use-pep517"; do
                all_pip_args="$(echo "${pip_args} ${extra_pip_arg}" \
                    | sed 's/  */ /g' 2>/dev/null || :)"
                if [ -z "${all_pip_args}" ]; then
                    all_pip_args="${pip_args} ${extra_pip_arg}"
                fi
                printf "
Attempting to download Python package \"${pip_name}${command_end}\" \
using pip ${all_pip_args}\n\n"
                # Download Python package
                "${python}" -m pip ${all_pip_args} & pip_download_pid=$!
                # The above command may succeed in retrieving the
                # package, but then hang indefinately.
                # Kill the process after ${pip_download_time} seconds.
                soothe ${pip_download_pid} ${pip_download_time}
                # If the archive exists in the tmp/pip dir,
                # the download completed successfully.
                if ls "${top_dir}/tmp/pip"                            \
                    | sed 's/-//g; s/_//g'                            \
                    | grep -i "${pip_name_nodashes}" > /dev/null 2>&1 \
                ; then
                    pip_status="success"
                fi
                if [ "${pip_status}" == "success" ]; then
                    break
                fi
            done
            if [ "${pip_status}" == "success" ]; then
                break
            fi
        done
        if [ "${pip_status}" == "success" ]; then
            break
        fi
        sleep ${sleep_time}
    done
    if [ "${pip_status}" == "error" ]; then
        error "Error downloading ${1}"
        exit 1
    fi
}

# Function for installing and upgrading Python packages, utilizing pip
pip_install_pypackage(){
    # Arguments: Python package name, [version or "upgrade"]
    # (install specific version or update existing version to newest).
    # If second argument is not provided, the newest version
    # will be installed.
    local command_end=""
    pypackage_version=""
    if [ "${2}" == "upgrade" ]; then
        current_step="upgrade of ${1}"
        heading "Upgrading ${1}"
        set_status "Upgrading ${1}"
    else
        if [ -n "${2}" ]; then
            current_step="installation of ${1} ${2}"
            heading "Installing ${1} ${2}"
            set_status "Installing ${1} ${2}"
        else
            current_step="installation of ${1}"
            heading "Installing ${1}"
            set_status "Installing ${1}"
        fi
        if [ -n "${2}" ]; then
            pypackage_version="${2}"
            if [[ "${pypackage_version}" == *"="* ]] || [[ "${pypackage_version}" == *"<"* ]] \
                || [[ "${pypackage_version}" == *">"* ]]; then
                    command_end="${pypackage_version}"
            else
                command_end="==${pypackage_version}"
            fi
        fi
    fi
    # Download Python package source
    tmp_pip_dir="${top_dir}/tmp/pip"
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp" || :
    mkdir -p "${tmp_pip_dir}" "${tmp_pip_dir}_tmp"
    export TMPDIR="${tmp_pip_dir}_tmp"
    pypackage="$(echo "${1}" | tr '[:upper:]' '[:lower:]')"
    pip_download "${pypackage}" "${2}"
    rm -rf "${tmp_pip_dir}_cp" || :
    cp -r "${tmp_pip_dir}" "${tmp_pip_dir}_cp"
    # Install Python package from source
    upgrade_flag=""
    if [ "${2}" == "upgrade" ]; then
        upgrade_flag="--upgrade"
    fi
    for force_recythonization in "False" "True"; do
        if [ "${force_recythonization}" == "True" ]; then
            # Some Python packages may contain pre-cythonized files as
            # part of their source code. If this is done with a Cython
            # version that is incompatible with the Python version in
            # use, this can lead to failure. We now try deleting any
            # such pre-cythonized files, forcing re-cythonization.
            working_cython=$(check_pypackage_installed cython)
            if [ "${working_cython}" == "False" ]; then
                continue
            fi
            rm -rf "${tmp_pip_dir}" || :
            cp -r "${tmp_pip_dir}_cp" "${tmp_pip_dir}"
            # Extract source files
            wd="$(pwd)"
            cd "${tmp_pip_dir}"
            pypackage_archive=""
            for f in *; do
                f_lower="$(echo "${f}" | tr '[:upper:]' '[:lower:]')"
                if [ ! -d "${f}" ] && [[ "${f_lower}" == "${pypackage}"* ]]; then
                    pypackage_archive="${f}"
                    break
                fi
            done
            extract "${pypackage_archive}" "True"
            for f in *; do
                f_lower="$(echo "${f}" | tr '[:upper:]' '[:lower:]')"
                if [ -d "${f}" ] && [[ "${f_lower}" == "${pypackage}"* ]]; then
                    cd "${f}"
                    break
                fi
            done
            # Remove pre-cythonized files
            precythonized="$(grep -r -l '^/\* Generated by Cython' .)"
            if [ -z "${precythonized}" ]; then
                cd "${wd}"
                continue
            fi
            rm -f ${precythonized}
            # Pack source into a tar.gz file with the name
            # <package>-<version>.tar.gz, which takes the place of the
            # downloaded archive.
            cd ..
            rm -rf "${pypackage_archive}"
            if [ -n "${pypackage_version}" ]; then
                pypackage_archive="${pypackage}-${pypackage_version}.tar.gz"
            else
                pypackage_archive="${pypackage}.tar.gz"
            fi
            tar -cvf - "${f}" | gzip > "${pypackage_archive}"
            rm -rf "${f}"
            cd "${wd}"
            rm -rf "${tmp_pip_dir}_cp" || :
            cp -r "${tmp_pip_dir}" "${tmp_pip_dir}_cp"
            # The re-cythonization should be carried out using the
            # Cython that is installed on the Python that we work with.
            # It may however be fetched from the PATH, and so we need to
            # ensure that the first Cython ('cython', 'cythonize') on
            # the PATH is the correct one.
            if [ -d "${python_dir}/bin" ]; then
                export PATH="${python_dir}/bin:${PATH}"
            fi
        fi
        for pyuser in "" "--user"; do
            # After the adoption of PEP 518 (pip 10), some packages
            # require wheels (not bare source) when building. This can
            # be disabled by supplying --no-build-isolation. We try
            # both. Some times the installation process will appear to
            # hang, but it will eventually get going. This happens often
            # for particular packages, such as h5py. When this is the
            # case, write a soothing message.
            for extra_pip_arg in "--no-cache-dir"     \
                "--no-cache-dir --no-build-isolation" \
                "--no-build-isolation"                \
                ""; do
                if [ -n "${extra_pip_arg}" ]; then
                    printf "\npip failed to install ${1}. \
Now trying with ${pyuser} ${extra_pip_arg}\n\n"
                fi
                rm -rf "${tmp_pip_dir}" || :
                cp -r "${tmp_pip_dir}_cp" "${tmp_pip_dir}"
                if [ -z "${upgrade_flag}" ]; then
                    printf "
Attempting to install ${1} using pip with force_recythonization=${force_recythonization}, \
pyuser=${pyuser}, extra_pip_arg=${extra_pip_arg}\n\n"
                    "${python}" -m pip uninstall "${pypackage}" -y >/dev/null 2>&1 || :
                fi
                "${python}" -m pip install ${pyuser} -v -v -v                \
                                           ${extra_pip_arg}                  \
                                           -b "${tmp_pip_dir}/build"         \
                                           ${upgrade_flag}                   \
                                           --no-index                        \
                                           --find-links="${tmp_pip_dir}"     \
                                           "${pypackage}${command_end}" 2>&1 \
                                            & pip_install_pid=$!
                soothe ${pip_install_pid}
                pypackage_installed=$(check_pypackage_installed ${pypackage})
                if [ "${pypackage_installed}" == "True" ]; then
                    break
                fi
            done
            if [ "${pypackage_installed}" == "True" ]; then
                break
            fi
            # If we failed to install the Python package,
            # try installing it via pip without supplying
            # the many additional arguments.
            if [ "${force_recythonization}" == "True" ]; then
                continue
            fi
            rm -rf "${tmp_pip_dir}" || :
            for extra_pip_arg in "--no-cache-dir"     \
                "--no-cache-dir --no-build-isolation" \
                "--no-build-isolation"                \
                ""; do
                printf "
Attempting to install ${1} using pip with default settings, \
force_recythonization=${force_recythonization}, pyuser=${pyuser}, \
extra_pip_arg=${extra_pip_arg}\n\n"
                if [ -z "${upgrade_flag}" ]; then
                    "${python}" -m pip uninstall "${pypackage}" -y >/dev/null 2>&1 || :
                fi
                "${python}" -m pip install ${pyuser} ${extra_pip_arg} \
                    "${pypackage}${command_end}" 2>&1 & pip_install_pid=$!
                soothe ${pip_install_pid}
                pypackage_installed=$(check_pypackage_installed ${pypackage})
                if [ "${pypackage_installed}" == "True" ]; then
                    break
                fi
            done
            if [ "${pypackage_installed}" == "True" ]; then
                break
            fi
        done
        if [ "${pypackage_installed}" == "True" ]; then
            break
        fi
    done
    reset_environment
    # Exit on failure
    if [ "${pypackage_installed}" != "True" ]; then
        echo "pip could not install/upgrade ${1}"
        return 1
    fi
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp" "${tmp_pip_dir}_cp" || :
}

# Upgrade/install setuptools, pip and wheel.
# Do not use the pip_download or pip_install_pypackage functions
# for this, as these packages (and their dependencies) may actually be
# needed for that to work, resulting in a bootstrapping problem.
# This problem really arises from the choice of installing Python
# packages from source. Let 'pip install' upgrade setuptools, pip and
# wheel by whatever means it wants, ensuring that the dependencies of
# these bootstrapping packages are installed/upgraded as well.
if [ "${pip_install}" == "True" ] && [ "${python_installed}" == "False" ]; then
    tmp_pip_dir="${top_dir}/tmp/pip"
    export TMPDIR="${tmp_pip_dir}_tmp"
    for package in "setuptools" "pip" "wheel"; do
        current_step="upgrade/install of ${package}"
        heading "Upgrading/installing ${package}"
        set_status "Upgrading/installing ${package}"
        eval "package_version=\${${package}_version}"
        # Dependent on the version of pip,
        # the --no-cache-dir option may be available or not.
        pip_success="True"
        for extra_pip_arg in "--no-cache-dir" ""; do
            rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp" || :
            mkdir -p "${tmp_pip_dir}" "${tmp_pip_dir}_tmp"
            "${python}" -m pip install -v -v -v                  \
                                       ${extra_pip_arg}          \
                                       -b "${tmp_pip_dir}/build" \
                                       --upgrade                 \
                                       "${package}==${package_version}" 2>&1 || pip_success="False"
            if [ "${pip_success}" == "True" ]; then
                break
            fi
        done
        # Do not exit on failure, but write a warning
        if [ "${pip_success}" == "False" ]; then
            error "Could not upgrade ${package}"
        fi
    done
    reset_environment
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp" || :
fi

# The code below will upgrade all packages pre-installed
# with the newly installed Python distribution,
# if upgrade_preinstalled_pypackages is True.
if [ -z "${upgrade_preinstalled_pypackages}" ]; then
    upgrade_preinstalled_pypackages="False"
fi
if [ "${python_install}" == "True" ] && [ "${python_installed}" == "False" ] \
    && [ "${upgrade_preinstalled_pypackages}" == "True" ]; then
    installed_packages_success="True"
    installed_packages="$("${python}" -m pip list --format=colu2mns 2>/dev/null)" \
        || installed_packages_success="False"
    if [ "${installed_packages_success}" == "False" ]; then
        installed_packages_success="True"
        installed_packages="$("${python}" -m pip list 2>/dev/null)" \
            || installed_packages_success="False"
    fi
    if [ "${installed_packages_success}" == "False" ]; then
        installed_packages="$("${python}" -c "
import pip
print('\n'.join([i.key for i in pip.get_installed_distributions()]))
")"
    fi
    installed_packages="$("${python}" -c "
packages = '''${installed_packages}'''.split('\n')
for i, package in enumerate(packages):
    if not package.strip().replace(' ', '').replace('-', ''):
        packages = packages[i+1:]
        break
print('\n'.join(packages))
" | awk '{print $1}')"
    while read package; do
        # No need to attempt updates of pip, setuptools and wheel,
        # as these have just been updated.
        if     [ "${package}" == "pip"        ] \
            || [ "${package}" == "setuptools" ] \
            || [ "${package}" == "wheel"      ]; then
            continue
        fi
        # Attempt to update all other installed Python packages
        for n in {1..10}; do
            pip_success="True"
            pip_install_pypackage "${package}" "upgrade" || pip_success="False"
            if [ "${pip_success}" == "True" ]; then
                break
            fi
        done
    done <<< "${installed_packages}"
fi

# Install Python packages from PyPI

# Blessings
if [ "${blessings_install}" == "True" ] && [ "${blessings_installed}" == "False" ]; then
    pip_install_pypackage "Blessings" "${blessings_version}"
fi

# Cython
if [ "${cython_install}" == "True" ] && [ "${cython_installed}" == "False" ]; then
    install_success="False"
    for compiler in "${compiler_possibilities[@]}"; do
        eval "use_${compiler}_compilers" || continue
        printf "
Attempting to install Cython with compiler=${compiler}\n\n"
        pip_install_pypackage "Cython" "${cython_version}"
        if [ "$(check_pypackage_installed cython)" == "False" ]; then
            continue
        fi
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install Cython"
        exit 1
    fi
    reset_environment
fi

# CythonGSL
if [ "${cythongsl_install}" == "True" ] && [ "${cythongsl_installed}" == "False" ]; then
    install_success="False"
    for compiler in "${compiler_possibilities[@]}"; do
        reset_environment
        eval "use_${compiler}_compilers" || continue
        printf "
Attempting to install CythonGSL with compiler=${compiler}\n\n"
        export LD_LIBRARY_PATH="${gsl_dir}/lib:${LD_LIBRARY_PATH}"
        pip_install_pypackage "CythonGSL" "${cythongsl_version}"
        if [ "$(check_pypackage_installed cythongsl)" == "False" ]; then
            continue
        fi
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install CythonGSL"
        exit 1
    fi
    reset_environment
fi

# pytest
if [ "${pytest_install}" == "True" ] && [ "${pytest_installed}" == "False" ]; then
    # As pytest is not a critical dependency (it is only used for
    # testing NumPy and SciPy), we continue past failure to install it.
    install_success="True"
    pip_install_pypackage "pytest" "${pytest_version}" || install_success="False"
    if [ "${install_success}" == "False" ]; then
        error "Failed to install pytest. The installation will continue regardless."
    fi
fi

# NumPy (manual invocation of setup.py is needed
# as we need to link to OpenBLAS).
if [ "${numpy_install}" == "True" ] && [ "${numpy_installed}" == "False" ]; then
    current_step="installation of NumPy ${numpy_version}"
    heading "Installing NumPy ${numpy_version}"
    set_status "Installing NumPy ${numpy_version}"
    # Download NumPy
    tmp_pip_dir="${top_dir}/tmp/pip"
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp" || :
    mkdir -p "${tmp_pip_dir}_tmp"
    export TMPDIR="${tmp_pip_dir}_tmp"
    pip_download "numpy" "${numpy_version}"
    cd "${tmp_pip_dir}"
    # It can happen that an archive format different from tar.gz is
    # downloaded, in which case the extraction will fail if the
    # corresponding tool is not installed. In that case, try to download
    # NumPy directly from GitHub
    extract "numpy"* "True" || :
    numpy_extract_success="False"
    for f in *; do
        f_lower="$(echo "${f}" | tr '[:upper:]' '[:lower:]')"
        if [ -d "${f}" ] && [[ "${f_lower}" == "numpy"* ]]; then
            numpy_extract_success="True"
            numpy_build_dir="${tmp_pip_dir}/${f}"
            break
        fi
    done
    if [ "${numpy_extract_success}" == "False" ]; then
        numpy_url="https://github.com/numpy/numpy/archive/v${numpy_version}.tar.gz"
        download "numpy"
        cd "${top_dir}/tmp/numpy"
        extract * "True"
        for f in *; do
            f_lower="$(echo "${f}" | tr '[:upper:]' '[:lower:]')"
            if [ -d "${f}" ] && [[ "${f_lower}" == "numpy"* ]]; then
                numpy_build_dir="${top_dir}/tmp/numpy/${f}"
                break
            fi
        done
    fi
    # Create a site.cfg file containing information about OpenBLAS
    echo "[DEFAULT]
library_dirs = ${blas_dir}/lib
include_dirs = ${blas_dir}/include

[ALL]
library_dirs = ${blas_dir}/lib
include_dirs = ${blas_dir}/include

[atlas]
atlas_libs = openblas
libraries = openblas

[openblas]
libraries = openblas
library_dirs = ${blas_dir}/lib
include_dirs = ${blas_dir}/include
runtime_library_dirs = ${blas_dir}/lib
" > "${numpy_build_dir}/site.cfg"
    # Build and install NumPy with OpenBLAS support.
    # We wish to use the gfortran Fortran compiler. We try out all the
    # compiler environments but overwriting the Fortran compiler.
    # If this fails, we retry without overwriting the Fortran compiler.
    # On some systems, several additional environment variables need to
    # be modified. We try all combinations until we hit a working one.
    cp -r "${numpy_build_dir}" "${numpy_build_dir}_cp"
    install_success="False"
    for pyuser in "" "--user"; do
        for numpy_gfortran in "True" "False"; do
            for compiler in "${compiler_possibilities[@]}"; do
                for cstd in "-std=c99" ""; do
                    for fcompiler in "gnu95" ""; do
                        for extra_FCFLAGS in "" "-fPIC"; do
                            for extra_LDFLAGS in "" "-shared"; do
                                reset_environment
                                eval "use_${compiler}_compilers" || continue
                                printf "
Attempting to install NumPy with pyuser=${pyuser}, numpy_gfortran=${numpy_gfortran}, \
compiler=${compiler}, cstd=${cstd}, fcompiler=${fcompiler}, extra_FCFLAGS=${extra_FCFLAGS}, \
extra_LDFLAGS=${extra_LDFLAGS}\n\n"
                                if [ "${numpy_gfortran}" == "True" ]; then
                                    export FC="gfortran"
                                    export F77="gfortran"
                                    export F90="gfortran"
                                    export F9X="gfortran"
                                fi
                                export CFLAGS="${CFLAGS} ${cstd}"
                                export TMPDIR="${tmp_pip_dir}_tmp"
                                export BLAS="${blas_dir}/lib/libopenblas.a"
                                export LAPACK="${blas_dir}/lib/libopenblas.a"
                                export LD_LIBRARY_PATH="${blas_dir}/lib:${LD_LIBRARY_PATH}"
                                export FCFLAGS="${extra_FCFLAGS} ${FCFLAGS}"
                                export FFLAGS="${extra_FCFLAGS} ${FFLAGS}"
                                export LDFLAGS="${extra_LDFLAGS} ${LDFLAGS}"
                                rm -rf "${numpy_build_dir}" || :
                                cp -r "${numpy_build_dir}_cp" "${numpy_build_dir}"
                                cd "${numpy_build_dir}"
                                echo "True" > ".setuppy_success"
                                if [ -n "${fcompiler}" ]; then
                                    ("${python}" setup.py build --fcompiler="${fcompiler}" \
                                        || echo "False" > ".setuppy_success") & setuppy_pid=$!
                                else
                                    ("${python}" setup.py build \
                                        || echo "False" > ".setuppy_success") & setuppy_pid=$!
                                fi
                                soothe ${setuppy_pid}
                                sleep 1
                                setuppy_success="$(cat '.setuppy_success')"
                                if [ "${setuppy_success}" != "True" ]; then
                                    continue
                                fi
                                "${python}" setup.py install ${pyuser} & setuppy_pid=$!
                                soothe ${setuppy_pid}
                                if [ "$(check_pypackage_installed numpy)" == "False" ]; then
                                    continue
                                fi
                                install_success="True"
                                break
                            done
                            if [ "${install_success}" == "True" ]; then
                                break
                            fi
                        done
                        if [ "${install_success}" == "True" ]; then
                            break
                        fi
                    done
                    if [ "${install_success}" == "True" ]; then
                        break
                    fi
                done
                if [ "${install_success}" == "True" ]; then
                    break
                fi
            done
            if [ "${install_success}" == "True" ]; then
                break
            fi
        done
        if [ "${install_success}" == "True" ]; then
            break
        fi
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install NumPy"
        exit 1
    fi
    cd "${top_dir}"
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp" "${top_dir}/tmp/numpy" || :
    reset_environment
    # Test NumPy
    if [ "${do_tests}" == "True" ]; then
        # Kill the testing and consider it failed if any given test
        # takes longer than numpy_test_max_time seconds.
        numpy_test_max_time=600
        exit_code_filename="${top_dir}/tmp/.exit_code_numpy"
        export LD_LIBRARY_PATH="${blas_dir}/lib:${LD_LIBRARY_PATH}"
        ("${python}" -c "import numpy; numpy.test('full', verbose=2, \
extra_argv=['--color=yes'])" 2>&1 | tee "${numpy_test_log}"; \
         echo "${PIPESTATUS[0]}" > "${exit_code_filename}") & numpy_test_pid=$!
        soothe ${numpy_test_pid} ${numpy_test_max_time}
        sleep 1
        kill -9 ${numpy_test_pid} >/dev/null 2>&1 || :
        wait    ${numpy_test_pid} >/dev/null 2>&1 || :
        exit_code="$(wait ${numpy_test_pid} >/dev/null 2>&1 || echo $?)"
        if [ -n "${exit_code}" ]; then
            numpy_test_success="False"
        else
            exit_code="$(cat "${exit_code_filename}" 2>/dev/null || :)"
            if [ "${exit_code}" != "0" ]; then
                numpy_test_success="False"
            fi
        fi
        if tail -n 1 "${numpy_test_log}" | grep " failed" >/dev/null 2>&1; then
            numpy_test_success="False"
        fi
        if [ "${numpy_test_success}" == "True" ]; then
            rm -f "${numpy_test_log}" || :
        fi
        rm -f "${exit_code_filename}" || :
    fi
    reset_environment
fi

# SciPy (manual invocation of setup.py is needed
# as we need to link to OpenBLAS).
if [ "${scipy_install}" == "True" ] && [ "${scipy_installed}" == "False" ]; then
    # As of SciPy 1.4, pybind11 is a required dependency, though this is
    # not automatically installed by pip. If not already installed, we
    # install this Python package now.
    pybind11_installed=$(check_pypackage_installed pybind11)
    if [ "${pybind11_installed}" == "False" ]; then
        pip_install_pypackage "pybind11"
    fi
    current_step="installation of SciPy ${scipy_version}"
    heading "Installing SciPy ${scipy_version}"
    set_status "Installing SciPy ${scipy_version}"
    # Download SciPy
    tmp_pip_dir="${top_dir}/tmp/pip"
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp" || :
    mkdir -p "${tmp_pip_dir}_tmp"
    export TMPDIR="${tmp_pip_dir}_tmp"
    pip_download "scipy" "${scipy_version}"
    cd "${tmp_pip_dir}"
    extract "scipy"* "True"
    for f in *; do
        f_lower="$(echo "${f}" | tr '[:upper:]' '[:lower:]')"
        if [ -d "${f}" ] && [[ "${f_lower}" == "scipy"* ]]; then
            scipy_build_dir="${tmp_pip_dir}/${f}"
            break
        fi
    done
    # Create a site.cfg file containing information about OpenBLAS
    echo "[DEFAULT]
library_dirs = ${blas_dir}/lib
include_dirs = ${blas_dir}/include

[ALL]
library_dirs = ${blas_dir}/lib
include_dirs = ${blas_dir}/include

[atlas]
atlas_libs = openblas
libraries = openblas

[openblas]
libraries = openblas
library_dirs = ${blas_dir}/lib
include_dirs = ${blas_dir}/include
runtime_library_dirs = ${blas_dir}/lib
" > "${scipy_build_dir}/site.cfg"
    # At least in SciPy 1.4.1, compilation of SciPy may fail with an
    # error stating that int64_t has not been declared.
    # We fix this below.
    rectangular_lsap="${scipy_build_dir}/scipy/optimize/rectangular_lsap/rectangular_lsap.cpp"
    echo "
/* Fix needed at least for SciPy 1.4.1 */
#include \"rectangular_lsap.h\"

$(cat "${rectangular_lsap}")
" > "${rectangular_lsap}"
    # Build and install SciPy with OpenBLAS support.
    # We wish to use the gfortran Fortran compiler. We try out all the
    # compiler environments but overwriting the Fortran compiler.
    # If this fails, we retry without overwriting the Fortran compiler.
    # On some systems, several additional environment variables need to
    # be modified. We try all combinations until we hit a working one.
    cp -r "${scipy_build_dir}" "${scipy_build_dir}_cp"
    install_success="False"
    for pyuser in "" "--user"; do
        for scipy_gfortran in "True" "False"; do
            for compiler in "${compiler_possibilities[@]}"; do
                for cstd in "-std=c99" ""; do
                    for fcompiler in "gnu95" ""; do
                        for extra_FCFLAGS in "" "-fPIC"; do
                            for extra_LDFLAGS in "" "-shared"; do
                                reset_environment
                                eval "use_${compiler}_compilers" || continue
                                printf "
Attempting to install SciPy with pyuser=${pyuser}, scipy_gfortran=${scipy_gfortran}, \
compiler=${compiler}, cstd=${cstd}, fcompiler=${fcompiler}, extra_FCFLAGS=${extra_FCFLAGS}, \
extra_LDFLAGS=${extra_LDFLAGS}\n\n"
                                if [ "${scipy_gfortran}" == "True" ]; then
                                    export FC="gfortran"
                                    export F77="gfortran"
                                    export F90="gfortran"
                                    export F9X="gfortran"
                                fi
                                export CFLAGS="${CFLAGS} ${cstd}"
                                export TMPDIR="${tmp_pip_dir}_tmp"
                                export BLAS="${blas_dir}/lib/libopenblas.a"
                                export LAPACK="${blas_dir}/lib/libopenblas.a"
                                export LD_LIBRARY_PATH="${blas_dir}/lib:${LD_LIBRARY_PATH}"
                                export FCFLAGS="${extra_FCFLAGS} ${FCFLAGS}"
                                export FFLAGS="${extra_FCFLAGS} ${FFLAGS}"
                                export LDFLAGS="${extra_LDFLAGS} ${LDFLAGS}"
                                cd "${top_dir}"
                                rm -rf "${scipy_build_dir}" || :
                                cp -r "${scipy_build_dir}_cp" "${scipy_build_dir}"
                                cd "${scipy_build_dir}"
                                echo "True" > ".setuppy_success"
                                if [ -n "${fcompiler}" ]; then
                                    ("${python}" setup.py build --fcompiler="${fcompiler}" \
                                        || echo "False" > ".setuppy_success") & setuppy_pid=$!
                                else
                                    ("${python}" setup.py build \
                                        || echo "False" > ".setuppy_success") & setuppy_pid=$!
                                fi
                                soothe ${setuppy_pid}
                                sleep 1
                                setuppy_success="$(cat '.setuppy_success')"
                                if [ "${setuppy_success}" != "True" ]; then
                                    continue
                                fi
                                "${python}" setup.py install ${pyuser} & setuppy_pid=$!
                                soothe ${setuppy_pid}
                                if [ "$(check_pypackage_installed scipy)" == "False" ]; then
                                    continue
                                fi
                                install_success="True"
                                break
                            done
                            if [ "${install_success}" == "True" ]; then
                                break
                            fi
                        done
                        if [ "${install_success}" == "True" ]; then
                            break
                        fi
                    done
                    if [ "${install_success}" == "True" ]; then
                        break
                    fi
                done
                if [ "${install_success}" == "True" ]; then
                    break
                fi
            done
            if [ "${install_success}" == "True" ]; then
                break
            fi
        done
        if [ "${install_success}" == "True" ]; then
            break
        fi
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install SciPy"
        exit 1
    fi
    cd "${top_dir}"
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp" || :
    reset_environment
    # Test SciPy
    if [ "${do_tests}" == "True" ]; then
        # Kill the testing and consider it failed if any given test
        # takes longer than scipy_test_max_time seconds.
        scipy_test_max_time=600
        # We skip the test_face test as this require bz2,
        # which may not be installed.
        exit_code_filename="${top_dir}/tmp/.exit_code_scipy"
        export LD_LIBRARY_PATH="${blas_dir}/lib:${LD_LIBRARY_PATH}"
        ("${python}" -c "import scipy; scipy.test('full', verbose=2, \
extra_argv=['--color=yes', '-k not test_face'])" 2>&1 | tee "${scipy_test_log}"; \
         echo "${PIPESTATUS[0]}" > "${exit_code_filename}") & scipy_test_pid=$!
        soothe ${scipy_test_pid} ${scipy_test_max_time}
        sleep 1
        kill -9 ${scipy_test_pid} >/dev/null 2>&1 || :
        wait    ${scipy_test_pid} >/dev/null 2>&1 || :
        exit_code="$(wait ${scipy_test_pid} >/dev/null 2>&1 || echo $?)"
        if [ -n "${exit_code}" ]; then
            scipy_test_success="False"
        else
            exit_code="$(cat "${exit_code_filename}" 2>/dev/null || :)"
            if [ "${exit_code}" != "0" ]; then
                scipy_test_success="False"
            fi
        fi
        if tail -n 1 "${scipy_test_log}" | grep " failed" >/dev/null 2>&1; then
                scipy_test_success="False"
        fi
        if [ "${scipy_test_success}" == "True" ]; then
            rm -f "${scipy_test_log}" || :
        fi
        rm -f "${exit_code_filename}" || :
    fi
    reset_environment
fi

# Matplotlib (as Matplotlib has a hard time finding FreeType,
# some hacks are needed).
if [ "${matplotlib_install}" == "True" ] && [ "${matplotlib_installed}" == "False" ]; then
    current_step="installation of Matplotlib ${matplotlib_version}"
    heading "Installing Matplotlib ${matplotlib_version}"
    set_status "Installing Matplotlib ${matplotlib_version}"
    # Download matplotlib itself
    tmp_pip_dir="${top_dir}/tmp/pip"
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp" || :
    mkdir -p "${tmp_pip_dir}_tmp"
    export TMPDIR="${tmp_pip_dir}_tmp"
    pip_download "matplotlib" "${matplotlib_version}"
    # Matplotlib depends on other Python packages not directly used
    # by COð˜•CEPT. Most often these dependencies are downloaded
    # automatically by the previous command. In case of failure,
    # we do it manually.
    matplotlib_pyparsing_installed=$(check_pypackage_installed "pyparsing")
    matplotlib_dateutil_installed=$(check_pypackage_installed "dateutil")
    matplotlib_cycler_installed=$(check_pypackage_installed "cycler")
    matplotlib_kiwisolver_installed=$(check_pypackage_installed "kiwisolver")
    if [ "${pypackage_installed}" == "True" ]; then
        break
    fi
    if [ "${numpy_preinstalled}" == "True" ] || [ "${numpy_install}" == "True" ]; then
        # NumPy already installed
        deps=(                \
            "pyparsing"       \
            "python-dateutil" \
            "cycler"          \
            "kiwisolver"      \
        )
        # From https://matplotlib.org/3.1.1/users/installing.html and
        # https://github.com/matplotlib/matplotlib/blob/v3.1.2/setupext.py
        dep_versions=(
            ">=2.0.1,!=2.0.4,!=2.1.2,!=2.1.6" \
            ">=2.1"                           \
            ">=0.10.0"                        \
            ">=1.0.1"                         \
        )
    else
        # NumPy not installed. Add it as a matplotlib dependency
        deps=(                \
            "numpy"           \
            "pyparsing"       \
            "python-dateutil" \
            "cycler"          \
            "kiwisolver"      \
        )
        # From http://matplotlib.org/users/installing.html and matplotlib's setupext.py
        dep_versions=(
            ">=1.11"                          \
            ">=2.0.1,!=2.0.4,!=2.1.2,!=2.1.6" \
            ">=2.1"                           \
            ">=0.10.0"                        \
            ">=1.0.1"                         \
        )
    fi
    # An illegal version of pyparsing may be downloaded by Matplotlib!
    pyparsing_downloaded="$(ls "${top_dir}/tmp/pip" | grep -i "pyparsing" || :)"
    illegal_pyparsings=("2.0.0" "2.0.4" "2.1.2" "2.1.6")
    for ((i=0; i<${#illegal_pyparsings[@]}; i+=1)); do
        if [[ "${pyparsing_downloaded}" == "pyparsing-${illegal_pyparsings[i]}"* ]]; then
            # Illegal pyparsing downloaded!
            rm -rf "${top_dir}/tmp/pip/pyparsing"* || :
            break
        fi
    done
    for ((i=0; i<${#deps[@]}; i+=1)); do
        if ! ls "${top_dir}/tmp/pip" | grep -i "${deps[i]}" > /dev/null 2>&1; then
            pip_download "${deps[i]}" "${dep_versions[i]}"
        fi
    done
    # Install matplotlib
    cd "${tmp_pip_dir}"
    extract "matplotlib"* "True"
    for f in *; do
        f_lower="$(echo "${f}" | tr '[:upper:]' '[:lower:]')"
        if [ -d "${f}" ] && [[ "${f_lower}" == "matplotlib"* ]]; then
            cd "${f}"
            break
        fi
    done
    cp "setup.cfg.template" "setup.cfg"
    freetype_include2="$(echo "${freetype_dir}/include/freetype"* | awk '{print $NF}')"
    libpng_version_majors="${libpng_version%.*}"
    libpng_version_majors="${libpng_version_majors//./}"
    basedirlist="${freetype_dir},\
${freetype_dir}/include,\
${freetype_include2},\
${freetype_dir}/lib,\
${libpng_dir},\
${libpng_dir}/include,\
${libpng_dir}/lib,\
${libpng_dir}/include/libpng${libpng_version_majors},\
${zlib_dir},\
${zlib_dir}/include,\
${zlib_dir}/lib\
"
    sed -i "/basedirlist/c\basedirlist = ${basedirlist}" "setup.cfg"
    cp -r "${freetype_include2}/"* "${freetype_dir}/include/"
    export CPPFLAGS="-I${freetype_dir}/include                              \
                     -I${freetype_include2}                                 \
                     -I${libpng_dir}/include                                \
                     -I${libpng_dir}/include/libpng${libpng_version_majors} \
                     -I${zlib_dir}/include ${CPPFLAGS}"
    export LDFLAGS="-L${freetype_dir}/lib          \
                    -Wl,-rpath=${freetype_dir}/lib \
                    -L${libpng_dir}/lib            \
                    -Wl,-rpath=${libpng_dir}/lib   \
                    -L${zlib_dir}/lib              \
                    -Wl,-rpath=${zlib_dir}/lib ${LDFLAGS}"
    export PATH="${freetype_dir}/bin:${libpng_dir}/bin:${PATH}"
    export LD_LIBRARY_PATH="${libpng_dir}/lib:${LD_LIBRARY_PATH}"
    export LD_LIBRARY_PATH="${zlib_dir}/lib:${LD_LIBRARY_PATH}"
    export LD_LIBRARY_PATH="${blas_dir}/lib:${LD_LIBRARY_PATH}"
    export PKG_CONFIG_PATH="${libpng_dir}/lib/pkgconfig:\
${zlib_dir}/lib/pkgconfig:${PKG_CONFIG_PATH}"
    # After the adoption of PEP 518 (pip 10), some packages require
    # wheels (not bare source) when building. This can be disabled by
    # supplying --no-build-isolation. We try both.
    # Some times the installation process will appear to hang,
    # but it will eventually get going. When this is the case,
    # write a soothing message.
    for extra_pip_arg in "" "--no-build-isolation"; do
        # Remove matplotlib dependency packages automatically installed
        if [ "${matplotlib_pyparsing_installed}" == "False" ]; then
            "${python}" -m pip uninstall "pyparsing" -y >/dev/null 2>&1 || :
        fi
        if [ "${matplotlib_dateutil_installed}" == "False" ]; then
            "${python}" -m pip uninstall "dateutil" -y >/dev/null 2>&1 || :
        fi
        if [ "${matplotlib_cycler_installed}" == "False" ]; then
            "${python}" -m pip uninstall "cycler" -y >/dev/null 2>&1 || :
        fi
        if [ "${matplotlib_kiwisolver_installed}" == "False" ]; then
            "${python}" -m pip uninstall "kiwisolver" -y >/dev/null 2>&1 || :
        fi
        # Install matplotlib and dependency packages
        "${python}" -m pip uninstall "matplotlib" -y >/dev/null 2>&1 || :
        "${python}" -m pip install -v -v -v                          \
                                   ${extra_pip_arg}                  \
                                   -b "${top_dir}/tmp/pip/build"     \
                                   --no-index                        \
                                   --find-links="${top_dir}/tmp/pip" \
                                   . 2>&1 & pip_install_pid=$!
        soothe ${pip_install_pid}
        pypackage_installed=$(check_pypackage_installed matplotlib)
        if [ "${pypackage_installed}" == "True" ]; then
            break
        fi
        # Matplotlib may not seem to be installed correctly due to
        # CXXABI_1.3.9 required by kiwisolver and not found. Before
        # giving up on the Matplotlib installation, try reinstalling
        # kiwisolver.
        "${python}" -m pip uninstall "kiwisolver" -y >/dev/null 2>&1 || :
        "${python}" -m pip install "kiwisolver>=1.0.1"
        pypackage_installed=$(check_pypackage_installed matplotlib)
        if [ "${pypackage_installed}" == "True" ]; then
            break
        fi
        if [ -z "${extra_pip_arg}" ]; then
            printf "\nFailed to install matplotlib. Now trying with --no-build-isolation\n\n"
        fi
    done
    reset_environment
    cd "${top_dir}"
    # Exit if installation failed
    if [ "${pypackage_installed}" == "False" ]; then
        error "Could not install matplotlib"
        exit 1
    fi
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp" || :
fi

# MPI4Py
if [ "${mpi4py_install}" == "True" ] && [ "${mpi4py_installed}" == "False" ]; then
    install_success="False"
    for compiler in "${compiler_possibilities[@]}"; do
        reset_environment
        eval "use_${compiler}_compilers" || continue
        printf "
Attempting to install MPI4Py with compiler=${compiler}\n\n"
        export PATH="${mpi_bindir}:${mpi_compilerdir}:${PATH}"
        pip_install_pypackage "MPI4Py" "${mpi4py_version}" || continue
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install MPI4Py"
        exit 1
    fi
    reset_environment
fi

# H5Py
if [ "${h5py_install}" == "True" ] && [ "${h5py_installed}" == "False" ]; then
    install_success="False"
    for compiler in "${compiler_possibilities[@]}"; do
        reset_environment
        eval "use_${compiler}_compilers" || continue
        printf "
Attempting to install H5Py with compiler=${compiler}\n\n"
        export LD_LIBRARY_PATH="${hdf5_dir}/lib:${LD_LIBRARY_PATH}"
        if [ -d "${blas_dir}/lib" ]; then
            export LD_LIBRARY_PATH="${blas_dir}/lib:${LD_LIBRARY_PATH}"
        fi
        export HDF5_DIR="${hdf5_dir}"
        export HDF5_MPI="ON"
        if [ -n "${mpicc}" ]; then
            export CC="${mpicc}"
        fi
        pip_install_pypackage "h5py" "${h5py_version}" || continue
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install H5Py"
        exit 1
    fi
    reset_environment
fi

# Sphinx
sphinx_install_success="True"
if [ "${sphinx_install}" == "True" ] && [ "${sphinx_installed}" == "False" ]; then
    # As sphinx is not a critical dependency (it is only used for
    # building the documentation), we continue past failure
    # to install it.
    install_success="True"
    pip_install_pypackage "sphinx" "${sphinx_version}" || install_success="False"
    if [ "${install_success}" == "False" ]; then
        sphinx_install_success="False"
        error "Failed to install Sphinx. The installation will continue regardless."
        sphinx_install="False"  # Flag as not to be installed
    fi
fi

# sphinx_copybutton
if     [ "${sphinx_copybutton_install}"   == "True"  ] \
    && [ "${sphinx_copybutton_installed}" == "False" ] \
    && [ "${sphinx_install_success}"      == "True"  ]; then
    # As sphinx_copybutton is not a critical dependency (it is only used
    # for building the documentation), we continue past failure
    # to install it.
    install_success="True"
    pip_install_pypackage "sphinx_copybutton" "${sphinx_copybutton_version}" \
        || install_success="False"
    if [ "${install_success}" == "False" ]; then
        error "Failed to install sphinx_copybutton. The installation will continue regardless."
        sphinx_copybutton_install="False"  # Flag as not to be installed
    fi
fi

# sphinx_rtd_theme
if     [ "${sphinx_rtd_theme_install}"   == "True"  ] \
    && [ "${sphinx_rtd_theme_installed}" == "False" ] \
    && [ "${sphinx_install_success}"     == "True"  ]; then
    # As sphinx_rtd_theme is not a critical dependency (it is only used
    # for building the documentation), we continue past failure
    # to install it.
    install_success="True"
    pip_install_pypackage "sphinx_rtd_theme" "${sphinx_rtd_theme_version}" \
        || install_success="False"
    if [ "${install_success}" == "False" ]; then
        error "Failed to install sphinx_rtd_theme. The installation will continue regardless."
        sphinx_rtd_theme_install="False"  # Flag as not to be installed
    fi
fi

# sphinx_tabs
if     [ "${sphinx_tabs_install}"    == "True"  ] \
    && [ "${sphinx_tabs_installed}"  == "False" ] \
    && [ "${sphinx_install_success}" == "True"  ]; then
    # As sphinx_tabs is not a critical dependency (it is only used
    # for building the documentation), we continue past failure
    # to install it.
    install_success="True"
    pip_install_pypackage "sphinx_tabs" "${sphinx_tabs_version}" || install_success="False"
    if [ "${install_success}" == "False" ]; then
        error "Failed to install sphinx_tabs. The installation will continue regardless."
        sphinx_tabs_install="False"  # Flag as not to be installed
    fi
fi



###################################
# Install the COð˜•CEPT code itself #
###################################
# Paths used by COð˜•CEPT
concept="${concept_dir}/concept"
docs_dir="${concept_dir}/docs"
ics_dir="${concept_dir}/ICs"
logs_dir="${concept_dir}/logs"
output_dir="${concept_dir}/output"
params_dir="${concept_dir}/params"
reusables_dir="${concept_dir}/.reusables"
tests_dir="${concept_dir}/tests"
utilities_dir="${concept_dir}/utilities"
Gadget2_dir="${gadget_dir}/Gadget2"
installer="${top_dir}/installer"
mpiexec="${mpi_bindir}/mpiexec"
# Move source files, create empty directories and create the .paths file
if [ "${concept_install}" == "True" ] && [ "${concept_installed}" == "False" ]; then
    init_install "CONCEPT"
    # Move everything from the concept-${concept_version}
    # directory to ${top_dir}.
    if [ -f "${top_dir}/installer" ]; then
        # An installation script already exists in the directory where
        # the downloaded installation script for the installed COð˜•CEPT
        # version should go. This pre-existing installation script might
        # be the very file running now, and so it is not safe to
        # overwrite it. Instead, move the new installation script there
        # under a new name, reflecting its version.
        mv "installer" "${top_dir}/installer_${concept_version}"
    fi
    mv ./{.[!.],}* "${top_dir}/"
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/concept" || :
    # Create directories
    mkdir -p "${ics_dir}"
    mkdir -p "${logs_dir}"
    mkdir -p "${output_dir}"
    mkdir -p "${params_dir}"
    # Add PATH-like and a few PYTHON environment variables present at
    # install time (now) to the .env file.
    current_step="setup of the .env file"
    printf "\nSetting up the .env file\n"
    set_status "Setting up the .env file"
    "${python}" -c "
import os
with open('${env_file}', 'r', encoding='utf-8') as file:
    lines = file.readlines()
# Generator for extracting environment variables
def get_envs():
    for var, val in os.environ.items():
        if (
            # PATH, LD_LIBRARY_PATH, ...
            ('path' in var.lower() and (val.startswith('/') or val.startswith(':')))
            # Intel license file
            or (var in {'INTEL_LICENSE_FILE', 'INTEL_LICENCE_FILE'} and val.startswith('/'))
        ):
            yield var, val
# Add environment variables
envs_inserted = False
with open('${env_file}', 'w', encoding='utf-8') as file:
    for line in lines:
        if not envs_inserted and 'Update the environment' in line:
            print('# The following has been placed by the installer script', file=file)
            if '${python_install}' == 'True':
                print('unset PYTHONPATH', file=file)
                print('unset PYTHONHOME', file=file)
                print('export PYTHONNOUSERSITE=\"True\"', file=file)
            print('pathenv_name_value_pairs_installtime=( \\\\', file=file)
            for var, val in get_envs():
                print(f'    {var} \"{val}\" \\\\', file=file)
            print(')', file=file)
            print('', file=file)
            envs_inserted = True
        print(line, end='', file=file)
"
    # If MPI was installed as part of this installation process, it is
    # not set up to function with e.g. Slurm, and so we set the
    # MPI executor to mpiexec explicitly. This should work even when
    # running on multiple nodes, though the network performance will
    # most likely be bad. We further add some arguments to mpiexec
    # depending on the MPI distribution and version.
    if [ "${mpi_preinstalled}" == "False" ]; then
        use_specified_mpi_compilers
        mpiexec_args=""
        if [ "${mpi}" == "mpich" ]; then
            # Though MPICH should not use process binding by default,
            # it still supports a -bind-to none or --bind-to none
            # option. Here we check if this is so, and apply it.
            mpiexec_output="$("${mpiexec}" -bind-to none -n 1 echo "success" 2>&1 || :)"
            if [ "${mpiexec_output}" == "success" ]; then
                mpiexec_args="${mpiexec_args} -bind-to none"
            else
                mpiexec_output="$("${mpiexec}" --bind-to none -n 1 echo "success" 2>&1 || :)"
                if [ "${mpiexec_output}" == "success" ]; then
                    mpiexec_args="${mpiexec_args} --bind-to none"
                fi
            fi
        elif [ "${mpi}" == "openmpi" ]; then
            # In OpenMPI 3 and 4, oversubscription (having more MPI
            # processes than physical cores) is disallowed by default.
            mpi_version_major="${mpi_version:0:1}"
            if [ "${mpi_version_major}" -ge 3 2>/dev/null ]; then
                mpiexec_args="${mpiexec_args} --oversubscribe"
            fi
            # Disable automatic process binding/affinity, allowing
            # OpenMP threads to be assigned to cores in a one-to-one
            # fashion. This is off by default prior to OpenMPI version
            # 1.7. All of 1.7 -- 4.0 supports the --bind-to none option
            # to mpiexec. Here we add this option if it is understood.
            mpiexec_output="$("${mpiexec}" --bind-to none -n 1 echo "success" 2>&1 || :)"
            if [ "${mpiexec_output}" == "success" ]; then
                mpiexec_args="${mpiexec_args} --bind-to none"
            fi
        fi
        sed -i "s/mpi_executor=\"\"/mpi_executor=\"mpiexec${mpiexec_args}\"/" "${env_file}"
        reset_environment
    fi
    # Create the .paths file,
    # storing important paths used by COð˜•CEPT.
    current_step="creation of the .paths file"
    printf "\nWriting paths to .paths\n"
    set_status "Writing paths to .paths"
    echo "# This file contains absolute paths to directories and files
# used by the COð˜•CEPT code. You may manually edit these paths.

#######################
# COð˜•CEPT directories #
#######################
# Directory containing the source code
concept_dir='${concept_dir}'
# Directory containing the documentation
docs_dir='${docs_dir}'
# Directory intended for initial conditions
ics_dir='${ics_dir}'
# Directory containing the log files
logs_dir='${logs_dir}'
# Directory intended for output
output_dir='${output_dir}'
# Directory intended for parameter files
params_dir='${params_dir}'
# Directory containing various reusable dumps
reusables_dir='${reusables_dir}'
# Directory containing tests
tests_dir='${tests_dir}'
# Top level directory, containing e.g. README.md
top_dir='${top_dir}'
# Directory containing utilities
utilities_dir='${utilities_dir}'

##########################
# Dependency directories #
##########################
# Directory of BLAS
blas_dir='${blas_dir}'
# Directory of CLASS
class_dir='${class_dir}'
# Directory of FFTW
fftw_dir='${fftw_dir}'
# Directory of FFTW2, used by GADGET
fftw_for_gadget_dir='${fftw_for_gadget_dir}'
# Directory of Gadget2
gadget_dir='${gadget_dir}'
# Directory containing the GADGET2 source code
Gadget2_dir='${Gadget2_dir}'
# Directory of GSL
gsl_dir='${gsl_dir}'
# Directory of HDF5
hdf5_dir='${hdf5_dir}'
# Directory of libpng
libpng_dir='${libpng_dir}'
# Directories of MPI
mpi_dir='${mpi_dir}'
mpi_compilerdir='${mpi_compilerdir}'
mpi_bindir='${mpi_bindir}'
mpi_libdir='${mpi_libdir}'
mpi_includedir='${mpi_includedir}'
mpi_symlinkdir='${mpi_symlinkdir}'
# Directory of Python
python_dir='${python_dir}'
# Directory of zlib
zlib_dir='${zlib_dir}'

#########
# Files #
#########
# The executable script of the COð˜•CEPT code
concept='${concept}'
# The file containing environment variables
env_file='${env_file}'
# The installer script
installer='${installer}'
# The MPI C compiler
mpicc='${mpicc}'
# The MPI executable
mpiexec='${mpiexec}'
# The file containing paths (this file)
paths_file='${paths_file}'
# The Python interpreter
python='${python}'
" > "${paths_file}"
    # COð˜•CEPT will be tested later
fi



###########################
# Install and patch CLASS #
###########################
if [ "${class_install}" == "True" ] && [ "${class_installed}" == "False" ]; then
    init_install "CLASS"
    # Move the content of the current directory (the files of CLASS,
    # except .gitignore) to the CLASS installation directory.
    mkdir -p "${class_dir}"
    mv ./* "${class_dir}/"
    cd "${class_dir}"
    # Below we will do a lot of patching on the CLASS source code.
    # To aid us, we define the following function.
    patch_class(){
        filename="$1"
        local linenr="$2"
        action="$3"
        belonging="$4"
        new_lines="$5"
        wrap_in_comments="$6"
        # Determine file type ("c" or "python")
        extension="${filename##*.}"
        filetype=""
        if     [ "${extension}" == "c"   ] \
            || [ "${extension}" == "h"   ] \
            || [ "${extension}" == "cpp" ]; then
            filetype="c"
        elif   [ "${extension}" == "py"  ] \
            || [ "${extension}" == "pyx" ] \
            || [ "${extension}" == "pxd" ]; then
            filetype="python"
        fi
        # Add comments around inserted lines
        if [ "${wrap_in_comments}" != "False" ]; then
            if [ "${filetype}" == "c" ]; then
                new_lines=(""                      \
                    "/************************/"   \
                    "/* For use with CONCEPT */"   \
                    "/************************/"   \
                    "${new_lines[@]}"              \
                    "/**************************/" \
                    "/* ^For use with CONCEPT^ */" \
                    "/**************************/" \
                    ""                             \
                )
            elif [ "${filetype}" == "python" ]; then
                new_lines=(""                    \
                    "########################"   \
                    "# For use with CONCEPT #"   \
                    "########################"   \
                    "${new_lines[@]}"            \
                    "##########################" \
                    "# ^For use with CONCEPT^ #" \
                    "##########################" \
                    ""                           \
                )
            fi
        fi
        # Find indentation at linenr
        indentation=""
        if [ "${belonging}" == "below" ]; then
            n_lines=$(wc -l "${filename}" | awk '{print $1}')
            ((n_lines_down = n_lines - linenr + 1))
            content="$(tail -n ${n_lines_down} "${filename}")"
        elif [ "${belonging}" == "above" ]; then
            ((n_lines_down = linenr - 1))
            content="$(head -n ${n_lines_down} "${filename}" | tac)"
        fi
        local IFS=''
        while read -r line; do
            if [ -n "${line// }" ]; then
                line_unindented="$(echo "${line}" | awk '{gsub(/^ +/,"")} {print $0}')"
                ((indentation_size = ${#line} - ${#line_unindented})) || :
                if [ "${filetype}" == "c" ] && [ "${line_unindented:0:1}" == "}" ]; then
                    ((indentation_size += 2))
                fi
                indentation="$(printf "%${indentation_size}s")"
                break
            fi
        done <<< "${content}"
        # Construct string of indented lines from the new_lines array
        new_line_nr=0
        for new_line in "${new_lines[@]}"; do
            if [ -n "${new_line}" ]; then
                indentation_use="${indentation}"
            else
                indentation_use=""
            fi
            if [ ${new_line_nr} -eq 0 ]; then
                new_lines_str="\\${indentation_use}${new_line}"
            else
                new_lines_str="${new_lines_str}\n${indentation_use}${new_line}"
            fi
            ((new_line_nr += 1))
        done
        # Insert the new lines in the file
        if [ "${action}" == "insert" ]; then
            sed -i "${linenr}i${new_lines_str}" "${filename}"
        elif [ "${action}" == "replace" ]; then
            sed -i "${linenr}d" "${filename}"
            sed -i "${linenr}i${new_lines_str}" "${filename}"
        fi
    }
    # Change the values of some preprocessing directives
    # in header files, allowing larger inputs and outputs.
    redefine_class() {
        filename="$1"
        name="$2"
        value="$3"
        sed -i "s/^\( *#define \+${name} \+\)\([^ ]*\)\(.*\)*$/\1${value}\3/" "${filename}"
    }
    redefine_class "${class_dir}/include/common.h"        _MAXTITLESTRINGLENGTH_  1000000  # 10â¶
    redefine_class "${class_dir}/include/parser.h"        _LINE_LENGTH_MAX_         10000  # 10â´
    redefine_class "${class_dir}/include/parser.h"        _ARGUMENT_LENGTH_MAX_     10000  # 10â´
    redefine_class "${class_dir}/include/perturbations.h" _MAX_NUMBER_OF_K_FILES_  100000  # 10âµ
    # As only the (relatively) late-time evolution is needed from CLASS,
    # we hardcode the perturbations output to only be printed here.
    a_min="3e-4"
    pattern=' +a *= *pvecback'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    ((linenr += 1))
    new_lines=(                                  \
        "/* Only return output at late times */" \
        "double a_min = ${a_min};"               \
        "if (a < a_min)"                         \
        "  return _SUCCESS_;"                    \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "below" "${new_lines[@]}"
    # When using the Runge-Kutta evolver, the derivatives are only
    # computed at the beginning of each time step, which is not
    # necessarily precise enough. Here we remove the derivative
    # computation in tools/evolver_rkck.c entirely and place it
    # in the perturb_print_variables function of
    # source/perturbations.c instead. This also ensures that
    # e.g. the ppw struct has been updated correctly
    # when it is time to print the perturbation results.
    pattern='( *x1 *== *x_ini *)'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/tools/evolver_rkck.c" | head -n 1)
    new_lines=(                                          \
        "/* derivs will be called in print_variables */" \
        "if (0 == 1) {  /* (x1 == x_ini) { */"           \
    )
    patch_class "${class_dir}/tools/evolver_rkck.c" ${linenr} "replace" "below" "${new_lines[@]}"
    pattern='double *\\* *dataptr *;'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    ((linenr += 1))
    new_lines=(                                                                  \
        "/**"                                                                    \
        " * Compute perturbation derivatives. This also ensures that the"        \
        " * ppw (and other) structs are up-to-date. This is important"           \
        " * when using the Runge-Kutta evolver, as this is otherwise"            \
        " * not taken care off correctly."                                       \
        " */"                                                                    \
        "class_call("                                                            \
        "  perturb_derivs(tau, y, dy, parameters_and_workspace, error_message)," \
        "  error_message,"                                                       \
        "  error_message);"                                                      \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "below" "${new_lines[@]}"
    # Include ncdm Psi0[q] in perturbation output
    include_ncdm_Psi0="False"
    if [ "${include_ncdm_Psi0}" == "True" ]; then
        pattern=' *char +tmp *\\[ *40 *\\] *;'
        linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
            "${class_dir}/source/perturbations.c" | head -n 1)
        new_lines=(           \
            "char tmp[1024];" \
            "int index_q;"    \
        )
        patch_class "${class_dir}/source/perturbations.c" ${linenr} \
            "replace" "below" "${new_lines[@]}"
        pattern='sprintf *\\( *tmp *, *\"cs2_ncdm\\[%d\\]\" *, *n_ncdm *\\) *;'
        linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
            "${class_dir}/source/perturbations.c" | head -n 1)
        ((linenr += 2))
        new_lines=(                                                                   \
            "/* Include ncdm Psi0[q] in perturbation output */"                       \
            "for (index_q=0; index_q<pba->q_size_ncdm[n_ncdm]; index_q++) {"          \
            "  sprintf(tmp,\"Psi0[%d](%.16f)\",n_ncdm,pba->q_ncdm[n_ncdm][index_q]);" \
            "  class_store_columntitle(ppt->scalar_titles,tmp,_TRUE_);"               \
            "}"                                                                       \
        )
        patch_class "${class_dir}/source/perturbations.c" ${linenr} \
            "insert" "below" "${new_lines[@]}"
        pattern="class_store_double *\\\\( *dataptr *, \
*delta_p_over_delta_rho_ncdm *\\\\[ *n_ncdm *\\\\] *,"
        linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
            "${class_dir}/source/perturbations.c" | head -n 1)
        ((linenr += 1))
        new_lines=(                                                            \
            "/* Include ncdm Psi0[q] in perturbation output */"                \
            "if (ppw->approx[ppw->index_ap_ncdmfa] == (int)ncdmfa_on) {"       \
            "  for (index_q=0; index_q<pba->q_size_ncdm[n_ncdm]; index_q++) {" \
            "    class_store_double(dataptr, 0.0, _TRUE_, storeidx);"          \
            "  }"                                                              \
            "}"                                                                \
            "else {"                                                           \
            "  idx = ppw->pv->index_pt_psi0_ncdm1;"                            \
            "  for (index_q=0; index_q<pba->q_size_ncdm[n_ncdm]; index_q++) {" \
            "    class_store_double(dataptr, y[idx], _TRUE_, storeidx);"       \
            "    /* Jump to next momentum bin */"                              \
            "    idx += (ppw->pv->l_max_ncdm[n_ncdm]+1);"                      \
            "  }"                                                              \
            "}"                                                                \
        )
        patch_class "${class_dir}/source/perturbations.c" ${linenr} \
            "insert" "below" "${new_lines[@]}"
    fi
    # Correctly implement the fld pressure perturbation,
    # both with and without PPF.
    pattern='double *rho_plus_p_theta_fld *;'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/include/perturbations.h" | head -n 1)
    ((linenr += 1))
    new_lines=(                                                                               \
"double delta_p_fld;  /**< pressure perturbation of fluid, very non-trivial in PPF scheme */" \
    )
    patch_class "${class_dir}/include/perturbations.h" ${linenr} \
        "insert" "above" "${new_lines[@]}"
    pattern='/\\* *fluid *contribution *\\*/'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    ((linenr += 1))
    new_lines=(                                                                                  \
        "/**"                                                                                    \
        " * Count up total pressure and conformal time derivative of pressure,"                  \
        " * excluding the fld species. These are used for the PPF formalism of fld."             \
        " */"                                                                                    \
        "double p_tot = 0.;"                                                                     \
        "double p_tot_prime = 0.;"                                                               \
        "if (pba->has_fld == _TRUE_ && pba->use_ppf == _TRUE_) {"                                \
        "  /* Photons */"                                                                        \
        "  p_tot += 1./3.*ppw->pvecback[pba->index_bg_rho_g];"                                   \
        "  p_tot_prime += -3.*a_prime_over_a*(1. + 1./3.)*1./3."                                 \
        "    *ppw->pvecback[pba->index_bg_rho_g];"                                               \
        "  /* Baryons have no pressure */"                                                       \
        "  /* Ultra relativistic species */"                                                     \
        "  if (pba->has_ur == _TRUE_) {"                                                         \
        "    p_tot += 1./3.*ppw->pvecback[pba->index_bg_rho_ur];"                                \
        "    p_tot_prime += -3.*a_prime_over_a*(1. + 1./3.)*1./3."                               \
        "      *ppw->pvecback[pba->index_bg_rho_ur];"                                            \
        "  }"                                                                                    \
        "  /* Cold dark matter has no pressure */"                                               \
        "  /* Non-cold dark matter */"                                                           \
        "  if (pba->has_ncdm == _TRUE_) {"                                                       \
        "    for(n_ncdm = 0; n_ncdm < pba->N_ncdm; n_ncdm++) {"                                  \
        "      p_tot += ppw->pvecback[pba->index_bg_p_ncdm1 + n_ncdm];"                          \
        "      p_tot_prime += -a_prime_over_a*(5.*ppw->pvecback[pba->index_bg_p_ncdm1 + n_ncdm]" \
        "        - ppw->pvecback[pba->index_bg_pseudo_p_ncdm1 + n_ncdm]);"                       \
        "    }"                                                                                  \
        "  }"                                                                                    \
        "  /* Decaying cold dark matter has no pressure */"                                      \
        "  /* Decay radiation */"                                                                \
        "  if (pba->has_dr == _TRUE_) {"                                                         \
        "    p_tot += 1./3.*ppw->pvecback[pba->index_bg_rho_dr];"                                \
        "    p_tot_prime += -3.*a_prime_over_a*(1. + 1./3.)*1./3."                               \
        "      *ppw->pvecback[pba->index_bg_rho_dr]"                                             \
        "      + 1./3.*a*pba->Gamma_dcdm*ppw->pvecback[pba->index_bg_rho_dcdm];"                 \
        "  }"                                                                                    \
        "  /* Importantly, we skip the dark energy fluid */"                                     \
        "  /* Scalar field */"                                                                   \
        "  if (pba->has_scf == _TRUE_) {"                                                        \
        "    p_tot += ppw->pvecback[pba->index_bg_p_scf];"                                       \
        "    p_tot_prime += -a_prime_over_a/(a*a)*ppw->pvecback[pba->index_bg_phi_prime_scf]"    \
        "      *ppw->pvecback[pba->index_bg_phi_prime_scf]"                                      \
        "      - 2./3.*ppw->pvecback[pba->index_bg_dV_scf]"                                      \
        "        *ppw->pvecback[pba->index_bg_phi_prime_scf];"                                   \
        "  }"                                                                                    \
        "  /* Lambda has constant pressure */"                                                   \
        "}"                                                                                      \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} \
        "insert" "above" "${new_lines[@]}"
    for n in $(grep -n 'class_call *( *background_w_fld *(' "${class_dir}/source/perturbations.c" \
        | awk '{print $1}'); do
        n="${n//:}"
        if [ ${n} -gt ${linenr} ]; then
            ((linenr = n + 1))
            new_lines=(                                                 \
                "double w_prime_fld = dw_over_da_fld*a_prime_over_a*a;" \
            )
            patch_class "${class_dir}/source/perturbations.c" ${linenr} \
                "insert" "above" "${new_lines[@]}"
            break
        fi
    done
    for n in $(grep -n 'ppw *-> *rho_plus_p_theta_fld *=' "${class_dir}/source/perturbations.c" \
        | awk '{print $1}'); do
        n="${n//:}"
        if [ ${n} -gt ${linenr} ]; then
            ((linenr = n + 1))
            new_lines=(                                                                          \
                "/* Pressure perturbation of fld without PPF */"                                 \
                "double ca2_fld = w_fld - w_prime_fld/(3.*a_prime_over_a*(1. + w_fld));"         \
                "ppw->delta_p_fld = pba->cs2_fld*ppw->delta_rho_fld"                             \
                "  + (pba->cs2_fld - ca2_fld)*(3.*a_prime_over_a*ppw->rho_plus_p_theta_fld/k2);" \
            )
            patch_class "${class_dir}/source/perturbations.c" ${linenr} \
                "insert" "above" "${new_lines[@]}"
            break
        fi
    done
    pattern='s2sq *= ppw *->'
    linenr_1=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    ((linenr_1 += 1))
    pattern='ppw *-> *S_fld *='
    linenr_2=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    ((linenr_2 -= 1))
    sed -i "${linenr_1},${linenr_2}d" "${class_dir}/source/perturbations.c"
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    new_lines=(                                                                                  \
        "double alpha_prime, X, Y, Z, X_prime, Y_prime, Z_prime;"                                \
        "double rho_plus_p_theta_fld_prime, metric_euler;"                                       \
        "double rho_t, rho_t_prime, p_t, p_t_prime, rho_fld, rho_fld_prime, p_fld, p_fld_prime;" \
        "double H, H_prime;"                                                                     \
        "double theta_t,theta_t_prime, S, S_prime;"                                              \
        "if (ppt->gauge == synchronous) {"                                                       \
        "  alpha = (y[ppw->pv->index_pt_eta] + 1.5*a2/k2/s2sq*(ppw->delta_rho"                   \
        "    + 3.*a_prime_over_a/k2*ppw->rho_plus_p_theta)"                                      \
        "    - y[ppw->pv->index_pt_Gamma_fld])/a_prime_over_a;"                                  \
        "  alpha_prime = -2.*a_prime_over_a*alpha + y[ppw->pv->index_pt_eta]"                    \
        "    - 4.5*(a2/k2)*ppw->rho_plus_p_shear;"                                               \
        "  metric_euler = 0.;"                                                                   \
        "} else {"                                                                               \
        "  alpha = 0.;"                                                                          \
        "  alpha_prime = 0.;"                                                                    \
        "  metric_euler = k2*y[ppw->pv->index_pt_phi] - 4.5*a2*ppw->rho_plus_p_shear;"           \
        "}"                                                                                      \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} \
        "insert" "above" "${new_lines[@]}"
    pattern='ppw->delta_rho_fld *='
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | tail -n 1)
    ((linenr += 1))
    new_lines=(                                                                                 \
        "rho_t = rho_plus_p_tot - p_tot;"                                                       \
        "p_t = p_tot;"                                                                          \
        "rho_t_prime = -3.*a_prime_over_a*(rho_t + p_t);"                                       \
        "p_t_prime = p_tot_prime;"                                                              \
        "rho_fld = ppw->pvecback[pba->index_bg_rho_fld];"                                       \
        "p_fld = w_fld*rho_fld;"                                                                \
        "rho_fld_prime = -3.*a_prime_over_a*(rho_fld + p_fld);"                                 \
        "p_fld_prime = w_prime_fld*rho_fld - 3.*a_prime_over_a*(1. + w_fld)*p_fld;"             \
        ""                                                                                      \
        "H = ppw->pvecback[pba->index_bg_H];"                                                   \
        "H_prime = ppw->pvecback[pba->index_bg_H_prime];"                                       \
        "X = c_gamma_k_H_square;"                                                               \
        "X_prime = -2.*X*(a_prime_over_a + H_prime/H);"                                         \
        "Y = 4.5*a2/k2/s2sq*(rho_t + p_t);"                                                     \
        "Y_prime = Y*(2.*a_prime_over_a + (rho_t_prime + p_t_prime)/(rho_t + p_t));"            \
        "Z = 2./3.*k2*H/a;"                                                                     \
        "Z_prime = Z*(H_prime/H - a_prime_over_a);"                                             \
        ""                                                                                      \
        "theta_t = ppw->rho_plus_p_theta/rho_plus_p_tot;"                                       \
        "theta_t_prime = -a_prime_over_a*theta_t + (-p_t_prime*theta_t + k2*ppw->delta_p"       \
        "  - k2*ppw->rho_plus_p_shear)/rho_plus_p_tot+metric_euler;"                            \
        ""                                                                                      \
        "S = ppw->S_fld;"                                                                       \
        "S_prime = -Z_prime/Z*S + 1./Z*(rho_fld_prime + p_fld_prime)*(theta_t + k2*alpha)"      \
        "  + 1./Z*(rho_fld + p_fld)*(theta_t_prime + k2*alpha_prime);"                          \
        "rho_plus_p_theta_fld_prime = Z_prime*(S - 1./(1. + Y)*(S/(1. + 1./X)"                  \
        "  + y[ppw->pv->index_pt_Gamma_fld]*X))"                                                \
        "  + Z*(S_prime + Y_prime/(1. + Y*Y + 2.*Y)*(S/(1. + 1./X)"                             \
        "    + y[ppw->pv->index_pt_Gamma_fld]*X)"                                               \
        "    - 1./(1. + Y)*(S_prime/(1. + 1./X) + S*X_prime/(1. + X*X + 2.*X)"                  \
        "      + ppw->Gamma_prime_fld*X + y[ppw->pv->index_pt_Gamma_fld]*X_prime))"             \
        "  - k2*alpha_prime*(rho_fld + p_fld) - k2*alpha*(rho_fld_prime + p_fld_prime);"        \
        ""                                                                                      \
        "ppw->delta_p_fld = (rho_plus_p_theta_fld_prime"                                        \
        "  + 4.*a_prime_over_a*ppw->rho_plus_p_theta_fld - (rho_fld + p_fld)*metric_euler)/k2;" \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} \
        "insert" "above" "${new_lines[@]}"
    pattern='ppw *-> *delta_p *\\+= *pba *-> *cs2_fld *\\* *ppw *-> *delta_rho_fld *;'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    new_lines=(                             \
        "ppw->delta_p += ppw->delta_p_fld;" \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} \
        "replace" "above" "${new_lines[@]}"
    # For the PPF scheme, include a maximum value for (c_Î“*k*a/H)Â² above
    # which Î“ = Î“' = 0, for the sake of numerical stability. In CAMB
    # such a maximum value is present as well and is set to 30. I have
    # found that a value of 10Â³ or even 10â´ ensures stability as well,
    # while perturbing the fld Î´_fld, Î¸_fld and Î´p_fld solutions
    # significantly less. Instead of a discontinuities cutoff as
    # in CAMB, we implement a smooth transition to zero, as defects in
    # Î´_fld, Î¸_fld and Î´p_fld have been observed otherwise.
    pattern='c_gamma_k_H_square *='
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    sed -i "${linenr}d" "${class_dir}/source/perturbations.c"
    pattern='s2sq *= ppw *->'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    ((linenr += 1))
    new_lines=(                                                                                   \
        "/**"                                                                                     \
        " * The computation of Gamma_fld and Gamma_prime_fld becomes unstable"                    \
        " * at large c_Gamma*k/H. To stabilise the system we set these to zero"                   \
        " * at some large c_Gamma*k/(aH)."                                                        \
        " * As to not introduce discontinuities, we have a smooth transition"                     \
        " * phase between the untouched values and completely nullified values."                  \
        " * This transition is given the shape of an error function in"                           \
        " * log(c_Gamma*k/(aH)) space. The parameters c_gamma_k_H_square_max_{0|1}"               \
        " * specify the borders of the transition."                                               \
        " * Here we nullify/shrink Gamma_fld only."                                               \
        " */"                                                                                     \
        "double Gamma_fld, Gamma_weight, Gamma_weight_steepness;"                                 \
        "double c_gamma_k_H_square_max_0, c_gamma_k_H_square_max_1;"                              \
        "c_gamma_k_H_square_max_0 = 1e+3;"                                                        \
        "c_gamma_k_H_square_max_1 = 1e+4;"                                                        \
        "c_gamma_k_H_square = pow(pba->c_gamma_over_c_fld*k/a_prime_over_a, 2)*pba->cs2_fld;"     \
        "if (c_gamma_k_H_square > c_gamma_k_H_square_max_1){"                                     \
        "    Gamma_fld = 0.;"                                                                     \
        "} else {"                                                                                \
        "  Gamma_fld = y[ppw->pv->index_pt_Gamma_fld];"                                           \
        "  if (c_gamma_k_H_square > c_gamma_k_H_square_max_0){"                                   \
        "    Gamma_weight_steepness = 5.; /* 5 results in double precision perfect transition */" \
        "    Gamma_weight = 0.5*(erf(Gamma_weight_steepness*("                                    \
        "      0.5*(log(c_gamma_k_H_square_max_0) + log(c_gamma_k_H_square_max_1))"               \
        "      - log(c_gamma_k_H_square)"                                                         \
        "    )) + 1.);"                                                                           \
        "    Gamma_fld *= Gamma_weight;"                                                          \
        "  }"                                                                                     \
        "}"                                                                                       \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} \
        "insert" "above" "${new_lines[@]}"
    pattern='double *alpha_prime *, *X *, *Y *, *Z'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    replacements_todo=7
    replacements=0
    for n in $(grep -n 'y *\[ *ppw *-> *pv *-> *index_pt_Gamma_fld *\]' \
        "${class_dir}/source/perturbations.c" | awk '{print $1}'); do
        n="${n//:}"
        if [ ${n} -ge ${linenr} ]; then
            sed -i "${n}s/y *\[ *ppw *-> *pv *-> *index_pt_Gamma_fld *\]/Gamma_fld/" \
                "${class_dir}/source/perturbations.c"
            ((replacements += 1))
            if [ ${replacements} -eq ${replacements_todo} ]; then
                break
            fi
        fi
    done
    pattern='ppw->Gamma_prime_fld *='
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    new_lines=(                                                                         \
        "/* Nullify/shrink Gamma_prime_fld as done for Gamma_fld above */"              \
        "if (c_gamma_k_H_square > c_gamma_k_H_square_max_1){"                           \
        "    ppw->Gamma_prime_fld = 0.;"                                                \
        "} else {"                                                                      \
        "  ppw->Gamma_prime_fld = a_prime_over_a*(ppw->S_fld/(1. + c_gamma_k_H_square)" \
        "    - (1. + c_gamma_k_H_square)*Gamma_fld);"                                   \
        "  if (c_gamma_k_H_square > c_gamma_k_H_square_max_0){"                         \
        "      ppw->Gamma_prime_fld *= Gamma_weight;"                                   \
        "  }"                                                                           \
        "}"                                                                             \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} \
        "replace" "above" "${new_lines[@]}"
    # Include fld in perturbation output
    new_class_perturbation_linenr(){
        if [ "${1}" == "perturb_prepare_output" ]; then
            pattern='ppt *-> *number_of_scalar_titles *='
            linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
                "${class_dir}/source/perturbations.c" | head -n 1)
            ((linenr -= 1))
        elif [ "${1}" == "perturb_print_variables" ]; then
            pattern="class_store_double *\\\\( *dataptr *, *theta_scf *, *pba *-> *has_scf *, \
*storeidx *\\\\)*;"
            linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
                "${class_dir}/source/perturbations.c" | head -n 1)
            n_lines_total=$(wc -l "${class_dir}/source/perturbations.c" | awk '{print $1}')
            ((n_lines_down = n_lines_total - linenr))
            local IFS=''
            while read -r line; do
                ((linenr += 1))
                if [[ "${line}" == "  }" ]]; then
                    break
                fi
            done <<< "$(tail -n ${n_lines_down} "${class_dir}/source/perturbations.c")"
        fi
        echo ${linenr}
    }
    linenr=$(new_class_perturbation_linenr "perturb_prepare_output")
    new_lines=(                                                                       \
        "/* Include fld in perturbation output */"                                    \
        "class_store_columntitle(ppt->scalar_titles, \"delta_fld\", pba->has_fld);"   \
        "class_store_columntitle(ppt->scalar_titles, \"theta_fld\", pba->has_fld);"   \
        "/**"                                                                         \
        " * We choose to store cs2_fld = delta_p_fld/delta_rho_fld rather than"       \
        " * simply delta_p_fld itself, as is done for massive neutrinos."             \
        " */"                                                                         \
        "class_store_columntitle(ppt->scalar_titles, \"cs2_fld\", pba->has_fld);"     \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "below" "${new_lines[@]}"
    linenr=$(new_class_perturbation_linenr "perturb_print_variables")
    new_lines=(                                                                             \
        "/* Include fld in perturbation output */"                                          \
        "double w_fld, dw_over_da_fld, integral_fld, theta_fld;"                            \
        "if (pba->has_fld) {"                                                               \
        "  class_call(background_w_fld(pba, a, &w_fld, &dw_over_da_fld, &integral_fld),"    \
        "    pba->error_message, ppt->error_message);"                                      \
        "  class_store_double(dataptr, ppw->delta_rho_fld/pvecback[pba->index_bg_rho_fld]," \
        "    pba->has_fld, storeidx);"                                                      \
        "  /* For w_fld = -1 (Lambda), we have theta = 0 */"                                \
        "  if (w_fld == -1.) {"                                                             \
        "    theta_fld = 0.;"                                                               \
        "  }"                                                                               \
        "  else {"                                                                          \
        "    theta_fld = ppw->rho_plus_p_theta_fld/"                                        \
        "      ((1. + w_fld)*pvecback[pba->index_bg_rho_fld]);"                             \
        "  }"                                                                               \
        "  class_store_double(dataptr, theta_fld, pba->has_fld, storeidx);"                 \
        "  /**"                                                                             \
        "   * We choose to store cs2_fld = delta_p_fld/delta_rho_fld rather than"           \
        "   * simply delta_p_fld itself, as is done for massive neutrinos."                 \
        "   *"                                                                              \
        "   */"                                                                             \
        "  class_store_double(dataptr,"                                                     \
        "    ppw->delta_p_fld/ppw->delta_rho_fld, pba->has_fld, storeidx);"                 \
        "}"                                                                                 \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "below" "${new_lines[@]}"
    # Include dcdm in the growth factor D(a)
    pattern='rho_M * \\+='
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/background.c" | head -n 1)
    ((linenr += 1))
    new_lines=(                                        \
        "/* Include dcdm in growth factor */"          \
        "if (pba->has_dcdm == _TRUE_)"                 \
        "  rho_M += pvecback[pba->index_bg_rho_dcdm];" \
    )
    patch_class "${class_dir}/source/background.c" ${linenr} \
        "insert" "below" "${new_lines[@]}"
    # Include theta_tot in perturbation output
    linenr=$(new_class_perturbation_linenr "perturb_prepare_output")
    new_lines=(                                                               \
        "/* Include theta_tot in perturbation output */"                      \
        "class_store_columntitle(ppt->scalar_titles, \"theta_tot\", _TRUE_);" \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "below" "${new_lines[@]}"
    linenr=$(new_class_perturbation_linenr "perturb_print_variables")
    new_lines=(                                                                                  \
        "/* Include theta_tot in perturbation output */"                                         \
        "double rho_plus_p_tot = -2./3.*pvecback[pba->index_bg_H_prime]/a + 2./3.*pba->K/(a*a);" \
        "double theta_tot = ppw->rho_plus_p_theta/rho_plus_p_tot;"                               \
        "class_store_double(dataptr, theta_tot, _TRUE_, storeidx);"                              \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "below" "${new_lines[@]}"
    # Include h_prime in perturbation output
    linenr=$(new_class_perturbation_linenr "perturb_prepare_output")
    new_lines=(                                                                                \
        "/* Include h_prime in perturbation output */"                                         \
        "class_store_columntitle(ppt->scalar_titles, \"h_prime\", ppt->gauge == synchronous);" \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "below" "${new_lines[@]}"
    linenr=$(new_class_perturbation_linenr "perturb_print_variables")
    new_lines=(                                                          \
        "/* Include h_prime in perturbation output */"                   \
        "class_store_double(dataptr, pvecmetric[ppw->index_mt_h_prime]," \
        "  ppt->gauge == synchronous, storeidx);"                        \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "below" "${new_lines[@]}"
    # Include H_T_prime in perturbation output
    linenr=$(new_class_perturbation_linenr "perturb_prepare_output")
    new_lines=(                                                               \
        "/* Include H_T_prime (in N-body gauge) in perturbation output */"    \
        "class_store_columntitle(ppt->scalar_titles, \"H_T_prime\", _TRUE_);" \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "below" "${new_lines[@]}"
    linenr=$(new_class_perturbation_linenr "perturb_print_variables")
    new_lines=(                                                                             \
        "/**"                                                                               \
        " * Include H_T_prime (in N-body gauge) in perturbation output."                    \
        " * Here we make use of rho_plus_p_tot defined earlier."                            \
        " */"                                                                               \
        "double p_tot_prime = 0.0;"                                                         \
        "/* Photons */"                                                                     \
        " p_tot_prime += -3.*a*H*(1. + 1./3.)*1./3.*pvecback[pba->index_bg_rho_g];"         \
        "/* Baryons have no pressure */"                                                    \
        "/* Ultra relativistic species */"                                                  \
        "if (pba->has_ur == _TRUE_)"                                                        \
        "  p_tot_prime += -3.*a*H*(1. + 1./3.)*1./3.*pvecback[pba->index_bg_rho_ur];"       \
        "/* Cold dark matter has no pressure */"                                            \
        "/* Non-cold dark matter */"                                                        \
        "if (pba->has_ncdm == _TRUE_) {"                                                    \
        "  for(n_ncdm=0; n_ncdm < pba->N_ncdm; n_ncdm++)"                                   \
        "    p_tot_prime += -a*H*(5.*pvecback[pba->index_bg_p_ncdm1+n_ncdm]"                \
        "    - pvecback[pba->index_bg_pseudo_p_ncdm1+n_ncdm]);"                             \
        "}"                                                                                 \
        "/* Decaying cold dark matter has no pressure */"                                   \
        "/* Decay radiation */"                                                             \
        "if (pba->has_dr == _TRUE_)"                                                        \
        "  p_tot_prime += -3.*a*H*(1. + 1./3.)*1./3.*pvecback[pba->index_bg_rho_dr]"        \
        "    + 1./3.*a*pba->Gamma_dcdm*pvecback[pba->index_bg_rho_dcdm];"                   \
        "/* Dark energy fluid */"                                                           \
        "if (pba->has_fld == _TRUE_) {"                                                     \
        "  p_tot_prime += a*H*pvecback[pba->index_bg_rho_fld]"                              \
        "    *(a*dw_over_da_fld - 3.*w_fld*(1. + w_fld));"                                  \
        "}"                                                                                 \
        "/* Scalar field */"                                                                \
        "if (pba->has_scf == _TRUE_) {"                                                     \
        "  p_tot_prime += -H/a*pvecback[pba->index_bg_phi_prime_scf]"                       \
        "    *pvecback[pba->index_bg_phi_prime_scf]"                                        \
        "    - 2./3.*pvecback[pba->index_bg_dV_scf]*pvecback[pba->index_bg_phi_prime_scf];" \
        "}"                                                                                 \
        "/* Lambda has constant pressure */"                                                \
        "double H_T_prime = 3.*a*H/rho_plus_p_tot*("                                        \
        "  - ppw->delta_p"                                                                  \
        "  + p_tot_prime*theta_tot/(k*k)"                                                   \
        "  + ppw->rho_plus_p_shear);"                                                       \
        "class_store_double(dataptr, H_T_prime, _TRUE_, storeidx);"                         \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "below" "${new_lines[@]}"
    # Do not convert synchronous variables to Newtonian gauge
    pattern='converting *synchronous *variables *to *newtonian *ones'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    ((linenr += 1))
    new_lines=(                                              \
        "/* Do not convert to Newtonian gauge */"            \
        "if (0 == 1) {  /* (ppt->gauge == synchronous) { */" \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "replace" "below" "${new_lines[@]}"
    # Add integers 'node', 'num_threads' and 'indentation' to the
    # classy.Class initializer as optional arguments and store them in
    # the 'background' struct. Here 'node' and 'indentation' will be
    # used to make CLASS print out correctly indented (with regard to
    # COð˜•CEPT) status updates during perturbation computations, when the
    # perturbations_verbose parameter is negative. The 'num_threads'
    # integer will hold the number of MPI processes on the local node,
    # which signals the number of OpenMP threads to use.
    linenr_1="$(grep -n 'struct background' "${class_dir}/include/background.h" | head -n 1)"
    linenr_1="${linenr_1%%:*}"
    i=0
    while :; do
        ((i += 1))
        linenr_2="$(grep -n '};' "${class_dir}/include/background.h" | head -n ${i} | tail -n 1)"
        linenr_2="${linenr_2%%:*}"
        if [ ${linenr_2} -gt ${linenr_1} ]; then
            break
        fi
    done
    new_lines=(                                                \
        "/**"                                                  \
        " * Used to set number of OpenMP threads and to print" \
        " * status updates during perturbation computations."  \
        " */"                                                  \
        "int node, num_threads, indentation;"                  \
    )
    patch_class "${class_dir}/include/background.h" ${linenr_2} "insert" "below" "${new_lines[@]}"
    linenr="$(grep -n "__cinit__" "${class_dir}/python/classy.pyx")"
    linenr="${linenr%%:*}"
    sed -i "${linenr}s/.*/    def __cinit__(self, \
        default=False, node=0, num_threads=1, indentation=0): \
        # Changed for use with CONCEPT/" "${class_dir}/python/classy.pyx"
    ((linenr += 1))
    new_lines=(                                  \
        "self.ba.node = <int>node"               \
        "self.ba.num_threads = <int>num_threads" \
        "self.ba.indentation = <int>indentation" \
    )
    patch_class "${class_dir}/python/classy.pyx" ${linenr} "insert" "below" "${new_lines[@]}"
    linenr_1="$(grep -n 'cdef struct background:' "${class_dir}/python/cclassy.pxd")"
    linenr_1="${linenr_1%%:*}"
    i=0
    while :; do
        ((i += 1))
        linenr_2="$(grep -n 'cdef struct' "${class_dir}/python/cclassy.pxd" \
            | head -n ${i} | tail -n 1)"
        linenr_2="${linenr_2%%:*}"
        if [ ${linenr_2} -eq ${linenr_1} ]; then
            ((i += 1))
            linenr_2="$(grep -n 'cdef struct' "${class_dir}/python/cclassy.pxd" \
                | head -n ${i} | tail -n 1)"
            linenr_2="${linenr_2%%:*}"
            while :; do
                ((linenr_2 -= 1))
                line="$(sed "${linenr_2}!d" "${class_dir}/python/cclassy.pxd")"
                if [ -n "${line}" ]; then
                    break
                fi
            done
            ((linenr_2 += 1))
            break
        fi
    done
    new_lines=(           \
        "int node"        \
        "int num_threads" \
        "int indentation" \
    )
    patch_class "${class_dir}/python/cclassy.pxd" ${linenr_2} "insert" "above" "${new_lines[@]}"
    linenr="$(grep -n 'for (index_k = ppt->k_size\[index_md\]-1; index_k >=0; index_k--)' \
        "${class_dir}/source/perturbations.c")"
    linenr="${linenr%%:*}"
    ((linenr += 1))
    new_lines=(                                                                   \
        "if ((abort == _FALSE_) && (ppt->perturbations_verbose < 0)) {"           \
        "  printf("                                                               \
        "    \"%*sNode %d, thread %d: Evolving mode k = %.3e/Mpc (%d/%d)\\\\n\"," \
        "    pba->indentation, \"\","                                             \
        "    pba->node,"                                                          \
        "    thread,"                                                             \
        "    ppt->k[index_md][index_k],"                                          \
        "    index_k+1,"                                                          \
        "    ppt->k_size[index_md]"                                               \
        "  );"                                                                    \
        "  fflush(stdout);"                                                       \
        "}"                                                                       \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "below" "${new_lines[@]}"
    pattern='#pragma *omp *parallel'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" "${class_dir}/source/perturbations.c" \
        | head -n 1)
    new_lines=(                                                                  \
        "if (pba->num_threads != -1) {"                                          \
        "  /**"                                                                  \
        "   * Explicitly set the number of OpenMP threads."                      \
        "   * Note that the value of OMP_NUM_THREADS is now completely ignored." \
        "   */"                                                                  \
        "  omp_set_num_threads(pba->num_threads);"                               \
        "}"                                                                      \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "above" "${new_lines[@]}"
    # If COð˜•CEPT is installed we now switch out the values of various
    # constants in the CLASS source code so that they match the values
    # used in COð˜•CEPT.
    if [ -n "${concept}" ] && [ -f "${concept}" ]; then
        echo "Patching physical constants in CLASS to match values used in COð˜•CEPT"
        current_dir="$(pwd)"
        if [ -n "${concept_dir}" ] && [ -d "${concept_dir}" ]; then
            cd "${concept_dir}"
        fi
        # Test whether COð˜•CEPT is able to run
        concept_works="False"
        result="$("${concept}" -m "print(2+2)" --pure-python 2>/dev/null | tail -n 1)"
        if [ "${result}" == "4" ]; then
            concept_commons_print() {
                expression="$1"
                "${concept}" -m "from commons import *; print(${expression})" --pure-python \
                    2>/dev/null | tail -n 1
            }
            result="$(concept_commons_print "Ï€")"
            if [[ "${result}" == "3.14"* ]]; then
                concept_works="True"
            fi
        fi
        if [ "${concept_works}" == "True" ]; then
            class_constants=(                                            \
                _Mpc_over_m_   "units.Mpc/units.m"                       \
                _Gyr_over_Mpc_ "light_speed*units.Gyr/units.Mpc"         \
                _c_            "light_speed*units.s/units.m"             \
                _G_            "G_Newton*units.kg*units.s**2/units.m**3" \
                _eV_           "units.eV/units.J"                        \
                _k_B_          "NotImplemented"                          \
                _h_P_          "2*Ï€*Ä§/(units.J*units.s)"                 \
            )
            for ((name_index=0; name_index<${#class_constants[@]}; name_index+=2)); do
                ((expr_index = name_index + 1))
                name=${class_constants[${name_index}]}
                expr="${class_constants[${expr_index}]}"
                if [ "${expr}" == "NotImplemented" ]; then
                    # This CLASS constant has no equivalent in COð˜•CEPT
                    continue
                fi
                value="$(concept_commons_print "${expr}")"
                redefine_class "${class_dir}/include/background.h" ${name} "${value}"
            done
        else
            # COð˜•CEPT was not able to run.
            # Print out error but do not exit.
            error "Unable to run COð˜•CEPT during CLASS installation"
        fi
        cd "${current_dir}"
    fi
    # Build CLASS, including the Python wrapper classy. We explicitly
    # specify Python 3 as the language level and replace -O4 with -O3
    # (which are equivalent on compilers that recognize -O4).
    # We try with and without the -ffast-math option, try different
    # commpilers and various flags for correctly linking to OpenMP.
    # The classy Python wrapper is hardcoded to use gcc in setup.py to
    # test for existence of the mvec library, as well as to get the
    # compiler library directory.
    sed -i '1s/^/# cython: language_level=3\n/' "python/classy.pyx"
    sed -i 's/-O4/-O3/' "Makefile"
    cp "Makefile" "Makefile_ori"
    cp "python/setup.py" "python/setup.py_ori"
    install_success="False"
    for lgomp_in_extra_link_args in "" "-gomp"; do
        for hardcoded_gcc in "False" "True"; do
            for compiler in "${compiler_possibilities[@]}"; do
                for OMPFLAG in "-fopenmp" "-openmp" "-qopenmp"; do
                    for fast_math in "True" "False"; do
                        reset_environment
                        export LD_LIBRARY_PATH="${blas_dir}/lib:${LD_LIBRARY_PATH}"
                        eval "use_${compiler}_compilers" || continue
                        if [ "${hardcoded_gcc}" == "False" ] && [ -z "${CC}" ]; then
                            continue
                        fi
                        printf "
Attempting to install CLASS with lgomp_in_extra_link_args=${lgomp_in_extra_link_args}, \
hardcoded_gcc=${hardcoded_gcc}, compiler=${compiler}, \
OMPFLAG=${OMPFLAG}, fast_math=${fast_math}\n\n"
                        cp "Makefile_ori" "Makefile"
                        cp "python/setup.py_ori" "python/setup.py"
                        make clean || :
                        if [ "${fast_math}" == "False" ]; then
                            sed -i '0,/-ffast-math/s/-ffast-math/#-ffast-math/' "Makefile"
                        fi
                        if [ -n "${CC}" ]; then
                            sed -i "s/CC * =/CC = ${CC//\//\\/}  #/" "Makefile"
                        fi
                        if [ -n "${OMPFLAG}" ]; then
                            sed -i "s/OMPFLAG *=/OMPFLAG = ${OMPFLAG}  #/" "Makefile"
                        fi
                        sed -i "s/extra_link_args *=/extra_link_args=\
'${lgomp_in_extra_link_args} ${OMPFLAG}'.split(),  #/" "python/setup.py"
                        if [ "${hardcoded_gcc}" == "False" ]; then
                            # Remove hardcoding of gcc
                            linenr_1=$(awk "\$0 ~ \"gcc\" {print NR}" "python/setup.py" \
                                | head -n 1)
                            linenr_2=$(awk "\$0 ~ \"mvec\" {print NR}" "python/setup.py" \
                                | tail -n 1)
                            sed -i "${linenr_1},${linenr_2}d" "python/setup.py"
                            sed -i "${linenr_1}iliblist = ['class']" "python/setup.py"
                            sed -i 's/GCCPATH//g' "python/setup.py"
                            # Check for the mvec library
                            mkdir -p "tmp_mvec"
                            cd "tmp_mvec"
                            echo "int main(void){ return 0; }" > test.c
                            mvec_warning="$("${CC}" -lmvec test.c 2>&1 | grep mvec || :)"
                            cd ..
                            rm -rf "tmp_mvec" || :
                            if [ -z "${mvec_warning}" ]; then
                                # mvec found.
                                # Add the mvec and m library.
                                ((linenr = linenr_1 + 1))
                                sed -i "${linenr}iliblist += ['mvec', 'm']" "python/setup.py"
                            fi
                        fi
                        PYTHON="${python}" make ${make_jobs} 2>&1 || continue
                        "${python}" -c "import classy; classy.Class().compute()" || continue
                        install_success="True"
                        break
                    done
                    if [ "${install_success}" == "True" ]; then
                        break
                    fi
                done
                if [ "${install_success}" == "True" ]; then
                    break
                fi
            done
            if [ "${install_success}" == "True" ]; then
                break
            fi
        done
        if [ "${install_success}" == "True" ]; then
            break
        fi
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install CLASS"
        exit 1
    fi
    reset_environment
    # Test CLASS
    if [ "${do_tests}" == "True" ]; then
        export LD_LIBRARY_PATH="${blas_dir}/lib:${LD_LIBRARY_PATH}"
        # We do not use the builtin test_class.py, as this require tens
        # of gigabytes and uses the Nose and parameterized Python
        # packages. Instead we perform a simple test of our own,
        # which only does a background computation.
        if ! "${python}" -c "
import sys
from classy import Class
cosmo = Class()
cosmo.compute()
sys.exit(int(cosmo.get_background()['proper time [Gyr]'][-1]) != 13)
"; then
            class_test_success="False"
        fi
        if [ "${class_test_success}" == "False" ]; then
            echo "CLASS did not pass a simple background computation test" \
               > "${class_test_log}"
        fi
    fi
    reset_environment
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/class" || :
    install_notice "CLASS" "${class_dir}"
fi



#####################################################
# Install GADGET, used for testing the COð˜•CEPT code #
#####################################################
# FFTW 2.x (GADGET2 is incompatible with FFTW 3.x)
if [ "${fftw_for_gadget_install}" == "True" ] \
    && [ "${fftw_for_gadget_installed}" == "False" ]; then
    install_success="False"
    fftw_for_gadget_test_success_backup="${fftw_for_gadget_test_success}"
    enable_mpi=""
    if [ -n "${mpi_dir}" ]; then
        enable_mpi="--enable-mpi"
    fi
    for extra_optimizations in "True" "False"; do
        for enable_shared in "--enable-shared" ""; do
            for shared in "" "-shared"; do
                if [ -z "${enable_shared}" ] && [ -n "${shared}" ]; then
                    continue
                fi
                for with_pic in "" "--with-pic"; do
                    for PIC in "-fPIC" ""; do
                        for extra_MPILIBS in "" "-lmpi" "-lmpich"; do
                            if [ -z "${enable_mpi}" ] && [ -n "${extra_MPILIBS}" ]; then
                                continue
                            fi
                            reset_environment
                            init_install "FFTW for GADGET" \
                                "extra_optimizations=${extra_optimizations}, \
enable_shared=${enable_shared}, shared=${shared}, with_pic=${with_pic}, \
PIC=${PIC}, extra_MPILIBS=${extra_MPILIBS}"
                            export CFLAGS="-O3 ${PIC} ${CFLAGS}"
                            export CXXFLAGS="-O3 ${PIC} ${CXXFLAGS}"
                            export LDFLAGS="${LDFLAGS} -Wl,-O3 ${shared} ${PIC}"
                            if [ -n "${enable_mpi}" ]; then
                                use_specified_mpi_compilers
                                export MPICC="${CC}"
                                export MPILIBS="${extra_MPILIBS} ${MPILIBS}"
                            fi
                            if [ "${extra_optimizations}" == "True" ]; then
                                export CFLAGS="${CFLAGS} -march=native"
                                info="$("${CC}" --version | head -n 1 || :)"
                                if echo "${info}" | grep -i icc >/dev/null; then
                                    # icc
                                    export CFLAGS="${CFLAGS} \
-fp-model fast=2 -inline-factor=200"
                                else
                                    # Assume gcc
                                    export CFLAGS="${CFLAGS} \
-ffast-math --param max-inline-insns-auto=100 --param early-inlining-insns=200"
                                fi
                            fi
                            # Intel compilers may link against the NUMA library, which should be
                            # placed in /usr/lib64. Add this directory to the LDFLAGS.
                            # Both libnuma.so and libnuma.so.1 should exist. To be sure,
                            # we create symlinks to these in a new directory and add this
                            # directory to LDFLAGS as well.
                            if [ -d "/usr/lib64" ]; then
                                export LDFLAGS="${LDFLAGS} -L/usr/lib64"
                            fi
                            numa_symlink_dir="${fftw_for_gadget_dir}/numa_symlinks"
                            rm -rf "${numa_symlink_dir}" || :
                            mkdir -p "${numa_symlink_dir}" || :
                            if     [   -f "/usr/lib64/libnuma.so"   ] \
                                && [ ! -f "/usr/lib64/libnuma.so.1" ]; then
                                ln -s "/usr/lib64/libnuma.so" "${numa_symlink_dir}/libnuma.so.1" \
                                    >/dev/null 2>&1 || :
                            fi
                            if     [   -f "/usr/lib64/libnuma.so.1" ] \
                                && [ ! -f "/usr/lib64/libnuma.so"   ]; then
                                ln -s "/usr/lib64/libnuma.so.1" "${numa_symlink_dir}/libnuma.so" \
                                    >/dev/null 2>&1 || :
                            fi
                            export LDFLAGS="${LDFLAGS} -L${numa_symlink_dir}"
                            # Double-precision
                            ./configure ${enable_shared}     \
                                        ${enable_mpi}        \
                                        --enable-type-prefix \
                                        --disable-fortran    \
                                        ${with_pic}          \
                                        --prefix="${fftw_for_gadget_dir}" 2>&1 || continue
                            make 2>&1 || continue
                            fftw_for_gadget_test_max_time=600
                            if [ "${extra_optimizations}" == "True" ]; then
                                exit_code_filename="${top_dir}/tmp/.exit_code_fftw_for_gadget"
                                (make check 2>&1 | tee "test_log";                    \
                                    echo "${PIPESTATUS[0]}" > "${exit_code_filename}" \
                                ) & fftw_for_gadget_test_pid=$!
                                soothe ${fftw_for_gadget_test_pid} ${fftw_for_gadget_test_max_time}
                                sleep 1
                                kill -9 ${fftw_for_gadget_test_pid} >/dev/null 2>&1 || :
                                wait    ${fftw_for_gadget_test_pid} >/dev/null 2>&1 || :
                                exit_code="$(wait ${fftw_for_gadget_test_pid} >/dev/null 2>&1 \
                                    || echo $?)"
                                if [ -n "${exit_code}" ]; then
                                    rm -f "${exit_code_filename}" "test_log" || :
                                    continue
                                else
                                    exit_code="$(cat "${exit_code_filename}" 2>/dev/null || :)"
                                    if [ "${exit_code}" != "0" ]; then
                                        rm -f "${exit_code_filename}" "test_log" || :
                                        continue
                                    fi
                                fi
                            fi
                            if [ "${do_tests}" == "True" ]; then
                                fftw_for_gadget_test_success="${fftw_for_gadget_test_success_backup}"
                                exit_code_filename="${top_dir}/tmp/.exit_code_fftw_for_gadget"
                                (make check 2>&1 | tee "test_log";                    \
                                    echo "${PIPESTATUS[0]}" > "${exit_code_filename}" \
                                ) & fftw_for_gadget_test_pid=$!
                                soothe ${fftw_for_gadget_test_pid} ${fftw_for_gadget_test_max_time}
                                sleep 1
                                kill -9 ${fftw_for_gadget_test_pid} >/dev/null 2>&1 || :
                                wait    ${fftw_for_gadget_test_pid} >/dev/null 2>&1 || :
                                exit_code="$(wait ${fftw_for_gadget_test_pid} >/dev/null 2>&1 \
                                    || echo $?)"
                                if [ -n "${exit_code}" ]; then
                                    fftw_for_gadget_test_success="False"
                                else
                                    exit_code="$(cat "${exit_code_filename}" 2>/dev/null || :)"
                                    if [ "${exit_code}" != "0" ]; then
                                        fftw_for_gadget_test_success="False"
                                    fi
                                fi
                                rm -f "${exit_code_filename}" || :
                            fi
                            make install 2>&1 || continue
                            # Single-precision
                            make clean || :
                            ./configure ${enable_shared}     \
                                        ${enable_mpi}        \
                                        --enable-float       \
                                        --enable-type-prefix \
                                        --disable-fortran    \
                                        ${with_pic}          \
                                        --prefix="${fftw_for_gadget_dir}" 2>&1 || continue
                            make         2>&1 || continue
                            make install 2>&1 || continue
                            install_success="True"
                            break
                        done
                        if [ "${install_success}" == "True" ]; then
                            break
                        fi
                    done
                    if [ "${install_success}" == "True" ]; then
                        break
                    fi
                done
                if [ "${install_success}" == "True" ]; then
                    break
                fi
            done
            if [ "${install_success}" == "True" ]; then
                break
            fi
        done
        if [ "${install_success}" == "True" ]; then
            break
        fi
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install FFTW for GADGET"
        exit 1
    fi
    if [ "${fftw_for_gadget_test_success}" == "False" ]; then
        mkdir -p "$(dirname "${fftw_for_gadget_test_log}")"
        cp "test_log" "${fftw_for_gadget_test_log}"
    fi
    reset_environment
    cp "COPYING" "README" "${fftw_for_gadget_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/fftw_for_gadget" || :
    install_notice "FFTW for GADGET" "${fftw_for_gadget_dir}"
fi

# GADGET
if [ "${gadget_install}" == "True" ] && [ "${gadget_installed}" == "False" ]; then
    init_install "GADGET"
    mkdir -p "${gadget_dir}"
    mv ./* "${gadget_dir}/"
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/gadget" || :
    # GADGET will be tested as part of the COð˜•CEPT test suite
    install_notice "GADGET" "${gadget_dir}"
fi



##############################
# Testing GADGET and COð˜•CEPT #
##############################
if [ "${concept_install}" == "True" ] && [ "${concept_installed}" == "False" ]; then
    if [ "${do_tests}" == "True" ]; then
        # Run basic COð˜•CEPT test to test the environment
        current_step="basic test of ${esc_concept}"
        heading "Basic test of ${esc_concept}"
        set_status "Basic test of ${esc_concept}"
        cd "${concept_dir}"
        "${concept}" -t "basic" 2>&1 | tee "${concept_test_log}"
        [ ${PIPESTATUS[0]} -eq 0 ] || concept_test_success="False"
        if  [ "${gadget_install}" == "True" ]; then
            # Run GADGET test
            # if basic COð˜•CEPT test finished successfully
            if [ "${concept_test_success}" == "True" ]; then
                current_step="testing GADGET"
                heading "Testing GADGET"
                set_status "Testing GADGET"
                "${concept}" -t "gadget" 2>&1 | tee "${gadget_test_log}"
                [ ${PIPESTATUS[0]} -eq 0 ] || gadget_test_success="False"
                # Clean test_log if test is successfull
                if [ "${gadget_test_success}" == "True" ]; then
                    rm -f "${gadget_test_log}" || :
                fi
            fi
            # Run complete COð˜•CEPT test suite if basic COð˜•CEPT test
            # finished successfully.
            if [ "${concept_test_success}" == "True" ]; then
                current_step="testing ${esc_concept}"
                heading "Testing ${esc_concept}"
                set_status "Testing ${esc_concept}"
                OMP_NUM_THREADS_backup="${OMP_NUM_THREADS}"
                unset OMP_NUM_THREADS
                "${concept}" -t "all" 2>&1 | tee "${concept_test_log}"
                [ ${PIPESTATUS[0]} -eq 0 ] || concept_test_success="False"
                # Clean test_log if test is successfull
                if [ "${concept_test_success}" == "True" ]; then
                    rm -f "${concept_test_log}" || :
                    # Note that this also removes
                    # the ${top_dir}/tmp directory.
                    (source "${concept}" && make distclean) || :
                fi
                if [ -n "${OMP_NUM_THREADS_backup}" ]; then
                    export OMP_NUM_THREADS="${OMP_NUM_THREADS_backup}"
                fi
            fi
        fi
        cd "${top_dir}"
    fi
    # Place the installation notice in the GADGET directory in order
    # to minimize the number of files in the COð˜•CEPT directory.
    install_notice "CONCEPT" "${gadget_dir}"
fi



###################################
# Build the COð˜•CEPT code and docs #
###################################
if [ "${concept_install}" == "True" ] && [ "${concept_installed}" == "False" ]; then
    current_step="building ${esc_concept}"
    heading "Building ${esc_concept}"
    set_status "Building ${esc_concept}"
    # Build the code by running it with no parameters specified
    cd "${concept_dir}"
    logo_printed=True "${concept}" --local 2>&1
    # Remove log and parameter copy file generated by the above run
    (source "${concept}" && make clean_logs clean_params_cp) || :
    # Also build the documentation
    echo
    (source "${concept}" && make docs 2>/dev/null) || :
    cd "${top_dir}"
fi



#############################
# Final cleanup and notices #
#############################
# Make sure that the tmp directory is removed. This may fail on clusters
# with the nfs file system ("Device or resource busy") due to still
# running background processes holding .nfs... files open.
rm -rf "${top_dir}/tmp" || :
# Remove the Python cache generated by all the Python invocations
# during the install.
rm -rf "${top_dir}/__pycache__" || :
# Pytest may leave a cache directory
rm -rf "${top_dir}/.pytest_cache" || :
# Remove miscellaneous files which may be left
# by one of the installations.
rm -rf "${top_dir}/_configtest"* || :
rm -f "${top_dir}/gramA" "${top_dir}/gramB" || :
# Copyright notice
disable_status
copyright_notice(){
    # Arguments: Program/package name, text if installed by this script
    if eval "[ \"\${${1}_install}\" == \"True\" ]"; then
        printf "${2}\n"
    fi
}
if [ "${install_anything}" == "True" ] && [ "${say_copyright}" != "False" ]; then
    current_step="copyright notice"
    heading "Copyright notice"
    if [ "${concept_install}" == "True" ]; then
        printf "${esc_concept} has been installed along with the following dependencies:\n"
    else
        printf "The following software has been installed:\n"
    fi
    copyright_notice "blas"              "OpenBLAS"
    copyright_notice "class"             "CLASS"
    copyright_notice "fftw"              "FFTW 3"
    copyright_notice "fftw_for_gadget"   "FFTW 2"
    copyright_notice "freetype"          "FreeType"
    copyright_notice "gadget"            "GADGET"
    copyright_notice "gsl"               "GSL"
    copyright_notice "hdf5"              "HDF5"
    copyright_notice "libpng"            "libpng"
    if [ "${mpi}" == "mpich" ]; then
        copyright_notice "mpi"           "MPICH"
    elif [ "${mpi}" == "openmpi" ]; then
        copyright_notice "mpi"           "OpenMPI"
    fi
    copyright_notice "ncurses"           "ncurses"
    copyright_notice "openssl"           "OpenSSL"
    copyright_notice "perl"              "Perl"
    copyright_notice "zlib"              "zlib"
    copyright_notice "python"            "Python"
    copyright_notice "blessings"         "$(printf ${en_quad}%.s {1..4})Blessings"
    copyright_notice "cython"            "$(printf ${en_quad}%.s {1..4})Cython"
    copyright_notice "cythongsl"         "$(printf ${en_quad}%.s {1..4})CythonGSL"
    copyright_notice "h5py"              "$(printf ${en_quad}%.s {1..4})H5Py"
    copyright_notice "matplotlib"        "$(printf ${en_quad}%.s {1..4})Matplotlib"
    copyright_notice "mpi4py"            "$(printf ${en_quad}%.s {1..4})MPI4Py"
    copyright_notice "numpy"             "$(printf ${en_quad}%.s {1..4})NumPy"
    copyright_notice "pytest"            "$(printf ${en_quad}%.s {1..4})pytest"
    copyright_notice "scipy"             "$(printf ${en_quad}%.s {1..4})SciPy"
    copyright_notice "sphinx"            "$(printf ${en_quad}%.s {1..4})Sphinx"
    copyright_notice "sphinx_copybutton" "$(printf ${en_quad}%.s {1..4})sphinx_copybutton"
    copyright_notice "sphinx_rtd_theme"  "$(printf ${en_quad}%.s {1..4})sphinx_rtd_theme"
    copyright_notice "sphinx_tabs"       "$(printf ${en_quad}%.s {1..4})sphinx_tabs"
    printf "\nThese have been installed into separate directories in\n\"${top_dir}\"\n"
    if [ "${concept_install}" == "True" ] && [ "${concept_installed}" == "False" ]; then
        printf "Any use of ${esc_concept} must conform to the license terms of the above
software in addition to its own. These can be found in the separate
installation directories.\n"
    else
        printf "Any use of the above software must conform to their license terms.
These can be found in the separate installation directories.\n"
    fi
fi
# Notice about test errors
current_step="erroneous tests notice"
any_test_error_notices="False"
erroneous_test_notice(){
    # Arguments: Program name, [alternative message]
    progname="${1// /_}"
    progname="$(echo "${progname}" | tr '[:upper:]' '[:lower:]')"
    test_success="True"
    eval "test_success=\"\${${progname}_test_success}\""
    if [ "${test_success}" == "False" ]; then
        if [ "${any_test_error_notices}" == "False" ]; then
            # First test error notice
            heading "Erroneous tests notice"
            any_test_error_notices="True"
        else
            # Add newline between notices
            echo
        fi
        eval "test_log_path=\"\${${progname}_test_log}\""
        printf "${esc_bold}${esc_red}Warning: ${esc_normal}"
        real_name="${1/CONCEPT/$esc_concept}"
        if [ "${real_name}" == "MPI" ]; then
            if [ "${mpi}" == "mpich" ]; then
                real_name="MPICH"
            elif [ "${mpi}" == "openmpi" ]; then
                real_name="OpenMPI"
            fi
        fi
        printf "Some tests of ${real_name} did not pass successfully.\n"
        if [ -n "${2}" ]; then
            printf "${2}\n"
            if [ "${progname}" != "concept" ] && [ "${concept_test_success}" != "False" ]; then
                printf "As ${esc_concept} do seem to function correctly, "
                printf "you may choose to disregard this.\n"
            fi
        else
            printf "As ${real_name} did seem to install correctly, "
            printf "this is usually not of any concern.\n"
        fi
        printf "The logged output of the tests can be found in\n"
        printf "\"${test_log_path}\"\n"
    fi
}
erroneous_test_notice "CLASS"
erroneous_test_notice "FFTW"
erroneous_test_notice "FFTW for GADGET"
erroneous_test_notice "FreeType"
erroneous_test_notice "GADGET"
erroneous_test_notice "GSL"
erroneous_test_notice "HDF5"
erroneous_test_notice "libpng"
erroneous_test_notice "MPI"
erroneous_test_notice "ncurses"
erroneous_test_notice "NumPy"
erroneous_test_notice "OpenSSL"
erroneous_test_notice "Perl"
erroneous_test_notice "Python"
erroneous_test_notice "SciPy"
erroneous_test_notice "zlib"
erroneous_test_notice "CONCEPT" \
                      "${esc_italic}This should usually be taken seriously!${esc_no_italic}"
if [ "${any_test_error_notices}" == "True" ]; then
    printf "\nThe logged output of the entire installation process can be found in\n"
    printf "\"${log}\"\n"
    printf "while the logged warnings and errors can be found in\n"
    printf "\"${log}_err\"\n"
fi

# Subprocess complete
printf "\n\n\n"
disable_status
if [ "${any_test_error_notices}" == "False" ]; then
    successfully_finish_status
fi
# Deactivate traps before exiting subprocess
trap : 0
) >> "${log}") 3>&1 1>&2 2>&3 & echo $! > "${top_dir}/.log_pid") \
    | tee -a "${log}_err" 3>&1 1>&2 2>&3 &
# Wait for the .log_pid file to be created
slept=0
while [ ! -f "${top_dir}/.log_pid" ]; do
    sleep 1
    ((slept += 1))
    if [ ${slept} -eq 30 ]; then
        break
    fi
done
log_pid=$(cat "${top_dir}/.log_pid")
rm -f "${top_dir}/.log_pid" || :
# End of subprocess #
#####################



################
# Display loop #
################
# Wait for the install log to be created
slept=0
while [ ! -f "${log}" ]; do
    sleep 1
    ((slept += 1))
    if [ ${slept} -eq 30 ]; then
        error "Could not create the log file \"${log}\""
        exit 1
    fi
done

# Continuously print the tail of the install log
((n_lines_to_skip = log_file_lines_before_install + 2))
display_loop(){
    local IFS=''
    printf "\n\n"
    tail -n +${n_lines_to_skip} -f "${log}" --pid ${log_pid} | while read -r line; do
        # Print out the lines, formatted nicely
        if [[ "${line}" == "${status_prefix}"* ]]; then
            status_backup_="${status}"
            status=${line:${status_prefix_length}}
            if [ "${status}" == "${status_disable}" ]; then
                # Disable status
                status_visible="${status_off}"
                status_backup="${status_backup_}"
                printf "${esc_up}${esc_erase}"
                printf "${esc_up}"
            elif [ "${status}" == "${status_enable}" ]; then
                # Enable status
                status_visible="${status_on}"
                status="${status_backup}"
                printf "\n${esc_bold}${esc_reverted}${status}${esc_normal}\n"
            elif [ "${status}" == "${status_finish}" ]; then
                # Display loop complete. Do nothing
                :
            elif [ "${status_visible}" == "${status_on}" ]; then
                # Normal status update
                printf "${esc_up}${esc_erase}"
                printf "${esc_up}"
                printf "\n${esc_bold}${esc_reverted}${status}${esc_normal}\n"
            fi
        else
            if [ "${status_visible}" == "${status_on}" ]; then
                # Line with status enabled
                printf "${esc_up}${esc_erase}"
                printf "${esc_up}"
                printf "%s\n" "${line}"
                printf "\n${esc_bold}${esc_reverted}${status}${esc_normal}\n"
            else
                # Line with status disabled
                printf "%s\n" "${line}"
            fi
        fi
    done
}
display_loop

# Installation complete
installation_guaranteed_successful="False"
if [ "${do_tests}" == "True" ] && \
    [ "$(tail -n 1 "${log}")" == "${status_prefix}${status_finish_successfully}" ]; then
    installation_guaranteed_successful="True"
fi
if [ ! -s "${log}" ]; then
    rm -f "${log}" || :
fi
if [ ! -s "${log}_err" ]; then
    rm -f "${log}_err" || :
fi
if [ "${say_goodbye}" != "False" ]; then
    if [ "${concept_install}" == "True" ] && [ "${concept_installed}" == "False" ]; then
        if [ "${installation_guaranteed_successful}" == "True" ]; then
            printf "${esc_bold}${esc_green}${esc_concept} installation finished${esc_normal}\n"
        else
            printf "${esc_concept} installation finished\n"
        fi
    else
        if [ "${installation_guaranteed_successful}" == "True" ]; then
            printf "${esc_bold}${esc_green}Installation finished${esc_normal}\n"
        else
            printf "Installation finished\n"
        fi
    fi
fi
trap : 0
