#!/usr/bin/env bash

# This file is part of COùòïCEPT, the cosmological ùòï-body code in Python.
# Copyright ¬© 2015‚Äì2019 Jeppe Mosgaard Dakin.
#
# COùòïCEPT is free software: You can redistribute it and/or modifypath
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# COùòïCEPT is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with COùòïCEPT. If not, see http://www.gnu.org/licenses/
#
# The author of COùòïCEPT can be contacted at dakin(at)phys.au.dk
# The latest version of COùòïCEPT is available at
# https://github.com/jmd-dk/concept/



# Help text which gets printed if invoked with -h or --help.
help_text='This script downloads and installs the COùòïCEPT code with all its
dependencies. You can also download and run the newest version of this script
by executing the following command:
  bash <(wget -O- https://raw.githubusercontent.com/jmd-dk/concept/master/installer)

If run without an argument, this script will prompt for an
installation directory. Alternatively, this directory can be passed as
an argument. Everything will be installed within this directory.

Options taken by this script:
  -h, --help   Show this help message and exit.
  -t, --tests  Test the various dependency programs after their individual
               installations. COùòïCEPT itself will similarly be tested.
               On failure (fatal or non-fatal) of any test, a log file of the
               test output will be placed in the installation directory of the
               given program. Any test failures will also be reported at the
               end of the entire installation.
  -y, --yes    Accept default options on future quiries. Currently these
               include only the system wide installations of basic system
               dependencies (e.g. gcc), should they be missing.
               Note that this require root access.
  --fix-ssh    Set up the ~/.ssh directory so that it allows for password-less
               SSH login between nodes. This may be needed in order to run
               multi-node MPI computations on clusters.
               The original state of the ~/.ssh directory will be backed up.
               Note that this option will perform the changes to ~/.ssh only;
               no actual installation will take place.

The full invocation signature of this script thus looks like
  /path/to/installer [/path/to/concept] [-t] [-y]
or
  /path/to/installer --fix-ssh
where brackets indicate optional arguments.

The system dependencies mentioned above consist of the following
(GNU implementations, specifically):
  - awk
  - gcc
  - g++
  - gfortran
  - grep
  - gzip
  - make
  - sed
  - tar
  - wget
  - glibc
  - as and ld
  - Linux headers
If any of these are missing, an attempt will be made to locate the
package manager on the system. If successful, you will be prompted to install
the missing system dependency, which will require root access.

The only system dependencies needed but not installed are the GNU core
utilities and bash. This script (and others used in COùòïCEPT) should be
compatible with bash version 3.0 or later.

The programs which will be installed into the specified installation
directory consist of the following and will be installed in order:
  - zlib     (needed by libpng, HDF5 and Python)
  - libpng   (needed by matplotlib)
  - GSL
  - MPICH/OpenMPI
  - HDF5
  - FFTW
  - FreeType (needed by matplotlib)
  - ncurses  (needed by _curses, which is needed by blessings)
  - Perl     (needed by OpenSSL)
  - OpenSSL  (needed by pip)
  - libffi   (needed by _ctypes, which is needed by pip)
  - OpenBLAS (needed by SciPy and also used by NumPy)
  - Python, with the following packages (together with their own Python
    package dependencies):
      - pip, setuptools & wheel (if any of the below)
      - Blessings
      - Cython
      - CythonGSL
      - pytest (needed by NumPy and SciPy if running with tests)
      - NumPy
      - SciPy
      - Matplotlib
      - MPI4Py
      - H5Py
  - CLASS
  - COùòïCEPT
  - FFTW 2 (needed by GADGET)
  - GADGET

Due to the numerosity of the above list, the installation process will take
about an hour on modern hardware. The installation time depend strongly
on whether make is allowed to build in parallel or not. When running locally
(i.e. not over SSH), the default is to build in parallel using all available
CPU cores. Conversely, when running remotely the default is to build serially.
You can overwrite these defaults by setting the `make_jobs`
environment variable. E.g. to build in parallel using up to 4 CPU cores,
invoke this script as
  make_jobs="-j 4" /path/to/installer [/path/to/concept] [-t] [-y]

The installation time is significantly increased when invoked with -t.
Note that the Python test suite will be run even when invoked without -t,
as this is done as part of the profile guided optimization used to make
the resultant Python interpreter faster.

When installing in a complicated environment with several available compilers
(typical for clusters) the installation time can be up to several times longer,
as for each program the installer tries out different compilers
and other options until a working configuration is found.

By default, any pre-installed software on the list above will be ignored.
No conflicts should come of this. Should you still wish COùòïCEPT to use one such
pre-installed component, you can declare its directory path through the
`programname_dir` environment variable.
E.g. to use a pre-installedgsl library:
  gsl_dir=/path/to/gsl /path/to/installer [/path/to/concept] [-t] [-y]
The set of such environment variables correspond to the program names
above (using lowercase only), except for MPICH/OpenMPI and OpenBLAS, which are
just mpi_dir and blas_dir, respectively, as the specific MPI and BLAS
implementation does not matter.

When installing COùòïCEPT on a cluster, it is often preferable to make use of an
already installed MPI library (MPI standard 3, any implementation should do),
as this is (hopefully) properly configured with e.g. InfiniBand, which may not
be the case for the MPI installation produced by this script.
Thus on clusters it is adviced to use
  mpi_dir=/path/to/mpi /path/to/installer [/path/to/concept] [-t] [-y]
If you have /path/to/mpi/bin properly loaded into your PATH,
you can get by without specifying the MPI path explicitly using
  mpi_dir=$(which mpicc) /path/to/installer [/path/to/concept] [-t] [-y]
(Note that $(which mpicc) results in /path/to/mpi/bin/mpicc, not /path/to/mpi.
Though both are valid in this case,
generally you must specify precisely programname_dir=/path/to/programname.)

When not using a pre-installed MPI (i.e. when mpi_dir is not specified),
you may specify which MPI implementation to install --- either MPICH
or OpenMPI --- by setting the `mpi` environment variable to "mpich"
or "openmpi", respectively. E.g.
  mpi=openmpi /path/to/installer [/path/to/concept] [-t] [-y]
The default is MPICH.

Should you choose to use a pre-installed Python distribution
(by setting the python_dir variable), any missing Python packages
will be installed in this distribution. Pre-installed Python packages
will not be touched; e.g. if the installer wishes to install NumPy
1.10.4, but 1.10.3 is already installed, the package will not be
updated. If you want such Python package updates (or downgrades),
set the `pythonpackagename_install` environment variable to "True".
E.g. to overwrite a pre-installed NumPy package:
  numpy_install=True python_dir=/path/to/python /path/to/installer
If you choose to use a pre-installed Python distribution, it is your
responsibility that pip is installed as part of this distribution.
Also, if the blessings package is not pre-installed in the Python
distribution, Python should at least be compiled with the ncurses
library.

Should you choose to use a pre-installed GADGET (by setting the gadget_dir
variable), note that this must be placed in a directory to which you have
write (as well as read and execute, naturally) permissions and that COùòïCEPT
will make changes to the source files of GADGET during some tests.

Should you wish to install a specific version of some dependency
program, Python package or COùòïCEPT itself, simply set the environment
variable `programname_version` when invoking the installer.
E.g. to install GSL 2.4:
  gsl_version=2.4 /path/to/installer [/path/to/concept] [-t] [-y]

Logs of the installation process are written to install_log (stdout)
and install_log_err (stderr) in the top installation directory.
Should the installation process end prematurely (e.g. due to network failure),
simply rerun this script with the same arguments and environment variables
as originally, and it will pick up the installation from where it left off.

See https://github.com/jmd-dk/concept for further information.
'
# Print help text and exit, if help is requested
for var in "$@"; do
    if     [ "${var}" ==  "-h"    ] \
        || [ "${var}" == "--h"    ] \
        || [ "${var}" == "--he"   ] \
        || [ "${var}" == "--hel"  ] \
        || [ "${var}" == "--help" ]; then
        printf "${help_text}"
        exit 0
    fi
done

# If invoked directly from the web (e.g. via wget), a small pause
# ensures that the print outs will not corrupt the loading bar.
sleep 2
# Newer versions of wget saves a copy of the printout when using the
# -O- option to a file called wget-log[.x], x ‚àà ‚Ñï. Remove any such log
# produced from invoking this script via wget.
wget_log_maxage=300
for filename in *; do
    if [ ! -f "${filename}" ] || [[ "${filename}" != "wget-log"* ]]; then
        continue
    fi
    fileage=$(($(date +%s) - $(stat -c '%Y' "${filename}")))
    if [ ${fileage} -lt ${wget_log_maxage} ]; then
        rm -f "${filename}" || :
    fi
done



##################
# Specifications #
##################
# The MPI implementation to use
mpi_lower="$(echo "${mpi}" | tr '[:upper:]' '[:lower:]')"
if [ -z "${mpi}" ]; then
    # If mpi_dir is specified,
    # try to determine whether OpenMPI or MPICH is used.
    if [ -n "${mpi_dir}" ]; then
        if [ -f "${mpi_dir}/bin/ompi_info" ]; then
            mpi="openmpi"
        elif [ -f "${mpi_dir}/bin/mpichversion" ]; then
            mpi="mpich"
        else
            mpi="unknown"
        fi
    else
        # Use MPICH by default
        mpi="mpich"
    fi
elif [ "${mpi_lower}" != "openmpi" ] && [ "${mpi_lower}" != "mpich" ]; then
    echo "Specified MPI implementation mpi=\"${mpi}\" not recognized.
Will use MPICH" >&2
    mpi="mpich"
fi
mpi="$(echo "${mpi}" | tr '[:upper:]' '[:lower:]')"
# This function sets the variables "name_dir" (if not set already)
# and "name_preinstalled".
set_dir(){
    # Arguments: Program name, install directory.
    # Set "name_preinstalled" if "name_dir" is already set
    eval "${1}_preinstalled=True"
    eval "[ -n \"\${${1}_dir}\" ] || ${1}_preinstalled=\"False\""
    # Set "name_dir" if "name_dir" is not already set
    # or "name" should be installed.
    eval "[ -n \"\${${1}_dir}\" ] || ${1}_dir=\"${2}\""
    eval "(! (   [ \"\${${1}_install}\"      == \"False\" ] \
              && [ \"\${${1}_preinstalled}\" == \"False\" ])) || ${1}_dir=\"\""
}
# The install_explicit_only environment variable, when set to "True",
# disables all implicit installations.
if [ "${install_explicit_only}" == "True" ]; then
    for progname in "concept"         \
                    "blas"            \
                    "class"           \
                    "fftw"            \
                    "fftw_for_gadget" \
                    "freetype"        \
                    "gadget"          \
                    "gsl"             \
                    "hdf5"            \
                    "libffi"          \
                    "libpng"          \
                    "mpi"             \
                    "ncurses"         \
                    "openssl"         \
                    "perl"            \
                    "python"          \
                    "zlib"            \
                    "blessings"       \
                    "cython"          \
                    "cythongsl"       \
                    "h5py"            \
                    "matplotlib"      \
                    "mpi4py"          \
                    "numpy"           \
                    "pytest"          \
                    "scipy"; do
        eval "[ -n \"\${${progname}_install}\" ] || ${progname}_install=\"False\""
    done
fi
# Specification of paths. The substring "__top_dir__"
# will later be replaced with the top level directory.
set_dir "class"           "__top_dir__/class"
set_dir "concept"         "__top_dir__/concept"
set_dir "fftw"            "__top_dir__/fftw"
set_dir "freetype"        "__top_dir__/freetype"
set_dir "gadget"          "__top_dir__/gadget"
set_dir "fftw_for_gadget" "${gadget_dir}/fftw"
set_dir "gsl"             "__top_dir__/gsl"
set_dir "hdf5"            "__top_dir__/hdf5"
set_dir "libpng"          "__top_dir__/libpng"
set_dir "mpi"             "__top_dir__/${mpi}"
set_dir "blas"            "__top_dir__/openblas"
set_dir "perl"            "__top_dir__/perl"
set_dir "python"          "__top_dir__/python"
set_dir "ncurses"         "${python_dir}"
set_dir "openssl"         "${python_dir}"
set_dir "libffi"          "${python_dir}"
set_dir "zlib"            "__top_dir__/zlib"
log="__top_dir__/install_log"
env_file="__top_dir__/.env"
paths_file="__top_dir__/.paths"

# This function sets the variable "name_version" if not set already.
# For preinstalled software, set "name_version" to "pre-installed".
# If a third argument is given, this is the version to fall back to,
# in case of unsuccessful retrievel of the link to the first version.
set_version(){
    # Arguments: Program name, version, [fallback version]
    eval "[ -z \"\${${1}_version}\" ] || ${1}_version_specifiedbyuser=\"True\""
    eval "[ -n \"\${${1}_version}\" ] || ${1}_version=\"${2}\""
    eval "[ \"\${${1}_preinstalled}\" != \"True\" ] || ${1}_version=\"pre-installed\""
    if [ -n "${3}" ]; then
        eval "${1}_version_fallback=\"${3}\""
    fi
}
# Specification of software versions.
# The rightmost column are fallbacks, which will be used if the
# link to the version given by the middle column is broken.
# In case of COùòïCEPT and CLASS, possible versions are the corresponding
# GitHub branches and releases.
set_version "concept"         "master"
set_version "blas"            "0.3.7"  "0.3.7"
set_version "class"           "2.7.2"
set_version "fftw"            "3.3.8"  "3.3.8"
set_version "fftw_for_gadget" "2.1.5"  "2.1.5"   # Do not change
set_version "freetype"        "2.10.1" "2.10.1"
set_version "gadget"          "2.0.7"            # Do not change
set_version "gsl"             "2.5"    "2.5"
set_version "hdf5"            "1.10.5" "1.10.5"
set_version "libffi"          "3.2.1"  "3.2.1"
set_version "libpng"          "1.6.37" "1.6.33"
if [ "${mpi}" == "mpich" ]; then
    set_version "mpi"         "3.3.1"  "3.3.1"
elif [ "${mpi}" == "openmpi" ]; then
    set_version "mpi"         "4.0.1"
fi
set_version "ncurses"         "6.1"    "6.1"
set_version "openssl"         "1.1.1c" "1.1.1c"
set_version "perl"            "5.30.0"
set_version "python"          "3.7.4"
set_version "zlib"            "1.2.11" "1.2.11"
# Python packages
set_version "blessings"       "1.7"
set_version "cython"          "0.29.13"
set_version "cythongsl"       "0.2.2"
set_version "h5py"            "2.9.0"
set_version "matplotlib"      "3.1.1"
set_version "mpi4py"          "3.0.2"
set_version "numpy"           "1.17.0"
set_version "pip"             "19.2.2"
set_version "pytest"          "5.0.1"
set_version "scipy"           "1.3.1"
set_version "setuptools"      "41.1.0"
set_version "wheel"           "0.33.4"
# Note that the versions may be changed further down due to known
# compatibility issues between specific versions of the above programs
# and specific versions of system dependencies.



#################
# Initial setup #
#################
# Set up error trapping
ctrl_c(){
    current_step="aborting"
    sleep 0.5
    kill -9 -- -$$ > /dev/null 2>&1 || :
    exit 2
}
abort(){
    sleep 0.5
    kill -9 -- -$$ > /dev/null 2>&1 || :
    exit 1
}
trap 'ctrl_c' SIGINT
trap 'abort' EXIT
set -e

# Set sleep_time, the amount of seconds spend sleeping at various stages
sleep_time=10

# For the terminal to be able to print Unicode characters correctly,
# the terminal character set needs to be compatible. To ensure this,
# we set all locale settings to en_US.UTF-8.
export LC_ALL="en_US.UTF-8"
export LANG="en_US.UTF-8"
# Set the terminal if unset or broken
if [ -z "${TERM}" ] || [ "${TERM}" == "dumb" ]; then
    export TERM="linux"
fi

# ANSI/VT100 escape sequences
esc="\x1b"
# Text formatting
esc_normal="${esc}[0m"
esc_bold="${esc}[1m"
esc_italic="${esc}[3m"
esc_reverted="${esc}[7m"
esc_no_italic="${esc}[23m"
# The name of the program, nicely typesat
if [ -z "${esc_concept}" ]; then
    esc_concept="CO${esc_italic}N${esc_no_italic}CEPT"
else
    esc_concept="${esc_concept//\$\{esc_italic\}/${esc_italic}}"
    esc_concept="${esc_concept//\$\{esc_no_italic\}/${esc_no_italic}}"
fi

# Text colors
esc_red="${esc}[91m"
esc_green="${esc}[92m"
esc_yellow="${esc}[93m"
esc_blue="${esc}[94m"
# Cursor movement
esc_up="${esc}[1A"
esc_erase="${esc}[K"
# Special characters
en_quad="\xE2\x80\x80"
# Functions for pretty printing text
heading(){
    printf "\n${esc_bold}${esc_yellow}${1}${esc_normal}\n"
}
error(){
    printf "\n${esc_bold}${esc_red}${1}${esc_normal}\n" >&2
}

# Print out welcome message
if [ "${say_welcome}" != "False" ]; then
    heading "${esc_bold}${esc_yellow}This is the installation script for ${esc_concept},
the cosmological ${esc_italic}N${esc_no_italic}-body code in Python${esc_normal}"
fi

# Status control sequenses
status="initialization"
status_prefix="__new_status__="
status_prefix_length=${#status_prefix}
status_disable="disable"
status_enable="enable"
status_on="on"
status_off="off"
status_visible="${status_on}"
status_finish="finish_successfully"

# Backup of initial environment variables
env_var_names=(BLAS             \
               CC               \
               CFLAGS           \
               CPPFLAGS         \
               CXX              \
               CXXFLAGS         \
               F77              \
               F90              \
               F9X              \
               FC               \
               FCFLAGS          \
               FFLAGS           \
               HDF5_DIR         \
               HDF5_MPI         \
               LAPACK           \
               LD_LIBRARY_PATH  \
               LD_PRELOAD       \
               LDFLAGS          \
               LIBS             \
               MPICC            \
               MPILIBS          \
               PATH             \
               PERL             \
               PKG_CONFIG_PATH  \
               PNG_CFLAGS       \
               PNG_LIBS         \
               RUNTESTS_VERBOSE \
               TMPDIR           \
               ZLIB_CFLAGS      \
               ZLIB_LIBS        \
               ZLIBLIB          \
               ZLIBINC          \
               )
for env_var_name in "${env_var_names[@]}"; do
    # Save initial state (set/unset) of the environment variable
    if [ -n "$(eval "echo "\${${env_var_name}+x}"")" ]; then
        eval "${env_var_name}_set=\"True\""
    else
        eval "${env_var_name}_set=\"False\""
    fi
    # Save initial value of the environment variable
    eval "${env_var_name}_backup=\"\${${env_var_name}}\""
done
# Function that resets all above environment
# variables to their initial state.
reset_environment(){
    for env_var_name in "${env_var_names[@]}"; do
        eval "env_var_set=\"\${${env_var_name}_set}\""
        if [ "${env_var_set}" == "True" ]; then
            # env_var_name initially set
            eval "export ${env_var_name}=\"\${${env_var_name}_backup}\""
        else
            # env_var_name initially unset
            unset "${env_var_name}"
        fi
    done
}

# Set test_success variables
blas_test_success="True"
class_test_success="True"
concept_test_success="True"
fftw_test_success="True"
fftw_for_gadget_test_success="True"
freetype_test_success="True"
gadget_test_success="True"
gsl_test_success="True"
hdf5_test_success="True"
libffi_test_success="True"
libpng_test_success="True"
mpi_test_success="True"
ncurses_test_success="True"
openssl_test_success="True"
perl_test_success="True"
python_test_success="True"
zlib_test_success="True"
numpy_test_success="True"
scipy_test_success="True"

# Read in command line arguments
if [ -z "${do_tests}" ]; then
    do_tests="False"
fi
if [ -z "${yes_to_defaults}" ]; then
    yes_to_defaults="False"
fi
if [ -z "${fix_ssh}" ]; then
    fix_ssh="False"
fi
if [ -z "${top_dir_specified}" ]; then
    top_dir_specified="False"
fi
for var in "$@"; do
    # Strip command line argument for brackets, which may have been
    # adeed by users not familiar with this syntax for
    # specifying optional arguments.
    var="${var//\[/}"
    var="${var//\]/}"
    # Parse command line argument
    if     [ "${var}" ==  "-t"     ] \
        || [ "${var}" == "--t"     ] \
        || [ "${var}" == "--te"    ] \
        || [ "${var}" == "--tes"   ] \
        || [ "${var}" == "--test"  ] \
        || [ "${var}" == "--tests" ]; then
        do_tests="True"
    elif   [ "${var}" ==  "-y"   ] \
        || [ "${var}" == "--y"   ] \
        || [ "${var}" == "--ye"  ] \
        || [ "${var}" == "--yes" ]; then
        yes_to_defaults="True"
    elif   [ "${var}" == "--f"         ] \
        || [ "${var}" == "--fi"        ] \
        || [ "${var}" == "--fix"       ] \
        || [ "${var}" == "--fix-"      ] \
        || [ "${var}" == "--fix-s"     ] \
        || [ "${var}" == "--fix-ss"    ] \
        || [ "${var}" == "--fix-ssh"   ]; then
        fix_ssh="True"
    elif [ "${var}" == "--fast" ]; then
        # This is a deprecated option for skipping tests,
        # which is now the default. Allow it but do nothing.
        :
    elif [ "${top_dir_specified}" == "False" ]; then
        top_dir="${var}"
        top_dir_specified="True"
    else
        if [ "${var}" != "${top_dir}" ]; then
            error "Got command line argument \"${var}\", "\
"but the installation path is already set to \"${top_dir}\""
            exit 1
        fi
    fi
done

# Function for converting a path to its absolute form
initial_dir="$(pwd)"  # It is crucial that this line is before any cd
convert_to_abs_path(){
    # Arguments: path
    current_dir="$(pwd)"
    cd "${initial_dir}"
    # Places backslashes before spaces.
    # These are needed when expanding tilde, but they will not persist.
    abs_path="${1//[ ]/\\ }"
    # Expand tilde
    eval abs_path="${abs_path}"
    # Convert to absolute path
    abs_path=$(readlink -m "${abs_path}")
    cd "${current_dir}"
    echo "${abs_path}"
}

# Setup password-less SSH login between nodes (and exit), if requested
if [ "${fix_ssh}" == "True" ]; then
    # Move the preexisting ~/.ssh directory into a directory
    # ~/.ssh_backup/<date>,
    # with <date> the current time.
    if [ -d ~/".ssh" ]; then
        passwordless_ssh_timestamp="$(date)"
        passwordless_ssh_timestamp="${passwordless_ssh_timestamp// /-}"
        passwordless_ssh_backup_dir="$(convert_to_abs_path \
            "~/.ssh_backup/${passwordless_ssh_timestamp}")"
        mkdir -p ~/".ssh_backup/${passwordless_ssh_timestamp}"
        mv ~/".ssh" ~/".ssh_backup/${passwordless_ssh_timestamp}/"
        echo "The existing ~/.ssh directory has been moved to ${passwordless_ssh_backup_dir}/.ssh"
    fi
    mkdir -p ~/".ssh"
    # The type of encryption to use for the ssh keys.
    # Should be "dsa" or "rsa".
    key_type="rsa"
    # Generate a public/private key pair
    ssh-keygen -t "${key_type}" -N "" -f ~/".ssh/id_${key_type}" >/dev/null
    # Add public key to the list of keys allowed to log in
    cat ~/".ssh/id_${key_type}.pub" >> ~/".ssh/authorized_keys"
    cat ~/".ssh/id_${key_type}.pub" >> ~/".ssh/authorized_keys2"
    # Suppress future confirmation dialogs
    echo "Host *
  StrictHostKeyChecking no
  UserKnownHostsFile /dev/null
  LogLevel ERROR
" >> ~/".ssh/config"
    # Remove any previously known hosts (there should be none
    # as the ~/.ssh directory has just been created).
    rm -f "known_hosts"* 2>/dev/null || :
    # Set proper permissions in order for ssh
    # to allow password-less login.
    chmod go-w ~
    chmod 700 ~/".ssh"
    chmod 644 ~/".ssh/authorized_keys"
    chmod 644 ~/".ssh/authorized_keys2"
    chmod go-rwx ~/".ssh/config" || :
    chmod go-rwx ~/".ssh/id_${key_type}"
    chmod go+r ~/".ssh/id_${key_type}.pub"
    # Inform the user on this change
    printf "\nPassword-less ssh login between nodes has been configured\n"
    # Do not install COùòïCEPT
    trap : 0
    exit 0
fi

# This function should be called before any use of sudo and will cache
# the root password to the sudo_command variable. After this, instead of
# invoing sudo, invoke ${sudo_command} (usind eval). This way, the root
# password has to be entered at most once.
sudo_command=""
build_sudo_command(){
    if [ -z "${sudo_command}" ]; then
        if [ ${EUID} -eq 0 ]; then
            sudo_command="sudo"
        else
            sudo -k
            while :; do
                read -s -p "[sudo] password for $(whoami): " sudo_password
                echo
                output="$(echo "${sudo_password}" | sudo -S echo hello 2>&1 || :)"
                output="${output##* }"
                if [ "${output}" == "hello" ]; then
                    break
                fi
                echo "Sorry, try again."
            done
            sudo_command="echo \"${sudo_password}\" | sudo -S"
            unset sudo_password
        fi
    fi
}

# Creating top level directory (top_dir)
current_step="setup of top level directory"
if [ "${top_dir_specified}" == "False" ]; then
    printf "\nWhere should the ${esc_concept} code be installed?"
    read -p "$(echo $'\n> ')" -e top_dir
    if [ -z "${top_dir}" ]; then
        # The user hit enter without writing a path.
        # Install in current directory.
        top_dir="."
    fi
fi
top_dir_is_sane="True"
mkdir -p "${top_dir}" 2>/dev/null || top_dir_is_sane="False"
if [ "${top_dir_is_sane}" == "False" ]; then
    error "\nThe installation path \"${top_dir}\" cannot be created."
    exit 1
fi
top_dir="$(convert_to_abs_path "${top_dir}")"
printf "\nThe code will be installed in \"${top_dir}\"\n"
cd "${top_dir}"

# This directory may be created by the fix_path, use_mpi_compilers or
# use_specified_mpi_compilers functions, which use it to store symlinks
# to MPI library files.
mpi_symlinkdir="${top_dir}/.mpi_symlinks"

# Function which prints the absolute path of a given command.
# If the command is not an executable file on the PATH but instead a
# known function, the input command is printed as is. If the command
# cannot be found at all, nothing is printed and an exit code of 1
# is returned.
get_command(){
    command_name="${1}"
    # Use the type builtin to locate the command
    local path="$(type "${command_name}" 2>/dev/null || :)"
    path="${path##* }"
    if [[ "${path}" == "/"* ]]; then
        # The command is a path
        path="$(readlink -f "${path}")"
        echo "${path}"
        return 0
    elif [ -n "${path}" ]; then
        # The command exists as a function
        echo "${command_name}"
        return 0
    fi
    # The command does not exist
    return 1
}

# Check whether system dependencies are installed and located on PATH
current_step="check for preinstalled system dependencies"
# Check for package manager and set package names
set_package_names(){
    # Arguments: Package name for awk, gcc, g++, gfortran, grep, gzip,
    # make, sed, tar, wget, glibc, as and ld, Linux headers.
    i=0
    for package in      \
        "awk"           \
        "gcc"           \
        "gxx"           \
        "gfortran"      \
        "grep"          \
        "gzip"          \
        "make"          \
        "sed"           \
        "tar"           \
        "wget"          \
        "glibc"         \
        "as_ld"         \
        "linux_headers" \
    ; do
        ((i += 1))
        eval "${package}_package=\${${i}}"
    done
}
set_package_manager_and_names(){
    # This function takes no arguments
    package_manager=""
    for pmanager in \
        "apt"       \
        "apt-get"   \
        "aptitude"  \
        "dnf"       \
        "yum"       \
        "zypper"    \
        "urpmi"     \
        "pacman"    \
        "eopkg"     \
        "emerge"    \
        "slackpkg"  \
    ; do
        if get_command "${pmanager}" >/dev/null; then
            # Package manager found
            package_manager="${pmanager}"
            # Package names
            case "${package_manager}" in
                "apt") install_command="${package_manager} install -y"
                    set_package_names               \
                        "gawk"                      \
                        "gcc"                       \
                        "g++"                       \
                        "gfortran"                  \
                        "grep"                      \
                        "gzip"                      \
                        "make"                      \
                        "sed"                       \
                        "tar"                       \
                        "wget"                      \
                        "libc6 libc6-dev"           \
                        "binutils"                  \
                        "linux-headers-$(uname -r)"
                    break
                    ;;
                "apt-get") install_command="${package_manager} -y install"
                    set_package_names               \
                        "gawk"                      \
                        "gcc"                       \
                        "g++"                       \
                        "gfortran"                  \
                        "grep"                      \
                        "gzip"                      \
                        "make"                      \
                        "sed"                       \
                        "tar"                       \
                        "wget"                      \
                        "libc6 libc6-dev"           \
                        "binutils"                  \
                        "linux-headers-$(uname -r)"
                    break
                    ;;
                "aptitude") install_command="${package_manager} -y install"
                    set_package_names               \
                        "gawk"                      \
                        "gcc"                       \
                        "g++"                       \
                        "gfortran"                  \
                        "grep"                      \
                        "gzip"                      \
                        "make"                      \
                        "sed"                       \
                        "tar"                       \
                        "wget"                      \
                        "libc6 libc6-dev"           \
                        "binutils"                  \
                        "linux-headers-$(uname -r)"
                    break
                    ;;
                "dnf") install_command="${package_manager} -y install"
                    set_package_names       \
                        "gawk"              \
                        "gcc"               \
                        "gcc-c++"           \
                        "gcc-gfortran"      \
                        "grep"              \
                        "gzip"              \
                        "make"              \
                        "sed"               \
                        "tar"               \
                        "wget"              \
                        "glibc glibc-devel" \
                        "binutils"          \
                        "kernel-headers"
                    break
                    ;;
                "yum") install_command="${package_manager} -y install"
                    set_package_names       \
                        "gawk"              \
                        "gcc"               \
                        "gcc-c++"           \
                        "gcc-gfortran"      \
                        "grep"              \
                        "gzip"              \
                        "make"              \
                        "sed"               \
                        "tar"               \
                        "wget"              \
                        "glibc glibc-devel" \
                        "binutils"          \
                        "kernel-headers"
                    break
                    ;;
                "zypper") install_command="${package_manager} -n install"
                    set_package_names          \
                        "gawk"                 \
                        "gcc"                  \
                        "gcc-c++"              \
                        "gcc-fortran"          \
                        "grep"                 \
                        "gzip"                 \
                        "make"                 \
                        "sed"                  \
                        "tar"                  \
                        "wget"                 \
                        "glibc glibc-devel"    \
                        "binutils"             \
                        "linux-kernel-headers"
                    break
                    ;;
                "urpmi") install_command="${package_manager} --auto"
                    set_package_names              \
                        "gawk"                     \
                        "gcc"                      \
                        "gcc-c++"                  \
                        "gcc-gfortran"             \
                        "grep"                     \
                        "gzip"                     \
                        "make"                     \
                        "sed"                      \
                        "tar"                      \
                        "wget"                     \
                        "glibc glibc-devel"        \
                        "binutils"                 \
                        "kernel-userspace-headers"
                    break
                    ;;
                "pacman") install_command="${package_manager} -S --noconfirm"
                    set_package_names   \
                        "gawk"          \
                        "gcc"           \
                        "gcc"           \
                        "gcc-fortran"   \
                        "grep"          \
                        "gzip"          \
                        "make"          \
                        "sed"           \
                        "tar"           \
                        "wget"          \
                        "glibc"         \
                        "binutils"      \
                        "linux-headers"
                    break
                    ;;
                "eopkg") install_command="${package_manager} install -y"
                    set_package_names       \
                        "gawk"              \
                        "gcc"               \
                        "g++"               \
                        "gfortran"          \
                        "grep"              \
                        "gzip"              \
                        "make"              \
                        "sed"               \
                        "tar"               \
                        "wget"              \
                        "glibc glibc-devel" \
                        "binutils"          \
                        "linux-headers"
                    break
                    ;;
                "emerge") install_command="${package_manager}"
                    set_package_names       \
                        "gawk"              \
                        "gcc"               \
                        "gcc"               \
                        "fortran"           \
                        "grep"              \
                        "gzip"              \
                        "make"              \
                        "sed"               \
                        "tar"               \
                        "wget"              \
                        "glibc"             \
                        "binutils"          \
                        "linux-headers"
                    break
                    ;;
                "slackpkg") install_command="${package_manager} install"
                    set_package_names       \
                        "gawk"              \
                        "gcc"               \
                        "gcc-g++"           \
                        "gcc-gfortran"      \
                        "grep"              \
                        "gzip"              \
                        "make"              \
                        "sed"               \
                        "tar"               \
                        "wget"              \
                        "glibc"             \
                        "binutils"          \
                        "kernel-headers"
                    break
                    ;;
            esac
            break
        fi
    done
}
set_package_manager_and_names
# Function for testing whether system dependencies are installed and
# located on PATH. For missing system dependencies, it will attempt to
# figure out the command to install it.
check_system_dependency(){
    # Arguments: Command, package name
    if ! get_command "${1}" >/dev/null; then
        # Package not installed
        if [ -n "${package_manager}" ]; then
            # Package manager found
            if [ "${yes_to_defaults}" == "True" ]; then
                echo "Auto installing '${1}'"
                build_sudo_command
                eval "${sudo_command} ${install_command} ${2}"
                printf "${1} successfully installed\n\n"
            else
                echo "Could not find '${1}'"
                echo "You can install it by typing:"
                echo "sudo ${install_command} ${2}"
                while :; do
                    read -p "Run above command now? [Y/n] " yn
                    case "${yn}" in
                        [Yy]* ) build_sudo_command
                                eval "${sudo_command} ${install_command} ${2}"
                                printf "${1} successfully installed\n\n"
                                return
                                ;;
                        [Nn]* ) error "Terminated install due to missing component '${1}'"
                                exit 1
                                ;;
                        ""    ) eval "${install_command} ${2}"
                                printf "${1} successfully installed\n\n"
                                return
                                ;;
                        *     ) error "Terminated install due to missing component '${1}'"
                                exit 1
                                ;;
                    esac
                done
                exit 1
            fi
        else
            # No package manager found
            error "Error: Could not find '${1}'"
            exit 1
        fi
    fi
}
check_system_dependency "awk"      "${awk_package}"
check_system_dependency "gcc"      "${gcc_package}"
check_system_dependency "g++"      "${gxx_package}"
check_system_dependency "gfortran" "${gfortran_package}"
check_system_dependency "grep"     "${grep_package}"
check_system_dependency "gzip"     "${gzip_package}"
check_system_dependency "make"     "${make_package}"
check_system_dependency "sed"      "${sed_package}"
check_system_dependency "tar"      "${tar_package}"
check_system_dependency "wget"     "${wget_package}"

# Though gcc is now guaranteed to be installed,
# it may miss important components, which we check for here.
current_step="check of gcc components"
gcc_test(){
    # Arguments:
    #   - Name of gcc component
    #   - C source code to test
    #   - Expected output
    #   - Text to write if fail
    #   - Name of package to install if fail
    name="$1"
    C_source="$2"
    expected_output="$3"
    message="$4"
    package_name="$5"
    # Prepare for gcc test
    current_dir="$(pwd)"
    gcc_test_dir="${top_dir}/tmp/gcc_test"
    rm -rf "${gcc_test_dir}" || :
    mkdir -p "${gcc_test_dir}"
    cd "${gcc_test_dir}"
    # Write C source to file
    echo "${C_source}" > main.c
    # Test compile and run
    for i in 0 1; do
        gcc_test_success="True"
        gcc main.c -o main || gcc_test_success="False"
        if [ "${gcc_test_success}" == "True" ]; then
            gcc_test_output="$(./main)"
            if [ "${gcc_test_output}" != "${expected_output}" ]; then
                gcc_test_success="False"
            fi
        fi
        if [ "${gcc_test_success}" == "False" ]; then
            if [ $i -eq 0 ]; then
                # Test failed.
                # Prompt for installation of needed package.
                echo
                echo "${message}"
                if [ -z "${package_manager}" ]; then
                    # No package manager found
                    error "Error: Could not find any installed package manager"
                    exit 1
                fi
                if [ "${yes_to_defaults}" == "True" ]; then
                    echo "Auto installing ${name}"
                    eval "${install_command} ${package_name}"
                else
                    echo "To ensure that ${name} are installed, type:"
                    echo "${install_command} ${package_name}"
                    gcc_test_prompt(){
                        while :; do
                            read -p "Run above command now? [Y/n] " yn
                            case "${yn}" in
                                [Yy]* ) eval "${install_command} ${package_name}"
                                        return
                                        ;;
                                [Nn]* ) error \
                                            "Terminated install due to missing component: ${name}"
                                        exit 1
                                        ;;
                                ""    ) eval "${install_command} ${package_name}"
                                        return
                                        ;;
                                *     ) error \
                                            "Terminated install due to missing component: ${name}"
                                        exit 1
                                        ;;
                            esac
                        done
                        exit 1
                    }
                    gcc_test_prompt
                fi
                printf "${name} successfully installed\n\n"
            else
                # Test failed even after installing the needed package
                error "Terminated install due to gcc failing to \
properly compile \"${gcc_test_dir}/main.c\""
                exit 1
            fi
        fi
    done
    # Cleanup after test
    cd "${current_dir}"
    rm -rf "${gcc_test_dir}" || :
}
# Basic gcc test, checking for the standard library,
# the assembler and linker.
gcc_test                                                \
    "the gcc C standard library, assembler and linker"  \
    '
#include <stdio.h>
int main(void){
    printf("hello\n");
    return 0;
}
'                                                       \
    "hello"                                             \
    "gcc could not compile even a simple C program. \
We need to make sure that the gcc C standard library, \
as well as the assembler and linker are all installed." \
    "${glibc_package} ${as_ld_package}"
# Check for the Linux headers
gcc_test                                                \
    "the Linux headers"  \
    '
#include <linux/limits.h>
#include <stdio.h>
int main(void){
    printf("hello\n");
    return 0;
}
'                                                       \
    "hello"                                             \
    "gcc could not find the Linux headers. \
We need to make sure that these are installed."         \
    "${linux_headers_package}"

# Change default versions if they are known not to work
# with the present versions of the system dependencies.
:

# Function which finds files deep inside a directory tree
# (like the GNU find command).
find_recursive(){
    # Arguments: Absolute path to directory,
    # file/directory to find,
    # [type of file to find: "-f" for file (default),
    #  "-d" for directory].
    local dirname="$1"
    local filename="$2"
    local fd="$3"
    if [ -z "${fd}" ]; then
        fd="-f"
    fi
    # Change directory
    local current_dir="$4"
    local primary_call="False"
    if [ -z "${current_dir}" ]; then
        # This is the primary call to this function
        primary_call="True"
        current_dir="$(pwd)"
        found_results=()
    fi
    dirname="$(convert_to_abs_path "${dirname}")"
    if [ ! -d "${dirname}" ]; then
        return
    fi
    cd "${dirname}"
    # Is file at this location?
    if [ ${fd} "${filename}" ]; then
        # Found
        found_results=("${found_results[@]}" "${dirname}/${filename}")
    else
        # Not found. Search in all subdirectories.
        local f
        for f in *; do
            if [ -d "${f}" ]; then
                find_recursive "${dirname}/${f}" "${filename}" "${fd}" "${current_dir}"
                cd "${dirname}"
            fi
        done
    fi
    cd "${current_dir}"
    if [ "${primary_call}" == "True" ]; then
        # Print out the shortest of the found results, where the length
        # is measured by counting the number of / in the paths.
        N=${#found_results[@]}
        if [ ${N} -gt 0 ]; then
            shortest_result="${found_results[0]}"
            n_slashes_shortest=$(echo "${shortest_result}" | awk -F/ '{print NF-1}')
            for ((i = 1; i < ${N}; i += 1)); do
                n_slashes=$(echo "${found_results[$i]}" | awk -F/ '{print NF-1}')
                if [ ${n_slashes} -lt ${n_slashes_shortest} ]; then
                    shortest_result="${found_results[$i]}"
                    n_slashes_shortest=${n_slashes}
                fi
            done
            echo "${shortest_result}"
        fi
    fi
}

# Replace "__top_dir__" in paths with the user specified top_dir.
# Also convert to absolute path and check that this path exist for
# pre-installed libraries.
fix_path(){
    # Arguments: Program name
    progname="${1// /_}"
    progname="$(echo "${progname}" | tr '[:upper:]' '[:lower:]')"
    # Replace "__top_dir__"
    eval "[ \"\${${progname=}_preinstalled}\" == \"True\" ] \
          || ${progname=}_dir=\"\${${progname=}_dir/__top_dir__/${top_dir}}\""
    # Convert to absolute path
    eval "${progname=}_dir=\"\$(convert_to_abs_path \"\${${progname=}_dir}\")\""
    # Check that the path to pre-installed dependencies exist
    if eval "[ \"\${${progname}_preinstalled}\" == \"True\" ] \
             && [ ! -d \"\${${progname}_dir}\" ] \
             && [ ! -f \"\${${progname}_dir}\" ]"; then
        error "The specified directory\n\"$(eval "echo \${${progname}_dir}")\"\n\
for ${1/CONCEPT/$esc_concept} does not exist!"
        exit 1
    fi
    # Check and correct user specified dependency directories
    eval "progname_dir=\"\${${progname=}_dir}\""
    if [ -f "${progname_dir}" ]; then
        progname_dir="$(dirname ${progname_dir})"
    fi
    if [ "${progname}" == 'class' ] && [ "${class_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/class" ]; then
            if [ -f "${progname_dir}/../class" ]; then
                class_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate CLASS at \"${class_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'concept' ] && [ "${concept_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/concept" ]; then
            if [ -f "${progname_dir}/../concept" ]; then
                concept_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate COùòïCEPT at \"${concept_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'fftw' ] && [ "${fftw_preinstalled}" == "True" ]; then
        if     [ ! -f "${progname_dir}/lib/libfftw3.so" ] \
            && [ ! -f "${progname_dir}/lib/libfftw3f.so" ]; then
            if     [ -f "${progname_dir}/../lib/libfftw3.so" ] \
                || [ -f "${progname_dir}/../lib/libfftw3f.so" ]; then
                fftw_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate FFTW at \"${fftw_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'freetype' ] && [ "${freetype_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/lib/libfreetype.so" ]; then
            if [ -f "${progname_dir}/../lib/libfreetype.so" ]; then
                freetype_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate FreeType at \"${freetype_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'gadget' ] && [ "${gadget_preinstalled}" == "True" ]; then
        if [ ! -d "${progname_dir}/Gadget2" ]; then
            if [ -d "${progname_dir}/../Gadget2" ]; then
                gadget_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate Gadget at \"${gadget_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'gsl' ] && [ "${gsl_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/lib/libgsl.so" ]; then
            if [ -f "${progname_dir}/../lib/libgsl.so" ]; then
                gsl_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate GSL at \"${gsl_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'hdf5' ] && [ "${hdf5_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/lib/libhdf5.so" ]; then
            if [ -f "${progname_dir}/../lib/libhdf5.so" ]; then
                hdf5_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate HDF5 at \"${hdf5_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'libffi' ] && [ "${libffi_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/lib/libffi.so" ]; then
            if [ -f "${progname_dir}/../lib/libffi.so" ]; then
                libffi_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate libffi at \"${libffi_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'libpng' ] && [ "${libpng_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/lib/libpng.so" ]; then
            if [ -f "${progname_dir}/../lib/libpng.so" ]; then
                libpng_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate libpng at \"${libpng_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'mpi' ] && [ "${mpi_preinstalled}" == "True" ]; then
        # As a pre-installed MPI is often used, allow for a rather
        # general directory layout. Find mpi_bindir, mpi_libdir and
        # mpi_includedir and set mpi_dir to the deepest common directory
        # in the path of these three directories.
        # First find the mpicc executable.
        progname_dir_shallow="${progname_dir}"
        for ((i = 0; i < 3; i += 1)); do
            mpicc="$(find_recursive "${progname_dir_shallow}" "mpicc")"
            if [ -n "${mpicc}" ] || [ "${progname_dir_shallow}" == "/" ]; then
                break
            fi
            progname_dir_shallow="$(dirname "${progname_dir_shallow}")"
        done
        if [ -z "${mpicc}" ]; then
            error "Could not locate mpicc at \"${mpi_dir}\""
            exit 1
        fi
        # The directory containing mpicc will be stored
        # in mpi_compilerdir.
        mpi_compilerdir="$(dirname "${mpicc}")"
        # Now use mpicc to locate the lib and include directories
        mpicc_show="$("${mpicc}" -show || :)"
        mpi_libdirs="$(echo "${mpicc_show}" | grep -o '\-L[^ ]*' || :)"
        n_mpi_libdirs=$(echo "${mpi_libdirs}" | wc -l)
        if [ ${n_mpi_libdirs} -eq 1 ]; then
            mpi_libdir="${mpi_libdirs:2}"
        else
            # Several lib directories exist. Merge them via symlinking.
            mpi_libdir_merged="${mpi_symlinkdir}/merged_lib_specified"
            mkdir -p "${mpi_libdir_merged}"
            while read mpi_libdir; do
                mpi_libdir="${mpi_libdir:2}"
                if [ -d "${mpi_libdir}" ]; then
                    for f in "${mpi_libdir}/"*; do
                        f_base="$(basename "${f}")"
                        mpi_symlink_name="${mpi_libdir_merged}/${f_base}"
                        if     [ ! -f "${mpi_symlink_name}" ] \
                            && [ ! -d "${mpi_symlink_name}" ]; then
                            ln -s "${f}" "${mpi_symlink_name}" >/dev/null 2>&1 || :
                        fi
                    done
                fi
            done <<< "${mpi_libdirs}"
            mpi_libdir="${mpi_libdir_merged}"
        fi
        if [ ! -d "${mpi_libdir}" ]; then
            error "Warning: Could not get MPI library information out of \"${mpicc}\""
            mpi_libdir="$(dirname "${mpi_compilerdir}")/lib"
        fi
        mpi_includedirs="$(echo "${mpicc_show}" | grep -o '\-I[^ ]*' || :)"
        n_mpi_includedirs=$(echo "${mpi_includedirs}" | wc -l)
        if [ ${n_mpi_includedirs} -eq 1 ]; then
            mpi_includedir="${mpi_includedirs:2}"
        else
            # Several include directories exist.
            # Merge them via symlinking.
            mpi_includedir_merged="${mpi_symlinkdir}/merged_include_specified"
            mkdir -p "${mpi_includedir_merged}"
            while read mpi_includedir; do
                mpi_includedir="${mpi_includedir:2}"
                if [ -d "${mpi_includedir}" ]; then
                    for f in "${mpi_includedir}/"*; do
                        f_base="$(basename "${f}")"
                        mpi_symlink_name="${mpi_includedir_merged}/${f_base}"
                        if     [ ! -f "${mpi_symlink_name}" ] \
                            && [ ! -d "${mpi_symlink_name}" ]; then
                            ln -s "${f}" "${mpi_symlink_name}" >/dev/null 2>&1 || :
                        fi
                    done
                fi
            done <<< "${mpi_includedirs}"
            mpi_includedir="${mpi_includedir_merged}"
        fi
        if [ ! -d "${mpi_includedir}" ]; then
            error "Warning: Could not get MPI include information out of \"${mpicc}\""
            mpi_includedir="$(dirname "${mpi_compilerdir}")/include"
        fi
        # Find the mpiexec executable, which might not be in the same
        # directory as mpicc. The mpi_bindir directory is set from the
        # mpiexec executable.
        progname_dir_shallow="${progname_dir}"
        for ((i = 0; i < 3; i += 1)); do
            mpi_bindir="$(find_recursive "${progname_dir_shallow}" "mpiexec")"
            if [ -n "${mpi_bindir}" ] || [ "${progname_dir_shallow}" == "/" ]; then
                break
            fi
            progname_dir_shallow="$(dirname "${progname_dir_shallow}")"
        done
        if [ -n "${mpi_bindir}" ]; then
            mpi_bindir="$(dirname "${mpi_bindir}")"
        else
            # Check for mpiexec in PATH
            mpiexec="$(which mpiexec 2>/dev/null || :)"
            if [ -n "${mpiexec}" ]; then
                mpi_bindir="$(dirname "${mpiexec}")"
                printf "\nMPI binary directory set to \"${mpi_bindir}\" (from PATH)\n\n"
            else
                if [ -f "${mpi_bindir}" ]; then
                    mpi_bindir="$(basename "${mpi_bindir}")"
                fi
                error "Warning: Could not locate MPI binaries at \"${mpi_dir}\", \
nor anywhere in the PATH"
                mpi_bindir="${mpi_compilerdir}"
            fi
        fi
        # Set mpi_dir
        mpi_dir_cancidates=(                     \
            "$(readlink -f "${mpi_bindir}"    )" \
            "$(readlink -f "${mpi_libdir}"    )" \
            "$(readlink -f "${mpi_includedir}")" \
        )
        N=${#mpi_dir_cancidates[@]}
        length="${#mpi_dir_cancidates[0]}"
        different="False"
        for ((j = 1; j < ${length}; j += 1)); do
            part0="${mpi_dir_cancidates[0]}"
            part0="${part0::$j}"
            for ((i = 1; i < ${N}; i += 1)); do
                part0_i="${mpi_dir_cancidates[$i]}"
                part0_i="${part0_i::$j}"
                if [ "${part0_i}" != "${part0}" ]; then
                    different="True"
                    break
                fi
            done
            if [ "${different}" == "True" ]; then
                break
            fi
        done
        ((j -= 1)) || :
        if [ ${j} -gt 1 ]; then
            mpi_dir="${mpi_dir_cancidates[0]}"
            mpi_dir="${mpi_dir::$j}"
            if [[ "${mpi_dir}" != *"/" ]]; then
                mpi_dir="$(dirname "${mpi_dir}")"
            fi
        fi
        if [ -f "${mpi_dir}" ]; then
            mpi_dir="$(dirname "${mpi_dir}")"
        fi
        if [ "$(basename "${mpi_dir}")" == "bin" ]; then
            mpi_dir="$(dirname "${mpi_dir}")"
        fi
    fi
    if [ "${progname}" == 'ncurses' ] && [ "${ncurses_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/lib/libncurses.so" ]; then
            if [ -f "${progname_dir}/../lib/libncurses.so" ]; then
                ncurses_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate ncurses at \"${ncurses_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'blas' ] && [ "${blas_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/include/cblas.h" ]; then
            if [ -f "${progname_dir}/../include/cblas.h" ]; then
                blas_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate OpenBLAS at \"${blas_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'openssl' ] && [ "${openssl_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/lib/libssl.so" ]; then
            if [ -f "${progname_dir}/../lib/libssl.so" ]; then
                openssl_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate OpenSSL at \"${openssl_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'perl' ] && [ "${perl_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/bin/perl" ]; then
            if [ -f "${progname_dir}/../bin/perl" ]; then
                perl_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate Perl at \"${perl_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'python' ] && [ "${python_preinstalled}" == "True" ]; then
        if     [ ! -f "${progname_dir}/bin/python" ] \
            && [ ! -f "${progname_dir}/bin/python3" ]; then
            if     [ -f "${progname_dir}/../bin/python" ] \
                || [ -f "${progname_dir}/../bin/python3" ]; then
                python_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate Python at \"${python_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'zlib' ] && [ "${zlib_preinstalled}" == "True" ]; then
        if [ ! -f "${progname_dir}/lib/libz.so" ]; then
            if [ -f "${progname_dir}/../lib/libz.so" ]; then
                zlib_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate zlib at \"${zlib_dir}\""
                exit 1
            fi
        fi
    fi
}
fix_path "CLASS"
fix_path "CONCEPT"
fix_path "FreeType"
fix_path "zlib"
fix_path "libpng"
fix_path "ncurses"
fix_path "BLAS"
fix_path "OpenSSL"
fix_path "libffi"
fix_path "Perl"
fix_path "Python"
fix_path "FFTW"
fix_path "GADGET"
fix_path "FFTW for GADGET"
fix_path "GSL"
fix_path "HDF5"
fix_path "MPI"
log="${log/__top_dir__/${top_dir}}"
env_file="${env_file/__top_dir__/${top_dir}}"
paths_file="${paths_file/__top_dir__/${top_dir}}"

# Set mpicc, mpi_compilerdir, mpi_bindir, mpi_libdir and mpi_includedir
# if not already set.
if [ -z "${mpicc}" ]; then
    mpicc="${mpi_dir}/bin/mpicc"
fi
if [ -z "${mpi_compilerdir}" ]; then
    mpi_compilerdir="${mpi_dir}/bin"
fi
if [ -z "${mpi_bindir}" ]; then
    mpi_bindir="${mpi_dir}/bin"
fi
if [ -z "${mpi_libdir}" ]; then
    mpi_libdir="${mpi_dir}/lib"
fi
if [ -z "${mpi_includedir}" ]; then
    mpi_includedir="${mpi_dir}/include"
fi

# Set test_log path variables
blas_test_log="${blas_dir}/test_log"  # No BLAS tests actually performed
class_test_log="${class_dir}/test_log"
concept_test_log="${concept_dir}/test_log"
fftw_test_log="${fftw_dir}/test_log"
fftw_for_gadget_test_log="${fftw_for_gadget_dir}/test_log"
freetype_test_log="${freetype_dir}/test_log"  # No FreeType tests actually performed
gadget_test_log="${gadget_dir}/test_log"
gsl_test_log="${gsl_dir}/test_log"
hdf5_test_log="${hdf5_dir}/test_log"
libffi_test_log="${libffi_dir}/lib/libffi-${libffi_version}/test_log"
libpng_test_log="${libpng_dir}/test_log"
mpi_test_log="${mpi_dir}/test_log"
ncurses_test_log="${ncurses_dir}/include/ncurses/test_log"
openssl_test_log="${openssl_dir}/include/openssl/test_log"
perl_test_log="${perl_dir}/test_log"
python_test_log="${python_dir}/test_log"
zlib_test_log="${zlib_dir}/test_log"
numpy_test_log="${python_dir}/numpy_test_log"
scipy_test_log="${python_dir}/scipy_test_log"

# Check whether this script is run locally or remotely via ssh
ssh="True"
if [ -z "${SSH_CLIENT}" ] && [ -z "${SSH_TTY}" ]; then
    ssh="False"
fi

# When running locally, set the "make_jobs" variable, holding the -j
# option for future make commands, enabling parallel building.
# Some implementations of make does not support the bare -j option
# without explicitly specifying a number afterwards. If so, we do not
# make use of the -j option.
if [ "${ssh}" == "False" ] && [ -z "${make_jobs}" ]; then
    make_jobs_test_dir="${top_dir}/tmp/make_jobs_test"
    rm -rf "${make_jobs_test_dir}" || :
    mkdir -p "${make_jobs_test_dir}"
    printf "
test:
\t@echo success
" > "${make_jobs_test_dir}/Makefile"
    make_jobs_output="$(cd "${make_jobs_test_dir}" && make -j 2>/dev/null)" || :
    if [ "${make_jobs_output}" == "success" ]; then
        make_jobs="-j"
    fi
    rm -rf "${make_jobs_test_dir}" || :
fi
# Set OMP_NUM_THREADS to 1 when running remotely,
# so that OpenMP runs serially.
if [ "${ssh}" == "True" ] && [ -z "${OMP_NUM_THREADS}" ]; then
    export OMP_NUM_THREADS=1
fi



##########################
# Dependency discovering #
##########################
current_step="discovery of dependencies"
# Flags specifying whether or not any Python packages,
# software (meaning anything but Python packages) or any of those
# should be installed.
install_any_pypackages="False"
install_any_software="False"
install_anything="False"
assume_preinstalled(){
    # Arguments: Program name (lowercase)
    eval "name_preinstalled=\"\${${1}_preinstalled}\""
    if [ "${name_preinstalled}" == "False" ]; then
        eval "${1}_preinstalled=\"True\""
        eval "${1}_dir=\"\""
        eval "${1}_version=\"pre-installed\""
    fi
}
# If Python is pre-installed, assume that OpenSSL,
# libffi and ncurses are also pre-installed.
if [ "${python_preinstalled}" == "True" ]; then
    assume_preinstalled "openssl"
    assume_preinstalled "libffi"
    assume_preinstalled "ncurses"
fi
# If OpenSSL is pre-installed, assume that Perl is also pre-installed
if [ "${openssl_preinstalled}" == "True" ]; then
    assume_preinstalled "perl"
fi

# Function that checks whether a given Python package
# is installed or not.
check_pypackage_installed(){
    # Arguments: Python package name
    current_dir="$(pwd)"
    cd "${top_dir}"
    # Some Python packages may need access to libraries at runtime
    current_LD_LIBRARY_PATH="${LD_LIBRARY_PATH}"
    for lib in "blas" "gsl" "hdf5" "libpng" "mpi" "zlib"; do
        eval "lib_dir=\"\${${lib}_dir}/lib\""
        if [ -d "${lib_dir}" ]; then
            export LD_LIBRARY_PATH="${lib_dir}:${LD_LIBRARY_PATH}"
        fi
    done
    "${python}" -c "
from time import sleep
try:
    if '${1}' == 'cythongsl':
        # CythonGSL has an extra underscore when importing
        import cython_gsl
    elif '${1}' == 'mpi4py':
        # For MPI4Py we do a more thorough test
        import mpi4py
        from mpi4py import MPI
    else:
        import ${1}
    sleep(1)
    print('\nTrue')
except:
    print('\nFalse')
" 2>/dev/null | tail -n 1
    cd "${current_dir}"
    export LD_LIBRARY_PATH="${current_LD_LIBRARY_PATH}"
}

# Set "pypackage"_preinstalled variables
blessings_preinstalled="False"
cython_preinstalled="False"
cythongsl_preinstalled="False"
h5py_preinstalled="False"
matplotlib_preinstalled="False"
mpi4py_preinstalled="False"
numpy_preinstalled="False"
pytest_preinstalled="False"
scipy_preinstalled="False"
pip_preinstalled="False"
if [ "${python_preinstalled}" == "True" ]; then
    python=$(ls -1 "${python_dir}/bin/python"* | head -n 1)
    for pypackage in blessings     \
                     cython        \
                     cythongsl     \
                     h5py          \
                     matplotlib    \
                     mpi4py        \
                     numpy         \
                     pytest        \
                     scipy         \
                     pip; do
        pypackage_preinstalled=$(check_pypackage_installed ${pypackage})
        eval "${pypackage}_preinstalled=\"${pypackage_preinstalled}\""
    done
fi

# Variables telling whether or not a program needs to be installed.
# COùòïCEPT (install by default)
if [ -z "${concept_install}" ]; then
    concept_install="False"
    if [ "${concept_preinstalled}" == "False" ]; then
        concept_install="True"
    fi
fi
# CLASS (needed by COùòïCEPT)
if [ -z "${class_install}" ]; then
    class_install="False"
    if [ "${class_preinstalled}" == "False" ] && [ "${concept_install}" == "True" ]; then
        class_install="True"
    fi
fi
# GADGET (needed by COùòïCEPT)
if [ -z "${gadget_install}" ]; then
    gadget_install="False"
    if [ "${gadget_preinstalled}" == "False" ] && [ "${concept_install}" == "True" ]; then
        gadget_install="True"
    fi
fi
# FFTW for GADGET (needed by GADGET)
if [ -z "${fftw_for_gadget_install}" ]; then
    fftw_for_gadget_install="False"
    if [ "${fftw_for_gadget_preinstalled}" == "False" ] && [ "${gadget_install}" == "True" ]; then
        fftw_for_gadget_install="True"
    fi
fi
# Python (needed by COùòïCEPT and CLASS)
if [ -z "${python_install}" ]; then
    python_install="False"
    if [ "${python_preinstalled}" == "False" ] \
        && ([ "${concept_install}" == "True" ] || [ "${class_install}" == "True" ]); then
        python_install="True"
    fi
fi
# Python packages (needed by CLASS and COùòïCEPT)
if [ -z "${pip_install}" ]; then
    # Always install pip if Python is to be installed
    pip_install="False"
    if [ "${python_install}" == "True" ]; then
        pip_install="True"
    fi
fi
for pypackage in blessings     \
                 cython        \
                 cythongsl     \
                 h5py          \
                 matplotlib    \
                 mpi4py        \
                 numpy         \
                 pytest        \
                 scipy; do
    eval "pypackage_install=\"\${${pypackage}_install}\""
    if [ -z "${pypackage_install}" ]; then
        eval "${pypackage}_install=\"False\""
        eval "pypackage_preinstalled=\"\${${pypackage}_preinstalled}\""
        if [ "${pypackage_preinstalled}" == "False" ] && [ "${concept_install}" == "True" ]; then
            eval "${pypackage}_install=\"True\""
        fi
    fi
done
# FFTW (needed by COùòïCEPT)
if [ -z "${fftw_install}" ]; then
    fftw_install="False"
    if [ "${fftw_preinstalled}" == "False" ] && [ "${concept_install}" == "True" ]; then
        fftw_install="True"
    fi
fi
# HDF5 (needed by COùòïCEPT)
if [ -z "${hdf5_install}" ]; then
    hdf5_install="False"
    if [ "${hdf5_preinstalled}" == "False" ] && [ "${concept_install}" == "True" ]; then
        hdf5_install="True"
    fi
fi
# MPI (needed by COùòïCEPT)
if [ -z "${mpi_install}" ]; then
    mpi_install="False"
    if [ "${mpi_preinstalled}" == "False" ] && [ "${concept_install}" == "True" ]; then
        mpi_install="True"
    fi
fi
# GSL (needed by COùòïCEPT)
if [ -z "${gsl_install}" ]; then
    gsl_install="False"
    if [ "${gsl_preinstalled}" == "False" ] && [ "${concept_install}" == "True" ]; then
        gsl_install="True"
    fi
fi
# libpng (needed by matplotlib)
if [ -z "${libpng_install}" ]; then
    libpng_install="False"
    if [ "${libpng_preinstalled}" == "False" ] && [ "${matplotlib_install}" == "True" ]; then
        libpng_install="True"
    fi
fi
# zlib (needed by HDF5, libpng and Python)
if [ -z "${zlib_install}" ]; then
    zlib_install="False"
    if [ "${zlib_preinstalled}" == "False" ] && \
        (   [ "${hdf5_install}"   == "True" ] \
         || [ "${libpng_install}" == "True" ] \
         || [ "${python_install}" == "True" ]); then
        zlib_install="True"
    fi
fi
# FreeType (needed by matplotlib)
if [ -z "${freetype_install}" ]; then
    freetype_install="False"
    if [ "${freetype_preinstalled}" == "False" ] && [ "${matplotlib_install}" == "True" ]; then
        freetype_install="True"
    fi
fi
# ncurses (needed by Python, if Python is needed by COùòïCEPT)
if [ -z "${ncurses_install}" ]; then
    ncurses_install="False"
    if [ "${ncurses_preinstalled}" == "False" ] && [ "${python_install}"  == "True" ] \
        && [ "${concept_install}" == "True" ]; then
        ncurses_install="True"
    fi
fi
# BLAS (needed by NumPy and SciPy)
if [ -z "${blas_install}" ]; then
    blas_install="False"
    if [ "${blas_preinstalled}" == "False" ] \
        && ([ "${numpy_install}" == "True" ] || [ "${scipy_install}" == "True" ]); then
        blas_install="True"
    fi
fi
# OpenSSL (needed by pip)
if [ -z "${openssl_install}" ]; then
    openssl_install="False"
    if [ "${openssl_preinstalled}" == "False" ] && [ "${pip_install}" == "True" ]; then
        openssl_install="True"
    fi
fi
# libffi (needed by pip)
if [ -z "${libffi_install}" ]; then
    libffi_install="False"
    if [ "${libffi_preinstalled}" == "False" ] && [ "${pip_install}" == "True" ]; then
        libffi_install="True"
    fi
fi
# Perl (needed by OpenSSL)
if [ -z "${perl_install}" ]; then
    perl_install="False"
    if [ "${perl_preinstalled}" == "False" ] && [ "${openssl_install}" == "True" ]; then
        perl_install="True"
    fi
fi
# The install_any_software, install_any_pypackages
# and install_anything variables.
if     [ "${concept_install}"         == "True" ] \
    || [ "${blas_install}"            == "True" ] \
    || [ "${class_install}"           == "True" ] \
    || [ "${gadget_install}"          == "True" ] \
    || [ "${fftw_for_gadget_install}" == "True" ] \
    || [ "${python_install}"          == "True" ] \
    || [ "${fftw_install}"            == "True" ] \
    || [ "${hdf5_install}"            == "True" ] \
    || [ "${mpi_install}"             == "True" ] \
    || [ "${gsl_install}"             == "True" ] \
    || [ "${libpng_install}"          == "True" ] \
    || [ "${zlib_install}"            == "True" ] \
    || [ "${freetype_install}"        == "True" ] \
    || [ "${ncurses_install}"         == "True" ] \
    || [ "${openssl_install}"         == "True" ] \
    || [ "${libffi_install}"          == "True" ] \
    || [ "${perl_install}"            == "True" ]; then
        install_any_software="True"
fi
if     [ "${blessings_install}"       == "True" ] \
    || [ "${cython_install}"          == "True" ] \
    || [ "${cythongsl_install}"       == "True" ] \
    || [ "${h5py_install}"            == "True" ] \
    || [ "${matplotlib_install}"      == "True" ] \
    || [ "${mpi4py_install}"          == "True" ] \
    || [ "${numpy_install}"           == "True" ] \
    || [ "${pytest_install}"          == "True" ] \
    || [ "${scipy_install}"           == "True" ]; then
        install_any_pypackages="True"
fi
if [ "${install_any_software}" == "True" ] || [ "${install_any_pypackages}" == "True" ]; then
    install_anything="True"
fi



###########################
# Beginning of subprocess #
log_file_lines_before_install=0
if [ -f "${log}" ]; then
    log_file_lines_before_install=$(wc -l "${log}" | awk '{print $1}')
fi
# The stdout of the (background) subprocess below will be redirected
# into ${log}, which in read back in and echoed to the TTY. The system
# will keep track of the current installation step and always display
# this at the bottom, which is the whole reason for not just tee'ing
# stdout directly to ${log}.
# To also log stderr, we tee this into ${log}_err.
( ( (
# Set up error trapping
ctrl_c_subprocess(){
    trap : 0
    ctrl_c
    exit 0
}
abort_subprocess(){
    trap : 0
    if [ "${current_step}" != "aborting" ]; then
        error "An error occurred during ${current_step}!"
    fi
    abort
    exit 0
}
trap 'ctrl_c_subprocess' SIGINT
trap 'abort_subprocess' EXIT
set -e

# Ensure new line in log after possible previous failed attempt
echo

# Functions for controlling the current status
set_status(){
    echo "${status_prefix}${1}"
}
disable_status(){
    echo "${status_prefix}${status_disable}"
}
enable_status(){
    echo "${status_prefix}${status_enable}"
}
successfully_finish_status(){
    echo "${status_prefix}${status_finish_successfully}"
}
# These are needed to get the spacing right in the output
current_step="initialisation"
set_status "Initialising"



#############################
# URL's to all the software #
#############################
# In this section, ${progame_url} are defined for each program.
# In order for the rest of this script to work, these URLs must point
# to archives containing a single top-level directory.

# Function for checking that a given url actually exists
validate_url(){
    # Arguments: Program name, [exit on error ("True" or "False")]
    progname="$(echo "${1}" | tr '[:upper:]' '[:lower:]')"
    progname="${progname// /_}"
    exit_on_error="True"
    if [ -n "$2" ]; then
        exit_on_error="$2"
    fi
    if [ "${progname}" == "mpi" ]; then
        if [ "${mpi}" == "mpich" ]; then
            current_step="validation of MPICH link"
            set_status "Validating MPICH link"
        elif [ "${mpi}" == "openmpi" ]; then
            current_step="validation of OpenMPI link"
            set_status "Validating OpenMPI link"
        fi
    else
        current_step="validation of ${1/CONCEPT/$esc_concept} link"
        set_status "Validating ${1/CONCEPT/${esc_concept}} link"
    fi
    url="$(eval "echo \"\${${progname}_url}\"")"
    filename="$(basename "${url}")"
    mkdir -p "${top_dir}/tmp"
    for n in {1..3}; do
        for ipv in "--inet4-only" "--inet6-only" ""; do
            wget_status="success"
            if [[ "${url}" == "ftp://"* ]]; then
                # wget do not always return with a non-zero status on
                # failure when using ftp.
                (cd "${top_dir}/tmp"
                 wget -t 1 --timeout 30 --no-check-certificate --no-dns-cache --spider \
                      --no-remove-listing ${ipv} "${url}" > "${top_dir}/tmp/.wget" 2>&1 || :)
                grep "${filename}" "${top_dir}/tmp/.listing" > /dev/null 2>&1 \
                     || wget_status="error"
                rm -f "${top_dir}/tmp/.listing" || :
            else
                wget -t 1 --timeout 30 --no-check-certificate --no-dns-cache --spider ${ipv} \
                     "${url}" > "${top_dir}/tmp/.wget" 2>&1 || wget_status="error"
            fi
            if [ "${wget_status}" == "error" ]; then
                # Heavy scraping can result in bans, indicated by a
                # "429 Too Many Requests" error. This does not mean
                # that we cannot download the file, just that the
                # spider has been disallowed by the server.
                if grep "429" "${top_dir}/tmp/.wget" >/dev/null 2>&1; then
                    wget_status="success"
                fi
            fi
            rm -f "${top_dir}/tmp/.wget" || :
            if [ "${wget_status}" == "success" ]; then
                break
            fi
        done
        if [ "${wget_status}" == "success" ]; then
            break
        fi
        sleep 1
    done
    validate_url_status="${wget_status}"
    if [ "${exit_on_error}" == "True" ]; then
        if [ "${wget_status}" != "success" ]; then
            error "Error: The ${1} link is broken: ${url}"
            exit 1
        fi
    fi
}

# Function for letting versions fall back to their secondary,
# fallback values, in case of unsuccessful retrievel of primary version.
fallback(){
    # Arguments: Program name
    progname="$(echo "${1}" | tr '[:upper:]' '[:lower:]')"
    progname="${progname// /_}"
    eval "progname_version=\"\${${progname}_version}\""
    eval "progname_version_fallback=\"\${${progname}_version_fallback}\""
    if [ "${progname}" == "mpi" ]; then
        if [ "${mpi}" == "mpich" ]; then
            realname="MPICH"
        elif [ "${mpi}" == "openmpi" ]; then
            realname="OpenMPI"
        fi
    else
        realname="${1}"
    fi
    if [ "${progname_version}" != "${progname_version_fallback}" ]; then
        echo "Falling back to ${realname} version ${progname_version_fallback}"
    fi
    progname_version="${progname_version_fallback}"
    eval "${progname}_version=\"\${progname_version}\""
    eval "${progname}_version_fallback=\"\${progname_version_fallback}\""
}

# Function which checks the download and installation progress
# of all the programs based on helper files created by previous
# invocations of this script. The function is called with the program
# name (progname) as the argument and it will set the variables
# progname_downloaded, progname_installed and progname_test_success
# to either "True" or "False".
check_progress(){
    # Arguments: Program name
    progname_display="${1/CONCEPT/${esc_concept}}"
    progname="${1// /_}"
    progname="$(echo "${progname}" | tr '[:upper:]' '[:lower:]')"
    # The program installation directory
    eval "progdir=\"\${${progname}_dir}\""
    # COùòïCEPT itself will not have a .installation_finished file in its
    # directory. Instead it uses the .installation_finished in the
    # GADGET directory.
    if [ "${progname}" == "concept" ]; then
        progdir="${gadget_dir}"
    fi
    # The program version
    eval "progversion=\"\${${progname}_version}\""
    # If the program has already been fully installed, a file called
    # .installation_finished will be placed in the program installation
    # directory. Note that some programs share a common installation
    # directory and thefore also a common .installation_finished file.
    eval "${progname}_installed=\"False\""
    if [ -f "${progdir}/.installation_finished" ]; then
        while read line; do
            prog_prev="$(echo "${line}" | grep  '^Program:*'     \
                                        | sed 's/^Program:\s//g' \
                                        | sed 's/^ *//')"
            if [ -n "${prog_prev}" ]; then
                prog_prev_real="${prog_prev// /_}"
                prog_prev_real="$(echo "${prog_prev_real}" | tr '[:upper:]' '[:lower:]')"
            fi
            version_prev="$(echo "${line}" | grep  '^Version:*'     \
                                           | sed 's/^Version:\s//g' \
                                           | sed 's/^ *//')"
            if [ -n "${version_prev}" ]; then
                version_prev_real="${version_prev}"
            fi
            test_results_prev="$(echo "${line}" | grep  '^Test results:*'     \
                                                | sed 's/^Test results:\s//g' \
                                                | sed 's/^ *//')"
            if [ -n "${test_results_prev}" ]; then
                test_results_prev_real="${test_results_prev}"
            fi
            if [ "${prog_prev_real}" == "${progname}" ]; then
                if [ "${version_prev_real}" == "${progversion}" ]; then
                    eval "${progname}_installed=\"True\""
                    if [ -n "${test_results_prev_real}" ]; then
                        if [ "${test_results_prev}" == "Success" ]; then
                            eval "${progname}_test_success=\"True\""
                        elif [ "${test_results_prev_real}" == "Failure" ]; then
                            eval "${progname}_test_success=\"False\""
                        fi
                    fi
                    # Installed programs should always count as downloaded
                    eval "${progname}_downloaded=\"True\""
                    return
                fi
                # Progam already installed but of incorrect version.
                # Count as uninstalled.
                break
            fi
        done <<< "$(tac "${progdir}/.installation_finished")"
    fi
    # If the program is not yet installed fully, remove its directory,
    # cleaning up after any previous failed installation attempts.
    if [ "${progname}" == "gadget" ]; then
        # FFTW for GADGET is placed inside the GADGET directory
        if [ -d "${gadget_dir}/fftw" ]; then
            mv "${gadget_dir}/fftw" "${gadget_dir}/.fftw"
        fi
        if [ -d "${gadget_dir}" ] && [ -n "$(ls "${gadget_dir}")" ]; then
            printf "Cleaning up ${progname_display} directory ..."
            rm -rf "${gadget_dir}/"* || :
            printf " done\n"
        fi
        if [ -d "${gadget_dir}/.fftw" ]; then
            mv "${gadget_dir}/.fftw" "${gadget_dir}/fftw"
        fi
        if [ -d "${gadget_dir}" ] && [ -z "$(ls -A "${gadget_dir}")" ]; then
            rm -rf "${gadget_dir}" || :
        fi
    elif [ "${progname}" == "python" ]; then
        # Files from ncurses, OpenSSL and libffi are placed all around
        # in ${python_dir}, so we cannot just delete this directory.
        :
    elif [ "${progname}" == "ncurses" ]; then
        if [ -d "${python_dir}/include/ncurses" ]; then
            printf "Cleaning up ${progname_display} directory ..."
            rm -rf "${python_dir}/include/ncurses" || :
            printf " done\n"
        fi
    elif [ "${progname}" == "openssl" ]; then
        if [ -d "${python_dir}/include/openssl" ]; then
            printf "Cleaning up ${progname_display} directory ..."
            rm -rf "${python_dir}/include/openssl" || :
            printf " done\n"
        fi
    elif [ "${progname}" == "libffi" ]; then
        for f in "${python_dir}/lib/libffi"*; do
            if [ -d "${f}" ]; then
                printf "Cleaning up ${progname_display} directory ..."
                rm -rf "${python_dir}/lib/libffi"* || :
                printf " done\n"
                break
            fi
        done
    elif [ "${progname}" == "concept" ]; then
        # In the case of COùòïCEPT, ${progdir} is set to
        # the GADGET directory.
        if [ -d "${concept_dir}" ]; then
            printf "Cleaning up ${progname_display} directory ..."
            rm -rf "${concept_dir}" || :
            printf " done\n"
        fi
    else
        # The files of all other programs live isolated
        # in their very own dedicated directory.
        if [ -d "${progdir}" ]; then
            printf "Cleaning up ${progname_display} directory ..."
            rm -rf "${progdir}" || :
            printf " done\n"
        fi
    fi
    # The url to the installation file for this program
    eval "url=\"\${${progname}_url}\""
    # The directory for the downloaded file
    download_dir="${top_dir}/tmp/${progname}"
    # If the source file has already been downloaded fully, a file
    # called .download_finished will be placed in the download_dir with
    # information about this file.
    eval "${progname}_downloaded=\"False\""
    if [ -f "${download_dir}/.download_finished" ]; then
        file_prev="$(grep "^File:*" "${download_dir}/.download_finished" | sed 's/^File:\s//g' \
                                                                         | sed 's/^ *//')"
        url_prev="$( grep "^URL:*"  "${download_dir}/.download_finished" | sed 's/^URL:\s//g' \
                                                                         | sed 's/^ *//')"
        if [ -f "${download_dir}/${file_prev}" ] && [ "${url_prev}" == "${url}" ]; then
            eval "${progname}_downloaded=\"True\""
        fi
    fi
}

# COùòïCEPT
if [ "${concept_install}" == "True" ]; then
    # Either download the current state of the master branch
    # or a specific release.
    if [ "${concept_version}" == "master" ]; then
        concept_url="https://github.com/jmd-dk/concept/archive/${concept_version}.tar.gz"
    else
        concept_version="${concept_version/v/}"
        concept_url="https://github.com/jmd-dk/concept/archive/v${concept_version}.tar.gz"
    fi
    # Check if already downloaded/installed
    check_progress "CONCEPT"
    # If not yet downloaded, validate the URL
    if [ "${concept_downloaded}" != "True" ]; then
        validate_url "CONCEPT" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary COùòïCEPT link broken: ${concept_url}"
            error "Error: The installer does not know of a secondary COùòïCEPT link"
            exit 1
        fi
    fi
fi

# CLASS
if [ "${class_install}" == "True" ]; then
    # Either download specific release or specific branch
    current_step="processing of CLASS link"
    dots="${class_version//[^.]}"
    ndots="${#dots}"
    if [ "${ndots}" == 1 ]; then
        class_url="https://github.com/lesgourg/class_public/archive/${class_version}.tar.gz"
    elif [ "${ndots}" == 2 ]; then
        class_version=${class_version/v/}
        class_url="https://github.com/lesgourg/class_public/archive/v${class_version}.tar.gz"
    else
        error "No CLASS URL known for version ${class_version}"
        exit 1
    fi
    # Check if already installed/downloaded
    check_progress "CLASS"
    # If not yet downloaded, validate the URL
    if [ "${class_downloaded}" != "True" ]; then
        validate_url "CLASS" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary CLASS link broken: ${class_url}"
            error "Error: The installer does not know of a secondary CLASS link"
            exit 1
        fi
    fi
fi

# FFTW
if [ "${fftw_install}" == "True" ]; then
    fftw_url="http://www.fftw.org/fftw-${fftw_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "FFTW"
    # If not yet downloaded, validate the URL
    if [ "${fftw_downloaded}" != "True" ]; then
        validate_url "FFTW" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary FFTW link broken: ${fftw_url}"
            fallback "FFTW"
            fftw_url="ftp://ftp.fftw.org/pub/fftw/fftw-${fftw_version}.tar.gz"
            echo "Using secondary FFTW link: ${fftw_url}"
            # Check if already installed and/or downloaded
            check_progress "FFTW"
            # If not yet downloaded, validate the URL
            if [ "${fftw_downloaded}" != "True" ]; then
                validate_url "FFTW"
            fi
        fi
    fi
fi

# FFTW for GADGET
if [ "${fftw_for_gadget_install}" == "True" ]; then
    fftw_for_gadget_url="http://www.fftw.org/fftw-${fftw_for_gadget_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "FFTW for GADGET"
    # If not yet downloaded, validate the URL
    if [ "${fftw_for_gadget_downloaded}" != "True" ]; then
        validate_url "FFTW for GADGET" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary FFTW 2 link broken: ${fftw_for_gadget_url}"
            fallback "FFTW for GADGET"
            fftw_for_gadget_url="ftp://ftp.fftw.org/pub/fftw/\
fftw-${fftw_for_gadget_version}.tar.gz"
            echo "Using secondary FFTW 2 link: ${fftw_for_gadget_url}"
            # Check if already installed and/or downloaded
            check_progress "FFTW for GADGET"
            # If not yet downloaded, validate the URL
            if [ "${fftw_for_gadget_downloaded}" != "True" ]; then
                validate_url "FFTW for GADGET"
            fi
        fi
    fi
fi

# FreeType
if [ "${freetype_install}" == "True" ]; then
    freetype_url="http://download.savannah.gnu.org/releases/freetype/\
freetype-${freetype_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "FreeType"
    # If not yet downloaded, validate the URL
    if [ "${freetype_downloaded}" != "True" ]; then
        validate_url "FreeType" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary FreeType link broken: ${freetype_url}"
            fallback "freetype"
            freetype_url="http://sourceforge.net/projects/freetype/files/freetype2/\
${freetype_version}/freetype-${freetype_version}.tar.gz"
            echo "Using secondary FreeType link: ${freetype_url}"
            # Check if already installed and/or downloaded
            check_progress "FreeType"
            # If not yet downloaded, validate the URL
            if [ "${freetype_downloaded}" != "True" ]; then
                validate_url "FreeType"
            fi
        fi
    fi
fi

# GADGET
if [ "${gadget_install}" == "True" ]; then
    gadget_url="http://www.mpa-garching.mpg.de/gadget/gadget-${gadget_version}.tar.gz"
    # Check if already installed/downloaded
    check_progress "GADGET"
    # If not yet downloaded, validate the URL
    if [ "${gadget_downloaded}" != "True" ]; then
        validate_url "GADGET" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary GADGET link broken: ${gadget_url}"
            error "Error: The installer does not know of a secondary GADGET link"
            exit 1
        fi
    fi
fi

# GSL
if [ "${gsl_install}" == "True" ]; then
    gsl_url="ftp://ftp.gnu.org/gnu/gsl/gsl-${gsl_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "GSL"
    # If not yet downloaded, validate the URL
    if [ "${gsl_downloaded}" != "True" ]; then
        validate_url "GSL" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary GSL link broken: ${gsl_url}"
            fallback "GSL"
            gsl_url="http://ftpmirror.gnu.org/gsl/gsl-${gsl_version}.tar.gz"
            echo "Using secondary gsl link: ${gsl_url}"
            # Check if already installed and/or downloaded
            check_progress "GSL"
            # If not yet downloaded, validate the URL
            if [ "${gsl_downloaded}" != "True" ]; then
                validate_url "GSL"
            fi
        fi
    fi
fi

# HDF5
if [ "${hdf5_install}" == "True" ]; then
    hdf5_version_major="$(echo "${hdf5_version}" | grep -o '[0-9]\.[0-9]*')"
    hdf5_url="https://support.hdfgroup.org/ftp/HDF5/releases/hdf5-${hdf5_version_major}/\
hdf5-${hdf5_version}/src/hdf5-${hdf5_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "HDF5"
    # If not yet downloaded, validate the URL
    if [ "${hdf5_downloaded}" != "True" ]; then
        validate_url "HDF5" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary HDF5 link broken: ${hdf5_url}"
            fallback "HDF5"
            hdf5_version_major="$(echo "${hdf5_version}" | grep -o '[0-9]\.[0-9]*')"
            hdf5_url="https://support.hdfgroup.org/ftp/HDF5/releases/hdf5-${hdf5_version_major}/\
hdf5-${hdf5_version}/src/hdf5-${hdf5_version}.tar.gz"
            echo "Using secondary HDF5 link: ${hdf5_url}"
            # Check if already installed and/or downloaded
            check_progress "HDF5"
            # If not yet downloaded, validate the URL
            if [ "${hdf5_downloaded}" != "True" ]; then
                validate_url "HDF5"
            fi
        fi
    fi
fi

# libpng
if [ "${libpng_install}" == "True" ]; then
    # For e.g. libpng_version 1.6.18, libpng_version_majors is 16
    libpng_url="http://prdownloads.sourceforge.net/libpng/libpng-${libpng_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "libpng"
    # If not yet downloaded, validate the URL
    if [ "${libpng_downloaded}" != "True" ]; then
        validate_url "libpng" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary libpng link broken: ${libpng_url}"
            fallback "libpng"
            libpng_version_majors="$(echo "${libpng_version}" | grep -m 1 -o -P "[0-9]*\.[0-9]*" \
                                                              | head -n 1)"
            libpng_version_majors="$(echo "${libpng_version_majors//./}")"
            libpng_url="http://sourceforge.net/projects/libpng/files/\
libpng${libpng_version_majors}/older-releases/${libpng_version}/libpng-${libpng_version}.tar.gz"
            echo "Using secondary libpng link: ${libpng_url}"
            # Check if already installed and/or downloaded
            check_progress "libpng"
            # If not yet downloaded, validate the URL
            if [ "${libpng_downloaded}" != "True" ]; then
                validate_url "libpng"
            fi
        fi
    fi
fi

# MPI
if [ "${mpi_install}" == "True" ]; then
    if [ "${mpi}" == "mpich" ]; then
        # MPICH
        mpi_url="http://www.mpich.org/static/downloads/${mpi_version}/mpich-${mpi_version}.tar.gz"
        # Check if already installed and/or downloaded
        check_progress "MPI"
        # If not yet downloaded, validate the URL
        if [ "${mpi_downloaded}" != "True" ]; then
            validate_url "MPI" "False"
            if [ "${validate_url_status}" != "success" ]; then
                echo "Primary MPICH link broken: ${mpi_url}"
                fallback "MPI"
                mpi_url="http://fossies.org/linux/misc/mpich-${mpi_version}.tar.gz"
                echo "Using secondary MPICH link: ${mpi_url}"
                # Check if already installed and/or downloaded
                check_progress "MPI"
                # If not yet downloaded, validate the URL
                if [ "${mpi_downloaded}" != "True" ]; then
                    validate_url "MPI"
                fi
            fi
        fi
    elif [ "${mpi}" == "openmpi" ]; then
        # OpenMPI
        mpi_version_major="$(echo "${mpi_version}" | grep -m 1 -o -P "[0-9]*" \
                                                   | head -n 1)"
        mpi_version_major_dot_minor="$(echo "${mpi_version}" | grep -m 1 -o -P \
                                            "${mpi_version_major}\.[0-9]*")"
        mpi_url="https://www.open-mpi.org/software/ompi/v${mpi_version_major_dot_minor}/\
downloads/openmpi-${mpi_version}.tar.gz"
        # Check if already installed and/or downloaded
        check_progress "MPI"
        # If not yet downloaded, validate the URL
        if [ "${mpi_downloaded}" != "True" ]; then
            validate_url "MPI" "False"
            if [ "${validate_url_status}" != "success" ]; then
                echo "Primary OpenMPI link broken: ${mpi_url}"
                error "Error: The installer does not know of a secondary OpenMPI link"
                exit 1
            fi
        fi
    fi
fi

# ncurses
if [ "${ncurses_install}" == "True" ]; then
    ncurses_url="http://ftp.gnu.org/gnu/ncurses/ncurses-${ncurses_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "ncurses"
    # If not yet downloaded, validate the URL
    if [ "${ncurses_downloaded}" != "True" ]; then
        validate_url "ncurses" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary ncurses link broken: ${ncurses_url}"
            fallback "ncurses"
            ncurses_url="http://ftpmirror.gnu.org/ncurses/ncurses-${ncurses_version}.tar.gz"
            echo "Using secondary ncurses link: ${ncurses_url}"
            # Check if already installed and/or downloaded
            check_progress "ncurses"
            # If not yet downloaded, validate the URL
            if [ "${ncurses_downloaded}" != "True" ]; then
                validate_url "ncurses"
            fi
        fi
    fi
fi

# BLAS
if [ "${blas_install}" == "True" ]; then
    blas_url="https://github.com/xianyi/OpenBLAS/archive/v${blas_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "BLAS"
    # If not yet downloaded, validate the URL
    if [ "${blas_downloaded}" != "True" ]; then
        validate_url "BLAS" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary OpenBLAS link broken: ${blas_url}"
            fallback "blas"
            blas_url="https://sourceforge.net/projects/openblas/files/v${blas_version}/\
OpenBLAS%20${blas_version}%20version.tar.gz"
            echo "Using secondary BLAS link: ${blas_url}"
            # Check if already installed and/or downloaded
            check_progress "BLAS"
            # If not yet downloaded, validate the URL
            if [ "${blas_downloaded}" != "True" ]; then
                validate_url "BLAS"
            fi
        fi
    fi
fi

# OpenSSL
if [ "${openssl_install}" == "True" ]; then
    openssl_url="https://www.openssl.org/source/openssl-${openssl_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "OpenSSL"
    # If not yet downloaded, validate the URL
    if [ "${openssl_downloaded}" != "True" ]; then
        validate_url "OpenSSL" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary OpenSSL link broken: ${openssl_url}"
            fallback "openssl"
            openssl_version_underscores="$(echo "${openssl_version}" | tr '.' '_')"
            openssl_url="https://github.com/openssl/openssl/archive/\
OpenSSL_${openssl_version_underscores}.tar.gz"
            echo "Using secondary OpenSSL link: ${openssl_url}"
            # Check if already installed and/or downloaded
            check_progress "OpenSSL"
            # If not yet downloaded, validate the URL
            if [ "${openssl_downloaded}" != "True" ]; then
                validate_url "OpenSSL"
            fi
        fi
    fi
fi

# libffi
if [ "${libffi_install}" == "True" ]; then
    libffi_url="ftp://sourceware.org/pub/libffi/libffi-${libffi_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "libffi"
    # If not yet downloaded, validate the URL
    if [ "${libffi_downloaded}" != "True" ]; then
        validate_url "libffi" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary libffi link broken: ${libffi_url}"
            fallback "libffi"
            libffi_url="https://sourceware.org/ftp/libffi/libffi-${libffi_version}.tar.gz"
            echo "Using secondary libffi link: ${libffi_url}"
            # Check if already installed and/or downloaded
            check_progress "libffi"
            # If not yet downloaded, validate the URL
            if [ "${libffi_downloaded}" != "True" ]; then
                validate_url "libffi"
            fi
        fi
    fi
fi

# Perl
if [ "${perl_install}" == "True" ]; then
    perl_url="http://www.cpan.org/src/5.0/perl-${perl_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "Perl"
    # If not yet downloaded, validate the URL
    if [ "${perl_downloaded}" != "True" ]; then
        validate_url "Perl" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary Perl link broken: ${perl_url}"
            error "Error: The installer does not know of a secondary Perl link"
            exit 1
        fi
    fi
fi

# Python
if [ "${python_install}" == "True" ]; then
    python_url="https://www.python.org/ftp/python/${python_version}/Python-${python_version}.tgz"
    # Check if already installed and/or downloaded
    check_progress "Python"
    # If not yet downloaded, validate the URL
    if [ "${python_downloaded}" != "True" ]; then
        validate_url "Python" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary Python link broken: ${python_url}"
            error "Error: The installer does not know of a secondary Python link"
            exit 1
        fi
    fi
fi

# zlib
if [ "${zlib_install}" == "True" ]; then
    zlib_url="http://sourceforge.net/projects/libpng/files/zlib/${zlib_version}/\
zlib-${zlib_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "zlib"
    # If not yet downloaded, validate the URL
    if [ "${zlib_downloaded}" != "True" ]; then
        validate_url "zlib" "False"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary zlib link broken: ${zlib_url}"
            fallback "zlib"
            zlib_url="http://zlib.net/zlib-${zlib_version}.tar.gz"
            echo "Using secondary zlib link: ${zlib_url}"
            # Check if already installed and/or downloaded
            check_progress "zlib"
            # If not yet downloaded, validate the URL
            if [ "${zlib_downloaded}" != "True" ]; then
                validate_url "zlib"
            fi
        fi
    fi
fi

# Set "pypackage"_installed variables
blessings_installed="False"
cython_installed="False"
cythongsl_installed="False"
h5py_installed="False"
matplotlib_installed="False"
mpi4py_installed="False"
numpy_installed="False"
pytest_installed="False"
scipy_installed="False"
pip_installed="False"
if [ -n "${python_dir}" ]; then
    for python_version_major in 3 2; do
        if [ -f "${python_dir}/bin/python${python_version_major}" ]; then
            python_version_major_dot_minor=$("${python_dir}/bin/python${python_version_major}" -c \
                "from sys import version_info as v; print(str(v.major) + '.' + str(v.minor))")
            python="${python_dir}/bin/python${python_version_major_dot_minor}"
            break
        fi
    done
fi
if [ -n "${python}" ] && [ "${python_installed}" == "True" ]; then
    for pypackage in blessings   \
                     cython      \
                     cythongsl   \
                     h5py        \
                     matplotlib  \
                     mpi4py      \
                     numpy       \
                     pytest      \
                     scipy       \
                     pip; do
        pypackage_installed=$(check_pypackage_installed ${pypackage})
        eval "${pypackage}_installed=\"${pypackage_installed}\""
    done
fi

# Functions for printing out nice tables (these are superior to the
# "column" command on older systems, as this does not handle
# formatted output very well).
modify_element(){
    # Arguments: Character to be replaced, character to replace with
    for ((i = 0; i < nelements; i += 1)); do
        element="${table_to_print[i]}"
        table_to_print[i]="${element//$1/$2}"
    done
}
print_table(){
    # Arguments: Array to be printed (passed as array[@]),
    #            number of columns.
    table_to_print=("${!1}")
    nelements=${#table_to_print[@]}
    nc=${2}
    # Replace spaces with tildes
    modify_element " " "~"
    # Backup of table
    table_with_esc=("${table_to_print[@]}")
    # Remove escape sequences in table
    for format in "normal" "bold" "italic" "no_italic" "green" "blue"; do
        eval "esc_format=\${esc_${format}}"
        modify_element "$(echo "${esc_format}" | sed 's,\\,\\\\,g')" ""
    done
    # Determine largest length of each column
    maxlengths=($(for i in $(eval "echo {1..${nc}}"); do echo 0; done))
    c=0
    for ((i = 0; i < nelements; i += 1)); do
        length=${#table_to_print[i]}
        [ ${length} -gt ${maxlengths[c]} ] && maxlengths[c]=${length}
        ((c += 1))
        [ ${c} == ${nc} ] && c=0
    done
    # Count number of missing right spaces for each element
    c=0
    for ((i = 0; i < nelements; i += 1)); do
        element="${table_to_print[i]}"
        nspaces[i]=$((${maxlengths[${c}]} - ${#element}))
        ((c += 1))
        [ ${c} == ${nc} ] && c=0
    done
    # Reinsert spaces
    table_to_print=("${table_with_esc[@]}")
    modify_element "~" " "
    # Print the table
    c=0
    for ((i = 0; i < nelements; i += 1)); do
        printf "${table_to_print[i]}"  # Print element
        [ ${nspaces[i]} -gt 0 ] && printf ' %.0s' $(eval "echo {1..${nspaces[i]}}")  # Print spaces
        ((c += 1))
        [ ${c} == ${nc} ] ||        printf "  "  # Print extra spaces
        [ ${c} == ${nc} ] && c=0 && printf "\n"  # Print newline
    done
}

# Write out installation overview.
# This overview take the form of the following tables.
# Programs which should not be installed will not be shown.
# Programs already installed and programs to be patched by this
# installer will be noted.
#
# The following software will be installed
# Name           Version  Installation path
# COùòïCEPT        ...      "/..."
# OpenBLAS       ...      "/..."
# CLASS          ...      "/..."
# FFTW           ...      "/..."
# FFTW           ...      "/..."
# FreeType       ...      "/..."
# Gadget         ...      "/..."
# GSL            ...      "/..."
# HDF5           ...      "/..."
# libffi         ...      "/..."
# libpng         ...      "/..."
# MPICH/OpenMPI  ...      "/..."
# ncurses        ...      "/..."
# OpenSSL        ...      "/..."
# Perl           ...      "/..."
# Python         ...      "/..."
# zlib           ...      "/..."
#
# The following Python packages will be installed
# Name          Version
# Blessings     ...
# Cython        ...
# CythonGSL     ...
# H5Py          ...
# Matplotlib    ...
# MPI4Py        ...
# NumPy         ...
# pytest        ...
# SciPy         ...
blas_patch="False"
class_patch="True"
concept_patch="False"
fftw_patch="False"
fftw_for_gadget_patch="False"
freetype_patch="False"
gadget_patch="False"
gsl_patch="False"
hdf5_patch="False"
libffi_patch="False"
libpng_patch="False"
if [ "${mpi}" == "mpich" ]; then
    mpi_patch="False"
elif [ "${mpi}" == "openmpi" ]; then
    mpi_patch="False"
fi
openmpi_patch="False"
ncurses_patch="False"
openssl_patch="False"
perl_patch="False"
python_patch="False"
zlib_patch="False"
blessings_patch="False"
cython_patch="False"
cythongsl_patch="False"
h5py_patch="False"
matplotlib_patch="False"
mpi4py_patch="False"
numpy_patch="False"
pytest_patch="False"
scipy_patch="False"
footnote_patch="${esc_blue}*${esc_normal}"
footnote_installed="${esc_green}‚Ä†${esc_normal}"
insert_footnote_patch(){
    # Argument: Program/Python package name
    eval "program_installed=\"\${${1}_installed}\""
    eval "program_patch=\"\${${1}_patch}\""
    if [ "${program_installed}" == "False" ] && [ "${program_patch}" == "True" ]; then
        echo "${footnote_patch}"
    fi
}
insert_footnote_installed(){
    # Argument: Program/Python package name
    eval "program_installed=\"\${${1}_installed}\""
    if [ "${program_installed}" == "True" ]; then
        echo "${footnote_installed}"
    fi
}
if [ "${install_anything}" == "True" ]; then
    disable_status
    heading "Installation overview"
fi
# Print out software installation overview
if [ "${install_any_software}" == "True" ]; then
    # Title
    table=("${esc_bold}Name${esc_normal}"    \
           "${esc_bold}Version${esc_normal}" \
           "${esc_bold}Installation path${esc_normal}")
    # COùòïCEPT
    if [ "${concept_install}" == "True" ]; then
        table=("${table[@]}"                                       \
            "${esc_concept}$(insert_footnote_installed 'concept')" \
            "${concept_version}$(insert_footnote_patch 'concept')" \
            "\"${concept_dir}\"")
    fi
    # OpenBLAS
    if [ "${blas_install}" == "True" ]; then
        table=("${table[@]}"                                 \
            "OpenBLAS$(insert_footnote_installed 'blas')"    \
            "${blas_version}$(insert_footnote_patch 'blas')" \
            "\"${blas_dir}\"")
    fi
    # CLASS (which will be patched)
    if [ "${class_install}" == "True" ]; then
        table=("${table[@]}"                                   \
            "CLASS$(insert_footnote_installed 'class')"        \
            "${class_version}$(insert_footnote_patch 'class')" \
            "\"${class_dir}\"")
    fi
    # FFTW
    if [ "${fftw_install}" == "True" ]; then
        table=("${table[@]}"                                 \
            "FFTW$(insert_footnote_installed 'fftw')"        \
            "${fftw_version}$(insert_footnote_patch 'fftw')" \
            "\"${fftw_dir}\"")
    fi
    # FFTW for gadget
    if [ "${fftw_for_gadget_install}" == "True" ]; then
        table=("${table[@]}"                                                       \
            "FFTW$(insert_footnote_installed 'fftw_for_gadget')"                   \
            "${fftw_for_gadget_version}$(insert_footnote_patch 'fftw_for_gadget')" \
            "\"${fftw_for_gadget_dir}\"")
    fi
    # FreeType
    if [ "${freetype_install}" == "True" ]; then
        table=("${table[@]}"                                         \
            "FreeType$(insert_footnote_installed 'freetype')"        \
            "${freetype_version}$(insert_footnote_patch 'freetype')" \
            "\"${freetype_dir}\"")
    fi
    # Gadget
    if [ "${gadget_install}" == "True" ]; then
        table=("${table[@]}"                                     \
            "Gadget$(insert_footnote_installed 'gadget')"        \
            "${gadget_version}$(insert_footnote_patch 'gadget')" \
            "\"${gadget_dir}\"")
    fi
    # GSL
    if [ "${gsl_install}" == "True" ]; then
        table=("${table[@]}"                               \
            "GSL$(insert_footnote_installed 'gsl')"        \
            "${gsl_version}$(insert_footnote_patch 'gsl')" \
            "\"${gsl_dir}\"")
    fi
    # HDF5
    if [ "${hdf5_install}" == "True" ]; then
        table=("${table[@]}"                                 \
            "HDF5$(insert_footnote_installed 'hdf5')"        \
            "${hdf5_version}$(insert_footnote_patch 'hdf5')" \
            "\"${hdf5_dir}\"")
    fi
    # libffi
    if [ "${libffi_install}" == "True" ]; then
        table=("${table[@]}"                                     \
            "libffi$(insert_footnote_installed 'libffi')"        \
            "${libffi_version}$(insert_footnote_patch 'libffi')" \
            "\"${libffi_dir}\"")
    fi
    # libpng
    if [ "${libpng_install}" == "True" ]; then
        table=("${table[@]}"                                     \
            "libpng$(insert_footnote_installed 'libpng')"        \
            "${libpng_version}$(insert_footnote_patch 'libpng')" \
            "\"${libpng_dir}\"")
    fi
    # MPICH/OpenMPI
    if [ "${mpi_install}" == "True" ]; then
        if [ "${mpi}" == "mpich" ]; then
            table=("${table[@]}"                               \
                "MPICH$(insert_footnote_installed 'mpi')"      \
                "${mpi_version}$(insert_footnote_patch 'mpi')" \
                "\"${mpi_dir}\"")
        elif [ "${mpi}" == "openmpi" ]; then
            table=("${table[@]}"                               \
                "OpenMPI$(insert_footnote_installed 'mpi')"    \
                "${mpi_version}$(insert_footnote_patch 'mpi')" \
                "\"${mpi_dir}\"")
        fi
    fi
    # ncurses
    if [ "${ncurses_install}" == "True" ]; then
        table=("${table[@]}"                                       \
            "ncurses$(insert_footnote_installed 'ncurses')"        \
            "${ncurses_version}$(insert_footnote_patch 'ncurses')" \
            "\"${ncurses_dir}\"")
    fi
    # OpenSSL
    if [ "${openssl_install}" == "True" ]; then
        table=("${table[@]}"                                       \
            "OpenSSL$(insert_footnote_installed 'openssl')"        \
            "${openssl_version}$(insert_footnote_patch 'openssl')" \
            "\"${openssl_dir}\"")
    fi
    # Perl
    if [ "${perl_install}" == "True" ]; then
        table=("${table[@]}"                                 \
            "Perl$(insert_footnote_installed 'perl')"        \
            "${perl_version}$(insert_footnote_patch 'perl')" \
            "\"${perl_dir}\"")
    fi
    # Python
    if [ "${python_install}" == "True" ]; then
        table=("${table[@]}"                                     \
            "Python$(insert_footnote_installed 'python')"        \
            "${python_version}$(insert_footnote_patch 'python')" \
            "\"${python_dir}\"")
    fi
    # zlib
    if [ "${zlib_install}" == "True" ]; then
        table=("${table[@]}"                                 \
            "zlib$(insert_footnote_installed 'zlib')"        \
            "${zlib_version}$(insert_footnote_patch 'zlib')" \
            "\"${zlib_dir}\"")
    fi
    echo "The following software will be installed"
    print_table table[@] 3
    N_to_be_patched=0
    for (( i=4; i<${#table[@]}; i+=3 )); do
        if [[ "${table[i]}" == *"${footnote_patch}" ]]; then
            ((N_to_be_patched += 1))
        fi
    done
    N_installed=0
    for (( i=3; i<${#table[@]}; i+=3 )); do
        if [[ "${table[i]}" == *"${footnote_installed}" ]]; then
            ((N_installed += 1))
        fi
    done
fi

# Print out Python package installation overview
if [ "${install_any_pypackages}" == "True" ]; then
    # Title
    table=("${esc_bold}Name${esc_normal}" "${esc_bold}Version${esc_normal}" "")
    # Blessings
    if [ "${blessings_install}" == "True" ]; then
        table=("${table[@]}"                                           \
            "Blessings$(insert_footnote_installed 'blessings')"        \
            "${blessings_version}$(insert_footnote_patch 'blessings')" \
            "")
    fi
    # Cython
    if [ "${cython_install}" == "True" ]; then
        table=("${table[@]}"                                     \
            "Cython$(insert_footnote_installed 'cython')"        \
            "${cython_version}$(insert_footnote_patch 'cython')" \
            "")
    fi
    # CythonGSL
    if [ "${cythongsl_install}" == "True" ]; then
           table=("${table[@]}"                                        \
            "CythonGSL$(insert_footnote_installed 'cythongsl')"        \
            "${cythongsl_version}$(insert_footnote_patch 'cythongsl')" \
            "")
    fi
    # H5Py
    if [ "${h5py_install}" == "True" ]; then
        table=("${table[@]}"                                 \
            "H5Py$(insert_footnote_installed 'h5py')"        \
            "${h5py_version}$(insert_footnote_patch 'h5py')" \
            "")
    fi
    # Matplotlib
    if [ "${matplotlib_install}" == "True" ]; then
        table=("${table[@]}"                                             \
            "Matplotlib$(insert_footnote_installed 'matplotlib')"        \
            "${matplotlib_version}$(insert_footnote_patch 'matplotlib')" \
            "")
    fi
    # MPI4Py
    if [ "${mpi4py_install}" == "True" ]; then
        table=("${table[@]}"                                     \
            "MPI4Py$(insert_footnote_installed 'mpi4py')"        \
            "${mpi4py_version}$(insert_footnote_patch 'mpi4py')" \
            "")
    fi
    # NumPy
    if [ "${numpy_install}" == "True" ]; then
        table=("${table[@]}"                                   \
            "NumPy$(insert_footnote_installed 'numpy')"        \
            "${numpy_version}$(insert_footnote_patch 'numpy')" \
            "")
    fi
    # Pytest
    if [ "${pytest_install}" == "True" ]; then
        table=("${table[@]}"                                     \
            "pytest$(insert_footnote_installed 'pytest')"        \
            "${pytest_version}$(insert_footnote_patch 'pytest')" \
            "")
    fi
    # SciPy
    if [ "${scipy_install}" == "True" ]; then
        table=("${table[@]}"                                   \
            "SciPy$(insert_footnote_installed 'scipy')"        \
            "${scipy_version}$(insert_footnote_patch 'scipy')" \
            "")
    fi
    if [ "${install_any_software}" ]; then
        echo
    fi
    echo "The following Python packages will be installed"
    print_table table[@] 3
    for (( i=3; i<${#table[@]}; i+=3 )); do
        if [[ "${table[i]}" == *"${footnote_patch}" ]]; then
            ((N_installed += 1))
        fi
    done
    for (( i=4; i<${#table[@]}; i+=3 )); do
        if [[ "${table[i]}" == *"${footnote_installed}" ]]; then
            ((N_to_be_patched += 1))
        fi
    done
fi
echo
if [ -n "${N_to_be_patched}" ]; then
    if [ ${N_to_be_patched} -eq 1 ]; then
        printf "${footnote_patch} This will be patched by the installer\n"
    elif [ ${N_to_be_patched} -gt 1 ]; then
        printf "${footnote_patch} These will be patched by the installer\n"
    fi
fi
if [ -n "${N_installed}" ]; then
    if [ ${N_installed} -eq 1 ]; then
        printf "${footnote_installed} This is already installed and will not be reinstalled\n"
    elif [ ${N_installed} -gt 1 ]; then
        printf "${footnote_installed} These are already installed and will not be reinstalled\n"
    fi
fi

# Find possible C, C++ and Fortran compilers to try out when building
# the various programs. The compiler possibilities will be gathered in
# the array "compiler_possibilities". An empty value corresponds to
# whatever compilers (if any) were set in the environment at the time of
# invocation of this script. For each compiler (e.g. "gnu") detected,
# there must be declared a corresponding function
# (e.g. "use_gnu_compilers"), the job of which is to set compiler
# environment variables such as CC, CXX and FC.
# Altering PATH-like environment variables is also allowed.
printf "\n${esc_bold}Compilers on the system${esc_normal}\n"
compiler_possibilities=("")
if [ "${mpi_preinstalled}" == "True" ]; then
    compiler_possibilities=("${compiler_possibilities[@]}" "specified_mpi")
fi
for program in "gcc" "g++" "gfortran"; do
    program_path="$(get_command "${program}")" || :
    if [ -n "${program_path}" ]; then
        echo "GNU compiler(s) discovered"
        compiler_possibilities=("${compiler_possibilities[@]}" "gnu")
        break
    fi
done
for program in "clang" "clang++"; do
    program_path="$(get_command "${program}")" || :
    if [ -n "${program_path}" ]; then
        echo "Clang compiler(s) discovered"
        compiler_possibilities=("${compiler_possibilities[@]}" "clang")
        break
    fi
done
for program in "mpicc" "mpiCC" "mpicxx" "mpic++" "mpifort" "mpif90"; do
    program_path="$(get_command "${program}")" || :
    if [ -n "${program_path}" ]; then
        echo "MPI compiler(s) discovered"
        compiler_possibilities=("${compiler_possibilities[@]}" "mpi")
        break
    fi
done
for program in "icc" "icpc" "ifort"; do
    program_path="$(get_command "${program}")" || :
    if [ -n "${program_path}" ]; then
        echo "Intel compiler(s) discovered"
        compiler_possibilities=("${compiler_possibilities[@]}" "intel")
        break
    fi
done
for program in "craycc" "crayCC" "crayftn"; do
    program_path="$(get_command "${program}")" || :
    if [ -n "${program_path}" ]; then
        echo "Cray compiler(s) discovered"
        compiler_possibilities=("${compiler_possibilities[@]}" "cray")
        break
    fi
done
for program in "pgcc" "pgCC" "pgf77" "pgf90"; do
    program_path="$(get_command "${program}")" || :
    if [ -n "${program_path}" ]; then
        echo "Portland compiler(s) discovered"
        compiler_possibilities=("${compiler_possibilities[@]}" "portland")
        break
    fi
done
for program in "cc" "c89" "c99" "CC" "c++" "ftn" "f77" "f90" "fortran"; do
    program_path="$(get_command "${program}")" || :
    if [ -n "${program_path}" ]; then
        echo "Some generic compiler(s) discovered"
        compiler_possibilities=("${compiler_possibilities[@]}" "generic")
        break
    fi
done
if [ "${install_anything}" == "True" ]; then
    echo
    sleep ${sleep_time}
    enable_status
fi
compiler_possibilities=("${compiler_possibilities[@]}" "unset")
use__compilers(){
    # This dummy function must exist
    :
}
use_specified_mpi_compilers(){
    local program program_path bin_path include_path lib_path
    if [ -n "${1}" ]; then
        printf "\nInstallation of ${1} failed. Attempting with specified MPI compilers\n\n"
    fi
    if [ -n "${mpi_dir}" ]; then
        compiler_path="${mpi_compilerdir}"
        bin_path="${mpi_bindir}"
        include_path="${mpi_includedir}"
        lib_path="${mpi_libdir}"
        for program in "mpicc" "mpiCC"; do
            program_path="${compiler_path}/${program}"
            if [ -f "${program_path}" ]; then
                export CC="${program_path}"
                break
            fi
            program_path="${bin_path}/${program}"
            if [ -f "${program_path}" ]; then
                export CC="${program_path}"
                break
            fi
        done
        for program in "mpicxx" "mpic++"; do
            program_path="${compiler_path}/${program}"
            if [ -f "${program_path}" ]; then
                export CXX="${program_path}"
                break
            fi
            program_path="${bin_path}/${program}"
            if [ -f "${program_path}" ]; then
                export CXX="${program_path}"
                break
            fi
        done
        for program in "mpif77"; do
            program_path="${compiler_path}/${program}"
            if [ -f "${program_path}" ]; then
                export FC="${program_path}"
                export F77="${program_path}"
                break
            fi
            program_path="${bin_path}/${program}"
            if [ -f "${program_path}" ]; then
                export FC="${program_path}"
                export F77="${program_path}"
                break
            fi
        done
        for program in "mpifort" "mpif90"; do
            program_path="${compiler_path}/${program}"
            if [ -f "${program_path}" ]; then
                export FC="${program_path}"
                export F90="${program_path}"
                export F9X="${program_path}"
                break
            fi
            program_path="${bin_path}/${program}"
            if [ -f "${program_path}" ]; then
                export FC="${program_path}"
                export F90="${program_path}"
                export F9X="${program_path}"
                break
            fi
        done
        if [ -d "${compiler_path}" ]; then
            export PATH="${compiler_path}:${PATH}"
        fi
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export CFLAGS="-I${include_path} ${CFLAGS}"
            export CXXFLAGS="-I${include_path} ${CXXFLAGS}"
            export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
            export FFLAGS="-I${include_path} ${FFLAGS}"
            export FCFLAGS="-I${include_path} ${FCFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
        # When mixing MPICH and Intel MPI, some symlinking is required
        # due to different library names, as described in section 11 of
        # https://www.mpich.org/static/downloads/3.1/mpich-3.1-README.txt
        mkdir -p "${mpi_symlinkdir}"
        mpi_symlink_pairs=(                      \
            "libmpi.so"      "libmpich.so.12"    \
            "libmpi_dbg.so"  "libmpich.so.12"    \
            "libmpigc4.so"   "libmpichcxx.so.12" \
            "libmpigc4.so"   "libmpichcxx.so.12" \
            "libmpigf.so"    "libfmpich.so.12"   \
            "libmpigf.so"    "libmpichf90.so.12" \
            "libmpi_dbg.so"  "libmpl.so.1"       \
            "libmpi.so"      "libmpl.so.1"       \
            "libmpi.so"      "libopa.so.1"       \
            "libmpi_dbg.so"  "libopa.so.1"       \
            "libmpich.so"    "libmpi.so.5"       \
            "libmpich.so"    "libmpi_dbg.so.5"   \
            "libmpichcxx.so" "libmpigc4.so.5"    \
            "libmpichf90.so" "libmpigf.so.5"     \
            "libmpi.so"      "libmpi.so"         \
            "libmpi.so"      "libmpi.so.5"       \
            "libmpi.so"      "libmpi.so.12"      \
            "libmpi.so.5"    "libmpi.so"         \
            "libmpi.so.5"    "libmpi.so.5"       \
            "libmpi.so.5"    "libmpi.so.12"      \
            "libmpi.so.12"   "libmpi.so"         \
            "libmpi.so.12"   "libmpi.so.5"       \
            "libmpi.so.12"   "libmpi.so.12"      \
        )
        any_mpi_symlinks="False"
        for ((mpi_symlink_index=0; mpi_symlink_index<${#mpi_symlink_pairs[@]}; \
            mpi_symlink_index+=2)); do
            ((mpi_symlink_name_index = mpi_symlink_index + 1))
            mpi_symlink="${lib_path}/${mpi_symlink_pairs[${mpi_symlink_index}]}"
            mpi_symlink_name="${mpi_symlinkdir}/${mpi_symlink_pairs[${mpi_symlink_name_index}]}"
            if [ -f "${mpi_symlink}" ]; then
                any_mpi_symlinks="True"
                if [ ! -f "${mpi_symlink_name}" ]; then
                    ln -s "${mpi_symlink}" "${mpi_symlink_name}" || :
                fi
            fi
        done
        if [ "${any_mpi_symlinks}" == "True" ]; then
            export LDFLAGS="${LDFLAGS} -L${mpi_symlinkdir}"
            export LD_LIBRARY_PATH="${LD_LIBRARY_PATH}:${mpi_symlinkdir}"
            # Using MVAPICH2 together with Python (or Fortran) can cause
            # trouble as described in section 9.1.1 of
            # http://mvapich.cse.ohio-state.edu/static/media/mvapich/
            # mvapich2-2.3b-userguide.html#x1-1280009.1.1
            # Setting the LD_PRELOAD variable should fix this.
            if [ ! -f "${mpi_symlinkdir}/ld_preload.so" ]; then
                current_dir="$(pwd)"
                cd "${mpi_symlinkdir}"
                f_lib=""
                n_lib=""
                for f in *; do
                    if [[ "${f}" == "libmpi.so"* ]]; then
                        n="${f#*.}"
                        if [ "${n}" == "so" ]; then
                            f_lib="${f}"
                            break
                        fi
                        n="${n#*.}"
                        if [ -z "${n_lib}" ] || [[ "${n_lib}" == *"."* ]] \
                            || [ "${n}" -lt "${n_lib}" ]; then
                            f_lib="${f}"
                            n_lib="${n}"
                        fi
                    fi
                done
                cd "${current_dir}"
                if [ -n "${f_lib}" ]; then
                    ln -s "${mpi_symlinkdir}/${f_lib}" "${mpi_symlinkdir}/ld_preload.so"
                fi
            fi
            if [ -f "${mpi_symlinkdir}/ld_preload.so" ]; then
                export LD_PRELOAD="${LD_PRELOAD} ${mpi_symlinkdir}/ld_preload.so"
            fi
        else
            rm -rf "${mpi_symlinkdir}"
        fi
        # Test whether the MPI environment is sane.
        # If not, a warning will be printed,
        # but the installation will carry on regardless.
        current_dir="$(pwd)"
        MPI_LIBS_backup="${MPI_LIBS}"
        if [ -d "${mpi_libdir}" ]; then
            MPI_LIBS="${MPI_LIBS} -L${mpi_libdir} -Wl,-rpath=${mpi_libdir}"
        fi
        if [ -d "${mpi_symlinkdir}" ]; then
            MPI_LIBS="${MPI_LIBS} -L${mpi_symlinkdir} -Wl,-rpath=${mpi_symlinkdir}"
        fi
        if [ -d "${mpi_libdir}" ]; then
            cd "${mpi_libdir}"
            mpi_lib_found="False"
            for f in *; do
                if [[ "${f}" == libmpi.* ]]; then
                    MPI_LIBS="${MPI_LIBS} -lmpi"
                    mpi_lib_found="True"
                    break
                fi
            done
            if [ "${mpi_lib_found}" == "False" ]; then
                for f in *; do
                    if [[ "${f}" == libmpich.* ]]; then
                        MPI_LIBS="${MPI_LIBS} -lmpich"
                        mpi_lib_found="True"
                        break
                    fi
                done
            fi
            cd "${current_dir}"
        fi
        mpi_test_dir="${top_dir}/tmp/mpi_test"
        rm -rf "${mpi_test_dir}" || :
        mkdir -p "${mpi_test_dir}"
        cd "${mpi_test_dir}"
        echo '
#include <mpi.h>
#include <stdio.h>
int main(int argc, char *argv[]) {
  MPI_Init(&argc, &argv);
  int master_rank = 0;
  int rank, number, sum;
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  if (rank == 0) {
    number = 22;
    MPI_Send(&number, 1, MPI_INT, 1, 0, MPI_COMM_WORLD);
  } else if (rank == 1) {
    MPI_Recv(&number, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
  } else {
    number = -1;
  }
  MPI_Reduce(&number, &sum, 1, MPI_INT, MPI_SUM, master_rank, MPI_COMM_WORLD);
  if (rank == 0){
    printf("\nMPI test result = %d\n", sum);
  }
  MPI_Finalize();
  return 0;
}
' > "test.c"
        mpicc ${CFLAGS} -c -o "test.o" "test.c" >/dev/null 2>&1 || :
        mpicc "test.o" -o "test" ${LDFLAGS} ${MPI_LIBS} >/dev/null 2>&1 || :
        mpi_environment_test_success="False"
        mpi_environment_result="$("${mpi_bindir}/mpiexec" -n 4 "./test" 2>/dev/null \
            | grep 'MPI test result =' | awk '{print $NF}' || :)"
        if [ "${mpi_environment_result}" == "42" ]; then
            mpi_environment_test_success="True"
        fi
        cd "${current_dir}"
        rm -rf "${mpi_test_dir}" || :
        MPI_LIBS="${MPI_LIBS_backup}"
        if [ "${mpi_environment_test_success}" == "False" ]; then
            printf "\n\nWarning: The MPI environment does not appear sane!\n\n"
        fi
    fi
}
use_gnu_compilers(){
    local program_path bin_path include_path lib_path
    if [ -n "${1}" ]; then
        printf "\nInstallation of ${1} failed. Attempting with GNU compilers\n\n"
    fi
    program_path="$(get_command "gcc")" || :
    if [ -n "${program_path}" ]; then
        export CC="${program_path}"
        export CXX="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export CFLAGS="-I${include_path} ${CFLAGS}"
            export CXXFLAGS="-I${include_path} ${CXXFLAGS}"
            export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    program_path="$(get_command "g++")" || :
    if [ -n "${program_path}" ]; then
        export CXX="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export CXXFLAGS="-I${include_path} ${CXXFLAGS}"
            export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    program_path="$(get_command "gfortran")" || :
    if [ -n "${program_path}" ]; then
        export FC="${program_path}"
        export F77="${program_path}"
        export F90="${program_path}"
        export F9X="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export FFLAGS="-I${include_path} ${FFLAGS}"
            export FCFLAGS="-I${include_path} ${FCFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
}
use_clang_compilers(){
    local program_path bin_path include_path lib_path
    if [ -n "${1}" ]; then
        printf "\nInstallation of ${1} failed. Attempting with Clang compilers\n\n"
    fi
    program_path="$(get_command "clang")" || :
    if [ -n "${program_path}" ]; then
        export CC="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export CFLAGS="-I${include_path} ${CFLAGS}"
            export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    program_path="$(get_command "clang++")" || :
    if [ -n "${program_path}" ]; then
        export CXX="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export CXXFLAGS="-I${include_path} ${CXXFLAGS}"
            export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    # Clang does not have a Fortran compiler
}
use_mpi_compilers(){
    local program program_path bin_path include_path lib_path
    if [ -n "${1}" ]; then
        printf "\nInstallation of ${1} failed. Attempting with MPI compilers\n\n"
    fi
    for program in "mpicc" "mpiCC"; do
        program_path="$(get_command "${program}")" || :
        if [ -n "${program_path}" ]; then
            export CC="${program_path}"
            bin_path="$(dirname "${program_path}")"
            mpicc_show="$("${CC}" -show || :)"
            lib_paths="$(echo "${mpicc_show}" | grep -o '\-L[^ ]*' || :)"
            n_lib_paths=$(echo "${lib_paths}" | wc -l)
            if [ ${n_lib_paths} -eq 1 ]; then
                lib_path="${lib_paths:2}"
            else
                # Several lib directories exist.
                # Merge them via symlinking.
                lib_path_merged="${mpi_symlinkdir}/merged_lib"
                mkdir -p "${lib_path_merged}"
                while read lib_path; do
                    lib_path="${lib_path:2}"
                    if [ -d "${lib_path}" ]; then
                        for f in "${lib_path}/"*; do
                            f_base="$(basename "${f}")"
                            mpi_symlink_name="${lib_path_merged}/${f_base}"
                            if     [ ! -f "${mpi_symlink_name}" ] \
                                && [ ! -d "${mpi_symlink_name}" ]; then
                                ln -s "${f}" "${mpi_symlink_name}" >/dev/null 2>&1 || :
                            fi
                        done
                    fi
                done <<< "${lib_paths}"
                lib_path="${lib_path_merged}"
            fi
            if [ ! -d "${lib_path}" ]; then
                lib_path="$(dirname "${bin_path}")/lib"
            fi
            include_paths="$(echo "${mpicc_show}" | grep -o '\-I[^ ]*' || :)"
            n_include_paths=$(echo "${include_paths}" | wc -l)
            if [ ${n_include_paths} -eq 1 ]; then
                include_path="${include_paths:2}"
            else
                # Several include directories exist.
                # Merge them via symlinking.
                include_path_merged="${mpi_symlinkdir}/merged_include"
                mkdir -p "${include_path_merged}"
                while read include_path; do
                    include_path="${include_path:2}"
                    if [ -d "${include_path}" ]; then
                        for f in "${include_path}/"*; do
                            f_base="$(basename "${f}")"
                            mpi_symlink_name="${include_path_merged}/${f_base}"
                            if     [ ! -f "${mpi_symlink_name}" ] \
                                && [ ! -d "${mpi_symlink_name}" ]; then
                                ln -s "${f}" "${mpi_symlink_name}" >/dev/null 2>&1 || :
                            fi
                        done
                    fi
                done <<< "${include_paths}"
                include_path="${include_path_merged}"
            fi
            if [ ! -d "${include_path}" ]; then
                include_path="$(dirname "${bin_path}")/include"
            fi
            if [ -d "${bin_path}" ]; then
                export PATH="${bin_path}:${PATH}"
            fi
            if [ -d "${include_path}" ]; then
                export CFLAGS="-I${include_path} ${CFLAGS}"
                export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
            fi
            if [ -d "${lib_path}" ]; then
                export LDFLAGS="-L${lib_path} ${LDFLAGS}"
                export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
            fi
            break
        fi
    done
    for program in "mpicxx" "mpic++"; do
        program_path="$(get_command "${program}")" || :
        if [ -n "${program_path}" ]; then
            export CXX="${program_path}"
            bin_path="$(dirname "${program_path}")"
            include_path="${bin_path}/../include"
            lib_path="${bin_path}/../lib"
            if [ -d "${bin_path}" ]; then
                export PATH="${bin_path}:${PATH}"
            fi
            if [ -d "${include_path}" ]; then
                export CXXFLAGS="-I${include_path} ${CXXFLAGS}"
                export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
            fi
            if [ -d "${lib_path}" ]; then
                export LDFLAGS="-L${lib_path} ${LDFLAGS}"
                export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
            fi
            break
        fi
    done
    program_path="$(get_command "mpif77")" || :
    if [ -n "${program_path}" ]; then
        export FC="${program_path}"
        export F77="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export FFLAGS="-I${include_path} ${FFLAGS}"
            export FCFLAGS="-I${include_path} ${FCFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    for program in "mpifort" "mpif90"; do
        program_path="$(get_command "${program}")" || :
        if [ -n "${program_path}" ]; then
            export FC="${program_path}"
            export F90="${program_path}"
            export F9X="${program_path}"
            bin_path="$(dirname "${program_path}")"
            include_path="${bin_path}/../include"
            lib_path="${bin_path}/../lib"
            if [ -d "${bin_path}" ]; then
                export PATH="${bin_path}:${PATH}"
            fi
            if [ -d "${include_path}" ]; then
                export FFLAGS="-I${include_path} ${FFLAGS}"
                export FCFLAGS="-I${include_path} ${FCFLAGS}"
            fi
            if [ -d "${lib_path}" ]; then
                export LDFLAGS="-L${lib_path} ${LDFLAGS}"
                export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
            fi
            break
        fi
    done
}
use_intel_compilers(){
    local program_path bin_path include_path lib_path
    if [ -n "${1}" ]; then
        printf "\nInstallation of ${1} failed. Attempting with Intel compilers\n\n"
    fi
    program_path="$(get_command "icc")" || :
    if [ -n "${program_path}" ]; then
        export CC="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export CFLAGS="-I${include_path} ${CFLAGS}"
            export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    program_path="$(get_command "icpc")" || :
    if [ -n "${program_path}" ]; then
        export CXX="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export CXXFLAGS="-I${include_path} ${CXXFLAGS}"
            export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    program_path="$(get_command "ifort")" || :
    if [ -n "${program_path}" ]; then
        export FC="${program_path}"
        export F77="${program_path}"
        export F90="${program_path}"
        export F9X="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export FFLAGS="-I${include_path} ${FFLAGS}"
            export FCFLAGS="-I${include_path} ${FCFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
}
use_cray_compilers(){
    local program_path bin_path include_path lib_path
    if [ -n "${1}" ]; then
        printf "\nInstallation of ${1} failed. Attempting with Cray compilers\n\n"
    fi
    program_path="$(get_command "craycc")" || :
    if [ -n "${program_path}" ]; then
        export CC="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export CFLAGS="-I${include_path} ${CFLAGS}"
            export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    program_path="$(get_command "crayCC")" || :
    if [ -n "${program_path}" ]; then
        export CXX="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export CXXFLAGS="-I${include_path} ${CXXFLAGS}"
            export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    program_path="$(get_command "crayftn")" || :
    if [ -n "${program_path}" ]; then
        export FC="${program_path}"
        export F77="${program_path}"
        export F90="${program_path}"
        export F9X="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export FFLAGS="-I${include_path} ${FFLAGS}"
            export FCFLAGS="-I${include_path} ${FCFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
}
use_portland_compilers(){
    local program_path bin_path include_path lib_path
    if [ -n "${1}" ]; then
        printf "\nInstallation of ${1} failed. Attempting with Portland compilers\n\n"
    fi
    program_path="$(get_command "pgcc")" || :
    if [ -n "${program_path}" ]; then
        export CC="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export CFLAGS="-I${include_path} ${CFLAGS}"
            export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    program_path="$(get_command "pgCC")" || :
    if [ -n "${program_path}" ]; then
        export CXX="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export CXXFLAGS="-I${include_path} ${CXXFLAGS}"
            export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    program_path="$(get_command "pgf77")" || :
    if [ -n "${program_path}" ]; then
        export FC="${program_path}"
        export F77="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export FFLAGS="-I${include_path} ${FFLAGS}"
            export FCFLAGS="-I${include_path} ${FCFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    program_path="$(get_command "pgf90")" || :
    if [ -n "${program_path}" ]; then
        export FC="${program_path}"
        export F90="${program_path}"
        export F9X="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export FFLAGS="-I${include_path} ${FFLAGS}"
            export FCFLAGS="-I${include_path} ${FCFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
}
use_generic_compilers(){
    local program program_path bin_path include_path lib_path
    if [ -n "${1}" ]; then
        printf "\nInstallation of ${1} failed. Attempting with generic compilers\n\n"
    fi
    for program in "cc" "c89" "c99"; do
        program_path="$(get_command "${program}")" || :
        if [ -n "${program_path}" ]; then
            export CC="${program_path}"
            bin_path="$(dirname "${program_path}")"
            include_path="${bin_path}/../include"
            lib_path="${bin_path}/../lib"
            if [ -d "${bin_path}" ]; then
                export PATH="${bin_path}:${PATH}"
            fi
            if [ -d "${include_path}" ]; then
                export CFLAGS="-I${include_path} ${CFLAGS}"
                export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
            fi
            if [ -d "${lib_path}" ]; then
                export LDFLAGS="-L${lib_path} ${LDFLAGS}"
                export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
            fi
            break
        fi
    done
    for program in "CC" "c++"; do
        program_path="$(get_command "${program}")" || :
        if [ -n "${program_path}" ]; then
            export CXX="${program_path}"
            bin_path="$(dirname "${program_path}")"
            include_path="${bin_path}/../include"
            lib_path="${bin_path}/../lib"
            if [ -d "${bin_path}" ]; then
                export PATH="${bin_path}:${PATH}"
            fi
            if [ -d "${include_path}" ]; then
                export CXXFLAGS="-I${include_path} ${CXXFLAGS}"
                export CPPFLAGS="-I${include_path} ${CPPFLAGS}"
            fi
            if [ -d "${lib_path}" ]; then
                export LDFLAGS="-L${lib_path} ${LDFLAGS}"
                export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
            fi
            break
        fi
    done
    program_path="$(get_command "f77")" || :
    if [ -n "${program_path}" ]; then
        export FC="${program_path}"
        export F77="${program_path}"
        bin_path="$(dirname "${program_path}")"
        include_path="${bin_path}/../include"
        lib_path="${bin_path}/../lib"
        if [ -d "${bin_path}" ]; then
            export PATH="${bin_path}:${PATH}"
        fi
        if [ -d "${include_path}" ]; then
            export FFLAGS="-I${include_path} ${FFLAGS}"
            export FCFLAGS="-I${include_path} ${FCFLAGS}"
        fi
        if [ -d "${lib_path}" ]; then
            export LDFLAGS="-L${lib_path} ${LDFLAGS}"
            export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
        fi
    fi
    for program in "ftn" "f90" "f9x" "fortran"; do
        program_path="$(get_command "${program}")" || :
        if [ -n "${program_path}" ]; then
            export FC="${program_path}"
            export F90="${program_path}"
            export F9X="${program_path}"
            bin_path="$(dirname "${program_path}")"
            include_path="${bin_path}/../include"
            lib_path="${bin_path}/../lib"
            if [ -d "${bin_path}" ]; then
                export PATH="${bin_path}:${PATH}"
            fi
            if [ -d "${include_path}" ]; then
                export FFLAGS="-I${include_path} ${FFLAGS}"
                export FCFLAGS="-I${include_path} ${FCFLAGS}"
            fi
            if [ -d "${lib_path}" ]; then
                export LDFLAGS="-L${lib_path} ${LDFLAGS}"
                export LD_LIBRARY_PATH="${lib_path}:${LD_LIBRARY_PATH}"
            fi
            break
        fi
    done
}
use_unset_compilers(){
    if [ -n "${1}" ]; then
        printf "\nInstallation of ${1} failed. Attempting with unset compilers\n\n"
    fi
    unset CC CXX FC F90 F9X CFLAGS CXXFLAGS CPPFLAGS FCFLAGS FFLAGS LDFLAGS
}



#################################
# Download COùòïCEPT dependencies #
#################################
# Function for downloading compressed archives
download(){
    # Arguments: Program name, [print_heading]
    progname_formatted="$1"
    progname="${progname_formatted// /_}"
    progname="$(echo "${progname}" | tr '[:upper:]' '[:lower:]')"
    print_heading="${2}"
    if [ -z "${print_heading}" ]; then
        print_heading="True"
    fi
    # Do not download if already fully downloaded
    eval "prog_downloaded=\"\${${progname}_downloaded}\""
    if [ "${prog_downloaded}" == "True" ]; then
        return
    fi
    eval "progversion=\"\${${progname}_version}\""
    if [ "${print_heading}" != "False" ]; then
        if [ "${progname}" == "fftw_for_gadget" ]; then
            # When downloading FFTW for GADGET, the version number should
            # be printed together with FFTW, not GADGET.
            current_step="the downloading of FFTW ${progversion} for GADGET"
            heading "Downloading FFTW ${progversion} for GADGET"
        elif [ "${progname}" == "mpi" ]; then
            if [ "${mpi}" == "mpich" ]; then
                current_step="the downloading of MPICH ${progversion}"
                heading "Downloading MPICH ${progversion}"
            elif [ "${mpi}" == "openmpi" ]; then
                current_step="the downloading of OpenMPI ${progversion}"
                heading "Downloading OpenMPI ${progversion}"
            fi
        else
            current_step="the downloading of ${1/CONCEPT/$esc_concept} ${progversion}"
            heading "Downloading ${1/CONCEPT/$esc_concept} ${progversion}"
        fi
    fi
    eval "url=\"\${${progname}_url}\""
    # Download
    mkdir -p "${top_dir}/tmp/${progname}"
    cd "${top_dir}/tmp/${progname}"
    for n in {1..50}; do
        for ipv in "--inet4-only" "--inet6-only" ""; do
            wget_status="success"
            wget --progress=bar:force -t 1 --timeout 60 -c --no-check-certificate \
                --no-dns-cache ${ipv} "${url}" || wget_status="error"
            if [ "${wget_status}" == "success" ]; then
                break
            fi
        done
        if [ "${wget_status}" == "success" ]; then
            break
        fi
        sleep 5
    done
    if [ "${wget_status}" == "error" ]; then
        error "Error downloading \"${url}\""
        exit 1
    fi
    # Write out success notice
    echo "The following has been fully downloaded:
File:    $(ls -t -1 | head -n 1)
URL:     ${url}
Program: ${progname_formatted}
Version: ${progversion}
Date:    $(date)
" > ".download_finished"
    cd "${top_dir}"
}

# Make the directory in which to dump all downloaded archives
mkdir -p "${top_dir}/tmp"
# Download the source code for all programs that should be installed
disable_status
if [ "${concept_install}" == "True" ] && [ "${concept_downloaded}" == "False" ]; then
    download "CONCEPT"
fi
if [ "${blas_install}" == "True" ] && [ "${blas_downloaded}" == "False" ]; then
    download "BLAS"
fi
if [ "${class_install}" == "True" ] && [ "${class_downloaded}" == "False" ]; then
    download "CLASS"
fi
if [ "${fftw_install}" == "True" ] && [ "${fftw_downloaded}" == "False" ]; then
    download "FFTW"
fi
if [ "${fftw_for_gadget_install}" == "True" ] \
    && [ "${fftw_for_gadget_downloaded}" == "False" ]; then
    download "FFTW for GADGET"
fi
if [ "${freetype_install}" == "True" ] && [ "${freetype_downloaded}" == "False" ]; then
    download "FreeType"
fi
if [ "${gadget_install}" == "True" ] && [ "${gadget_downloaded}" == "False" ]; then
    download "GADGET"
fi
if [ "${gsl_install}" == "True" ] && [ "${gsl_downloaded}" == "False" ]; then
    download "GSL"
fi
if [ "${hdf5_install}" == "True" ] && [ "${hdf5_downloaded}" == "False" ]; then
    download "HDF5"
fi
if [ "${libpng_install}" == "True" ] && [ "${libpng_downloaded}" == "False" ]; then
    download "libpng"
fi
if [ "${mpi_install}" == "True" ] && [ "${mpi_downloaded}" == "False" ]; then
    download "MPI"
fi
if [ "${ncurses_install}" == "True" ] && [ "${ncurses_downloaded}" == "False" ]; then
    download "ncurses"
fi
if [ "${openssl_install}" == "True" ] && [ "${openssl_downloaded}" == "False" ]; then
    download "OpenSSL"
fi
if [ "${libffi_install}" == "True" ] && [ "${libffi_downloaded}" == "False" ]; then
    download "libffi"
fi
if [ "${perl_install}" == "True" ] && [ "${perl_downloaded}" == "False" ]; then
    download "Perl"
fi
if [ "${python_install}" == "True" ] && [ "${python_downloaded}" == "False" ]; then
    download "Python"
fi
if [ "${zlib_install}" == "True" ] && [ "${zlib_downloaded}" == "False" ]; then
    download "zlib"
fi
enable_status



################################
# Install COùòïCEPT dependencies #
################################
# Function for extracting compressed files
extract(){
    # Arguments: Program name, [is_file]
    # Here, the optional is_file argument can be set to "True" if
    # the first argument is a filename rather than a program name.
    # In that case, the working directory will not be changed.
    if [ "$2" == "True" ]; then
        archive="$1"
    else
        progname="${1// /_}"
        progname="$(echo "${progname}" | tr '[:upper:]' '[:lower:]')"
        cd "${top_dir}/tmp/${progname}"
        # We assume that any directories placed here is from a similar
        # previous call which went wrong. Delete any of these
        # directories before extracting.
        n_files=0
        for f in *; do
            if [ -d "${f}" ]; then
                for n in {1..720}; do
                    rm_success="True"
                    rm -rf "${f}" || rm_success="False"
                    if [ "${rm_success}" == "True" ]; then
                        break
                    fi
                    sleep 5
                done
            else
                archive="${f}"
                ((n_files += 1))
            fi
        done
        if [ -z "${archive}" ]; then
            error "Did not find any files in \"${top_dir}/tmp/${progname}\""
            exit 1
        elif [ ${n_files} -gt 1 ]; then
            error "Found multiple files in \"${top_dir}/tmp/${progname}\"."
            error "I am confused about which to extract. Exiting."
            exit 1
        fi
    fi
    case "${archive}" in
        # 7zip
        *.tar.7zip)  7z       -so  x   "${archive}" | tar -ixvf -;;
        *.tar.7z)    7z       -so  x   "${archive}" | tar -ixvf -;;
        *.t7zip)     7z       -so  x   "${archive}" | tar -ixvf -;;
        *.t7z)       7z       -so  x   "${archive}" | tar -ixvf -;;
        *.7zip)      7z            x   "${archive}"              ;;
        *.7z)        7z            x   "${archive}"              ;;
        # ar
        *.ar)        ar       -xv      "${archive}"              ;;
        *.a)         ar       -xv      "${archive}"              ;;
        # bzip2
        *.tar.bzip2) bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.tar.bz2)   bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.tbzip2)    bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.tbz2)      bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.bzip2)     bzip2    -d       "${archive}"              ;;
        *.bz2)       bzip2    -d       "${archive}"              ;;
        *.tar.bzip)  bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.tar.bz)    bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.tbzip)     bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.tbz)       bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.bzip)      bzip2    -d       "${archive}"              ;;
        *.bz)        bzip2    -d       "${archive}"              ;;
        # cbz
        *.cbz)       unzip             "${archive}"              ;;
        # compress
        *.tar.Z)     compress -d     < "${archive}" | tar -ixvf -;;
        *.tZ)        compress -d     < "${archive}" | tar -ixvf -;;
        *.Z)         compress -d       "${archive}"              ;;
        # cpio
        *.cpio)      cpio     -idv     "${archive}"              ;;
        # exe
        *.exe)       "$(readlink -f    "${archive}")"            ;;
        # gzip
        *.tar.gzip)  gzip     -d     < "${archive}" | tar -ixvf -;;
        *.tar.gz)    gzip     -d     < "${archive}" | tar -ixvf -;;
        *.tar.z)     gzip     -d     < "${archive}" | tar -ixvf -;;
        *.tgzip)     gzip     -d     < "${archive}" | tar -ixvf -;;
        *.tgz)       gzip     -d     < "${archive}" | tar -ixvf -;;
        *.tz)        gzip     -d     < "${archive}" | tar -ixvf -;;
        *.gzip)      gzip     -d       "${archive}"              ;;
        *.gz)        gzip     -d       "${archive}"              ;;
        # iso
        *.7z)        7z            x   "${archive}"              ;;
        # jar
        *.jar)       jar      -xvf     "${archive}"              ;;
        # lzip
        *.tar.lzip)  lzip     -d     < "${archive}" | tar -ixvf -;;
        *.tar.lz)    lzip     -d     < "${archive}" | tar -ixvf -;;
        *.tlzip)     lzip     -d     < "${archive}" | tar -ixvf -;;
        *.tlz)       lzip     -d     < "${archive}" | tar -ixvf -;;
        *.lzip)      lzip     -d       "${archive}"              ;;
        *.lz)        lzip     -d       "${archive}"              ;;
        # lzma
        *.tar.lzma)  lzma     -d     < "${archive}" | tar -ixvf -;;
        *.tlzma)     lzma     -d     < "${archive}" | tar -ixvf -;;
        *.lzma)      lzma     -d       "${archive}"              ;;
        # lzop
        *.tar.lzop)  lzop     -d     < "${archive}" | tar -ixvf -;;
        *.tar.lzo)   lzop     -d     < "${archive}" | tar -ixvf -;;
        *.tlzop)     lzop     -d     < "${archive}" | tar -ixvf -;;
        *.tlzo)      lzop     -d     < "${archive}" | tar -ixvf -;;
        *.lzop)      lzop     -d       "${archive}"              ;;
        *.lzo)       lzop     -d       "${archive}"              ;;
        # pack
        *.z)         pack          u   "${archive}" out          ;;
        # rar
        *.rar)       unrar         x   "${archive}"              ;;
        # rzip
        *.tar.rzip)  rzip     -d     < "${archive}" | tar -ixvf -;;
        *.tar.rz)    rzip     -d     < "${archive}" | tar -ixvf -;;
        *.trzip)     rzip     -d     < "${archive}" | tar -ixvf -;;
        *.trz)       rzip     -d     < "${archive}" | tar -ixvf -;;
        *.rzip)      rzip     -d       "${archive}"              ;;
        *.rz)        rzip     -d       "${archive}"              ;;
        # shar
        *.shar)      unshar            "${archive}"              ;;
        # snappy
        *.sz)        snzip    -d       "${archive}"              ;;
        # tar
        *.tar)       cat               "${archive}" | tar -ixvf -;;
        # xz
        *.tar.xz)    xz       -d     < "${archive}" | tar -ixvf -;;
        *.txz)       xz       -d     < "${archive}" | tar -ixvf -;;
        *.xz)        xz       -d       "${archive}"              ;;
        # zip
        *tar.zip)    unzip    -p       "${archive}" | tar -ixvf -;;
        *tzip)       unzip    -p       "${archive}" | tar -ixvf -;;
        *.zip)       unzip             "${archive}"              ;;
        # unknown
        *) error "Could not understand the compression format of \"${archive}\""
           exit 1
           ;;
    esac
    if [ "$2" != "True" ]; then
        cd "${top_dir}"
    fi
}

# Function which initializes installations (extracts the pre-
# downloaded archive and change to the extracted directory).
init_install(){
    # Arguments: Program name
    progname="${1// /_}"
    progname="$(echo "${progname}" | tr '[:upper:]' '[:lower:]')"
    eval "progversion=\"\${${progname}_version}\""
    if [ "${progname}" != "${progname_last_init_install}" ]; then
        if [ "${progname}" == "fftw_for_gadget" ]; then
            # When installing FFTW for GADGET, the version number should
            # be printed together with FFTW, not GADGET.
            current_step="the installation of FFTW ${progversion} for GADGET"
            heading "Installing FFTW ${progversion} for GADGET"
            set_status "Installing FFTW ${progversion} for GADGET"
        elif [ "${progname}" == "mpi" ]; then
            if [ "${mpi}" == "mpich" ]; then
                current_step="the installation of MPICH ${progversion}"
                heading "Installing MPICH ${progversion}"
                set_status "Installing MPICH ${progversion}"
            elif [ "${mpi}" == "openmpi" ]; then
                current_step="the installation of OpenMPI ${progversion}"
                heading "Installing OpenMPI ${progversion}"
                set_status "Installing OpenMPI ${progversion}"
            fi
        else
            current_step="the installation of ${1/CONCEPT/$esc_concept} ${progversion}"
            heading "Installing ${1/CONCEPT/$esc_concept} ${progversion}"
            set_status "Installing ${1/CONCEPT/${esc_concept}} ${progversion}"
        fi
    fi
    # Extract the downloaded archive
    extract "${progname}"
    # Change to the directory which contain the archive
    # and the extracted folder.
    cd "${top_dir}/tmp/${progname}"
    # The current directory should contain only a single directory.
    # Change to this directory.
    for f in *; do
        if [ -d "${f}" ]; then
            cd "${f}"
            break
        fi
    done
    # Save a copy of the program name
    progname_last_init_install="${progname}"
}

# Function for detecting when the current process appears to hang.
# When an apparent hang is detected, a soothing message is displayed.
# This should be used when installing Python packages, as pip/setuptools
# sometimes has this bad hanging behaviour, especially for particular
# packages, such as h5py. This function should not be called in a
# situation where you do not believe that the hang is only apparent.
soothe(){
    # Argument: PID of background process on which to wait,
    # [time in seconds after which PID is killed].
    soothe_pid=$1
    kill_time=$2
    # A long wait is detected by repeatedly
    # checking the size of the log file generated
    # by this installation script.
    soothe_update_time=60
    (
    log_size_last=-1;                                                              \
    log_size=$(du -b "${log}" | awk '{print $1}');                                 \
    time_slept=0;                                                                  \
    while :; do                                                                    \
        sleep ${soothe_update_time};                                               \
        log_size_new=$(du -b "${log}" | awk '{print $1}');                         \
        if [ ${log_size} -eq ${log_size_new} ]; then                               \
            ((time_slept += ${soothe_update_time}));                               \
            if [ ${log_size} -ne ${log_size_last} ]; then                          \
                printf "\n\nThe next step may take an unreasonable amount of time.
Please be patient ...\n";                                                          \
                sleep 5;                                                           \
                log_size_new=$(du -b "${log}" | awk '{print $1}');                 \
                log_size_last=${log_size_new};                                     \
            elif [ -n "${kill_time}" ] && [ ${time_slept} -gt ${kill_time} ]; then \
                echo "Process assumed to be hanging. Killing it";                  \
                kill -9 ${soothe_pid} >/dev/null 2>&1;                             \
                wait    ${soothe_pid} >/dev/null 2>&1;                             \
            fi;                                                                    \
        else                                                                       \
            time_slept=0;                                                          \
        fi;                                                                        \
        log_size=${log_size_new};                                                  \
    done                                                                           \
    ) & soothe_killer_pid=$!
    wait ${soothe_pid} >/dev/null 2>&1 || :
    kill ${soothe_killer_pid} >/dev/null 2>&1 || :  # No forcefull kill (no -9)
    wait ${soothe_killer_pid} >/dev/null 2>&1 || :
}

# Function for writing out installation notices as to files in the
# installation directories of the various programs.
install_notice(){
    # Arguments: Program name, program_dir
    progname_formatted="$1"
    progdir="$2"
    progname="${progname_formatted// /_}"
    progname="$(echo "${progname}" | tr '[:upper:]' '[:lower:]')"
    eval "progversion=\"\${${progname}_version}\""
    test_results="None"
    if [ "${do_tests}" == "True" ]; then
        eval "test_success=\"\${${progname}_test_success}\""
        if [ "${test_success}" == "True" ]; then
            test_results="Success"
        elif [ "${test_success}" == "False" ]; then
            test_results="Failure"
        fi
    fi
    echo "The following has been fully installed:
Program:      ${progname_formatted}
Version:      ${progversion}
Test results: ${test_results}
Date:         $(date)
" >> "${progdir}/.installation_finished"
}



# zlib
if [ "${zlib_install}" == "True" ] && [ "${zlib_installed}" == "False" ]; then
    install_success="False"
    for compiler in "${compiler_possibilities[@]}"; do
        reset_environment
        eval "use_${compiler}_compilers zlib" || continue
        init_install "zlib"
        ./configure --shared --prefix="${zlib_dir}" 2>&1 || continue
        if [ "${do_tests}" == "True" ]; then
            make ${make_jobs} test 2>&1 | tee "test_log"
            [ ${PIPESTATUS[0]} -eq 0 ] || zlib_test_success="False"
        fi
        if [ "${zlib_test_success}" == "False" ]; then
            mkdir -p "$(dirname "${zlib_test_log}")"
            cp "test_log" "${zlib_test_log}"
        fi
        make ${make_jobs} install 2>&1 || continue
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install zlib"
        exit 1
    fi
    reset_environment
    cp "README" "${zlib_dir}/"
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/zlib" || :
    install_notice "zlib" "${zlib_dir}"
fi

# libpng
if [ "${libpng_install}" == "True" ] && [ "${libpng_installed}" == "False" ]; then
    install_success="False"
    for compiler in "${compiler_possibilities[@]}"; do
        reset_environment
        eval "use_${compiler}_compilers libpng" || continue
        init_install "libpng"
        export CPPFLAGS="-I${zlib_dir}/include ${CPPFLAGS}"
        export LD_LIBRARY_PATH="${zlib_dir}/lib:${LD_LIBRARY_PATH}"
        export LDFLAGS="-L${zlib_dir}/lib ${LDFLAGS}"
        export ZLIBLIB="${zlib_dir}/lib"
        export ZLIBINC="${zlib_dir}/include"
        ./configure --prefix="${libpng_dir}" 2>&1 || continue
        if [ "${do_tests}" == "True" ]; then
            make ZLIBLIB="${ZLIBLIB}" ZLIBINC="${ZLIBINC}" ${make_jobs} check 2>&1 | tee "test_log"
            [ ${PIPESTATUS[0]} -eq 0 ] || libpng_test_success="False"
        fi
        if [ "${libpng_test_success}" == "False" ]; then
            mkdir -p "$(dirname "${libpng_test_log}")"
            cp "test_log" "${libpng_test_log}"
        fi
        make ZLIBLIB="${ZLIBLIB}" ZLIBINC="${ZLIBINC}" ${make_jobs} install 2>&1 || continue
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install libpng"
        exit 1
    fi
    reset_environment
    cp "LICENSE" "${libpng_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/libpng" || :
    install_notice "libpng" "${libpng_dir}"
fi

# GSL
if [ "${gsl_install}" == "True" ] && [ "${gsl_installed}" == "False" ]; then
    install_success="False"
    for compiler in "${compiler_possibilities[@]}"; do
        reset_environment
        eval "use_${compiler}_compilers GSL" || continue
        init_install "GSL"
        ./configure --prefix="${gsl_dir}" 2>&1 || continue
        make ${make_jobs} 2>&1 || continue
        if [ "${do_tests}" == "True" ]; then
            make ${make_jobs} check 2>&1 | tee "test_log"
            [ ${PIPESTATUS[0]} -eq 0 ] || gsl_test_success="False"
        fi
        if [ "${gsl_test_success}" == "False" ]; then
            mkdir -p "$(dirname "${gsl_test_log}")"
            cp "test_log" "${gsl_test_log}"
        fi
        make ${make_jobs} install 2>&1 || continue
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install GSL"
        exit 1
    fi
    reset_environment
    cp "COPYING" "README" "${gsl_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/gsl" || :
    install_notice "GSL" "${gsl_dir}"
fi

# MPI
if [ "${mpi_install}" == "True" ] && [ "${mpi_installed}" == "False" ]; then
    install_success="False"
    compiler_possibilities_mpi=()
    compiler_possibilities_specified_mpi=""
    for compiler in "${compiler_possibilities[@]}"; do
        if [ "${compiler}" == "specified_mpi" ]; then
            compiler_possibilities_specified_mpi="${compiler}"
        else
            compiler_possibilities_mpi=("${compiler_possibilities_mpi[@]}" "${compiler}")
        fi
    done
    if [ -n "${compiler_possibilities_specified_mpi}" ]; then
        compiler_possibilities_mpi=("${compiler_possibilities_mpi[@]}" \
            "${compiler_possibilities_specified_mpi}")
    fi
    for compiler in "${compiler_possibilities_mpi[@]}"; do
        reset_environment
        eval "use_${compiler}_compilers MPI" || continue
        if [ "${mpi}" == "mpich" ]; then
            # MPICH
            init_install "MPI"
            ./configure --enable-shared --prefix="${mpi_dir}" 2>&1 || continue
            make ${make_jobs} 2>&1 || continue
            make ${make_jobs} install 2>&1 || continue
            # MPICH can be tested by running the code below.
            # Since this require several GB of memory and will occupy up
            # to 30 MPI processes, we skip these tests.
            run_mpi_tests="False"
            if [ "${run_mpi_tests}" == "True" ]; then
                if [ "${do_tests}" == "True" ]; then
                    export RUNTESTS_VERBOSE=1
                    make ${make_jobs} testing 2>&1 | tee "test_log"
                    [ ${PIPESTATUS[0]} -eq 0 ] || mpi_test_success="False"
                fi
                if [ "${mpi_test_success}" == "False" ]; then
                    mkdir -p "$(dirname "${mpi_test_log}")"
                    cp "test_log" "${mpi_test_log}"
                fi
            fi
            install_success="True"
            break
        elif [ "${mpi}" == "openmpi" ]; then
            # OpenMPI.
            # On some systems the building of OpenMPI will fail unless
            # it is configured with the UCX library. If the initial
            # installation fails we install such a UCX library and
            # link OpenMPI to it.
            for install_ucx in "False" "True"; do
                init_install "MPI"
                # Temporary OpenMPI session files can cause OpenMPI
                # to crash. Remove any temporary directory of the form
                # /tmp/openmpi-sessions-* which belongs to the user.
                my_username="$(whoami)"
                ls_output="$(ls -l /tmp | grep openmpi-sessions- || :)"
                if [ -n "${ls_output}" ]; then
                    while read -r line; do
                        username="$(echo "${line}" | awk '{print $3}')"
                        if [ "${username}" == "${my_username}" ]; then
                            openmpi_session_dirname="$(echo "${line}" | awk '{print $9}')"
                            rm -rf "/tmp/${openmpi_session_dirname}" || :
                        fi
                    done <<< "${ls_output}"
                fi
                # Install dedicated UCX for OpenMPI.
                # This may fail if it cannot detect the NUMA library.
                # On failure, install it without NUMA support.
                current_dir="$(pwd)"
                if [ "${install_ucx}" == "True" ]; then
                    install_ucx_success="False"
                    ucx_dir="${mpi_dir}/ucx"
                    ucx_version="1.5.0"
                    ucx_url="https://github.com/openucx/ucx/archive/v${ucx_version}.tar.gz"
                    download "ucx" "False"
                    LDFLAGS_ori="${LDFLAGS}"
                    CFLAGS_ori="${CFLAGS}"
                    CXXFLAGS_ori="${CXXFLAGS}"
                    CPPFLAGS_ori="${CPPFLAGS}"
                    for disable_numa in "" "--disable-numa"; do
                        printf "
Attempting to install UCX for OpenMPI with disable_numa=${disable_numa}\n\n"
                        extract "ucx"
                        cd "${top_dir}/tmp/ucx"
                        for f in *; do
                            if [ -d "${f}" ]; then
                                cd "${f}"
                                break
                            fi
                        done
                        # The NUMA library should be placed in
                        # /usr/lib64. Add this directory to the LDFLAGS.
                        # Both libnuma.so and libnuma.so.1 should exist.
                        # To be sure, we create symlinks to these in a
                        # new directory and add this directory to
                        # LDFLAGS as well.
                        # Similarly, the NUMA header files are
                        # needed and should be placed in /usr/include.
                        if [ -z "${disable_numa}" ]; then
                            if [ -d "/usr/lib64" ]; then
                                export LDFLAGS="${LDFLAGS_ori} -L/usr/lib64"
                            fi
                            numa_symlink_dir="${ucx_dir}/numa_symlinks"
                            rm -rf "${numa_symlink_dir}" || :
                            mkdir -p "${numa_symlink_dir}" || :
                            if [ -f "/usr/lib64/libnuma.so" ] && \
                                [ ! -f "/usr/lib64/libnuma.so.1" ]; then
                                ln -s "/usr/lib64/libnuma.so" \
                                    "${numa_symlink_dir}/libnuma.so.1" || :
                            fi
                            if [ -f "/usr/lib64/libnuma.so.1" ] && \
                                [ ! -f "/usr/lib64/libnuma.so" ]; then
                                ln -s "/usr/lib64/libnuma.so.1" \
                                    "${numa_symlink_dir}/libnuma.so" || :
                            fi
                            export LDFLAGS="${LDFLAGS} -L${numa_symlink_dir}"
                            if [ -d "/usr/include" ]; then
                                export CFLAGS="-I/usr/include ${CFLAGS_ori}"
                                export CXXFLAGS="-I/usr/include ${CXXFLAGS_ori}"
                                export CPPFLAGS="-I/usr/include ${CPPFLAGS_ori}"
                            fi
                        fi
                        ./autogen.sh 2>&1 || continue
                        ./contrib/configure-release --prefix="${ucx_dir}" \
                            ${disable_numa} 2>&1 || continue
                        make ${make_jobs} 2>&1 || continue
                        make install 2>&1 || continue
                        cp "AUTHORS" "LICENSE" "${ucx_dir}/" || :
                        install_ucx_success="True"
                        printf "\nInstallation of UCX for OpenMPI successful.
Now continue with the installation of OpenMPI\n\n"
                        break
                    done
                    export LDFLAGS="${LDFLAGS_ori}"
                    export CFLAGS="${CFLAGS_ori}"
                    export CXXFLAGS="${CXXFLAGS_ori}"
                    export CPPFLAGS="${CPPFLAGS_ori}"
                    if [ "${install_ucx_success}" == "False" ]; then
                        continue
                    fi
                fi
                cd "${current_dir}"
                # Install OpenMPI
                if [ "${install_ucx}" == "False" ]; then
                    ./configure --prefix="${mpi_dir}" 2>&1 || continue
                elif [ "${install_ucx}" == "True" ]; then
                    ./configure --prefix="${mpi_dir}" --with-ucx="${ucx_dir}" 2>&1 || continue
                fi
                make ${make_jobs} all 2>&1 || continue
                make ${make_jobs} install 2>&1 || continue
                # OpenMPI does not come with a test suite
                install_success="True"
                break
            done
            if [ "${install_success}" == "True" ]; then
                break
            fi
        fi
    done
    if [ "${install_success}" == "False" ]; then
        if [ "${mpi}" == "mpich" ]; then
            error "Failed to install MPICH"
        elif [ "${mpi}" == "openmpi" ]; then
            error "Failed to install OpenMPI"
        fi
        exit 1
    fi
    reset_environment
    if [ "${mpi}" == "mpich" ]; then
        cp "COPYRIGHT" "${mpi_dir}/" || :
    elif [ "${mpi}" == "openmpi" ]; then
        cp "AUTHORS" "LICENSE" "${mpi_dir}/" || :
    fi
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/mpi" || :
    if [ "${mpi}" == "openmpi" ]; then
        rm -rf "${top_dir}/tmp/ucx" || :
    fi
    install_notice "MPI" "${mpi_dir}"
fi

# HDF5
if [ "${hdf5_install}" == "True" ] && [ "${hdf5_installed}" == "False" ]; then
    install_success="False"
    hdf5_test_success_backup="${hdf5_test_success}"
    # Attempt to configure using multiple MPI link flags
    for extra_LIBS in "" "-lmpi" "-lmpich"; do
        reset_environment
        init_install "HDF5"
        # Set environment variables and configure options used
        # when building againts MPI and zlib.
        enable_parallel=""
        if [ -n "${mpi_dir}" ]; then
            use_specified_mpi_compilers
            enable_parallel="--enable-parallel"
        elif [ -n "${extra_LIBS}" ]; then
            break
        fi
        with_zlib=""
        if [ -n "${zlib_dir}" ]; then
            export LDFLAGS="-L${zlib_dir}/lib ${LDFLAGS}"
            export LD_LIBRARY_PATH="${zlib_dir}/lib:${LD_LIBRARY_PATH}"
            export CFLAGS="-I${zlib_dir}/include ${CFLAGS}"
            with_zlib=--with-zlib="${zlib_dir}/include","${zlib_dir}/lib"
        fi
        # A bug in HDF5 makes the code crash on certain file systems.
        # A workaround is to set an environment variable as below.
        # The bug is documented here:
        # http://www.nersc.gov/users/data-analytics
        # /data-management/i-o-libraries/hdf5-2/hdf5/
        export HDF5_USE_FILE_LOCKING=FALSE
        if [ -n "${enable_parallel}" ]; then
            export LIBS="${extra_LIBS} ${LIBS}"
            printf "
Attempting to install HDF5 with extra_LIBS=${extra_LIBS}\n\n"
        fi
        ./configure                \
            --enable-shared        \
            ${enable_parallel}     \
            ${with_zlib}           \
            --prefix="${hdf5_dir}" \
            2>&1 || continue
        # Newer versions of gcc (e.g. 8.1.0) do not allow attributes to
        # be specified after the declarator in function definitions.
        # At least in some versions of HDF5 (e.g. 1.10.2), this rule is
        # broken by src/H5detect.c. If the original build fail, we edit
        # src/H5detect.c to be compliant with this rule and try again.
        hdf5_make_success="True"
        make ${make_jobs} 2>&1 || hdf5_make_success="False"
        if [ "${hdf5_make_success}" == "False" ]; then
            mv "src/H5detect.c" "src/H5detect.c_cp"
            if [ -z "${IFS+x}" ]; then
                IFS_ori="__unset__"
            else
                IFS_ori="${IFS}"
            fi
            IFS=''
            while read -r line; do
                if [ "${line}" == "static void" ] || [ "${line}" == "int" ] ; then
                    printf "${line} " >> "src/H5detect.c"
                else
                    echo "${line}" >> "src/H5detect.c"
                fi
            done <<< "$(cat "src/H5detect.c_cp")"
            if [ "${IFS_ori}" == "__unset__" ]; then
                unset IFS
            else
                IFS="${IFS_ori}"
            fi
            rm -f "src/H5detect.c_cp" || :
            sed -i 's/^static void \(.*\) HDF_NO_UBSAN/static void HDF_NO_UBSAN \1/' \
                "src/H5detect.c"
            sed -i 's/^int \(.*\) HDF_NO_UBSAN/int HDF_NO_UBSAN \1/' "src/H5detect.c"
            hdf5_make_success="True"
            make ${make_jobs} 2>&1 || continue
        fi
        # On some systems, the HDF5 test (make check) hangs
        # indefinitely. To counteract this, kill the process if it still
        # runs after ${hdf5_test_max_time} seconds.
        if [ "${do_tests}" == "True" ]; then
            hdf5_test_success="${hdf5_test_success_backup}"
            hdf5_test_max_time=3600
            # Perform serial + parallel tests if build against MPI
            # or normal tests otherwise.
            if [ -n "${mpi_dir}" ]; then
                # Serial tests
                (make ${make_jobs} check-s 2>&1 | tee "test_log") & hdf5_test_pid=$!
                soothe ${hdf5_test_pid} ${hdf5_test_max_time}
                sleep 1
                kill -9 ${hdf5_test_pid} >/dev/null 2>&1 || :
                wait    ${hdf5_test_pid} >/dev/null 2>&1 || :
                exit_code="$(wait ${hdf5_test_pid} >/dev/null 2>&1 || echo $?)"
                if [ -n "${exit_code}" ]; then
                    hdf5_test_success="False"
                fi
                # Parallel tests
                printf "\n\n\nParallel tests below\n\n\n\n" >> "test_log"
                (make ${make_jobs} check-p 2>&1 | tee "test_log") & hdf5_test_pid=$!
                soothe ${hdf5_test_pid} ${hdf5_test_max_time}
                sleep 1
                kill -9 ${hdf5_test_pid} >/dev/null 2>&1 || :
                wait    ${hdf5_test_pid} >/dev/null 2>&1 || :
                exit_code="$(wait ${hdf5_test_pid} >/dev/null 2>&1 || echo $?)"
                if [ -n "${exit_code}" ]; then
                    hdf5_test_success="False"
                fi
            else
                (make ${make_jobs} check 2>&1 | tee "test_log") & hdf5_test_pid=$!
                soothe ${hdf5_test_pid} ${hdf5_test_max_time}
                sleep 1
                kill -9 ${hdf5_test_pid} >/dev/null 2>&1 || :
                wait    ${hdf5_test_pid} >/dev/null 2>&1 || :
                exit_code="$(wait ${hdf5_test_pid} >/dev/null 2>&1 || echo $?)"
                if [ -n "${exit_code}" ]; then
                    hdf5_test_success="False"
                fi
            fi
        fi
        make ${make_jobs} install 2>&1 || continue
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install HDF5"
        exit 1
    fi
    if [ "${do_tests}" == "True" ]; then
        printf "\n\n\nInstall tests below\n\n\n\n" >> "test_log"
        make ${make_jobs} check-install 2>&1 | tee -a "test_log"
        # The text "*FAILED*" will be present in the test log file
        # if any of the tests failed.
        [ ${PIPESTATUS[0]} -eq 0 ] || hdf5_test_success="False"
        if grep '\*FAILED\*' "test_log" >/dev/null 2>&1; then
            hdf5_test_success="False"
        fi
    fi
    if [ "${hdf5_test_success}" == "False" ]; then
        mkdir -p "$(dirname "${hdf5_test_log}")"
        cp "test_log" "${hdf5_test_log}"
    fi
    reset_environment
    cp "COPYING" "README.txt" "${hdf5_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/hdf5" || :
    install_notice "HDF5" "${hdf5_dir}"
fi

# FFTW
if [ "${fftw_install}" == "True" ] && [ "${fftw_installed}" == "False" ]; then
    install_success="False"
    fftw_test_success_backup="${fftw_test_success}"
    enable_mpi=""
    if [ -n "${mpi_dir}" ]; then
        enable_mpi="--enable-mpi"
    fi
    for enable_shared in "--enable-shared" ""; do
        for shared in "" "-shared"; do
            if [ -z "${enable_shared}" ] && [ -n "${shared}" ]; then
                continue
            fi
            for with_pic in "" "--with-pic"; do
                for PIC in "-fPIC" ""; do
                    for extra_MPILIBS in "" "-lmpi" "-lmpich"; do
                        if [ -z "${enable_mpi}" ] && [ -n "${extra_MPILIBS}" ]; then
                            continue
                        fi
                        reset_environment
                        init_install "FFTW"
                        printf "
Attempting to install FFTW with enable_shared=${enable_shared}, with_pic=${with_pic}, \
PIC=${PIC}, shared=${shared}, extra_MPILIBS=${extra_MPILIBS}\n\n"
                        export CFLAGS="-O3 ${PIC} ${CFLAGS}"
                        export CXXFLAGS="-O3 ${PIC} ${CXXFLAGS}"
                        export LDFLAGS="${LDFLAGS} ${shared} ${PIC}"
                        if [ -n "${enable_mpi}" ]; then
                            use_specified_mpi_compilers
                            export MPICC="${CC}"
                            export MPILIBS="${extra_MPILIBS} ${MPILIBS}"
                        fi
                        # Double-precision
                        ./configure ${enable_shared}  \
                                    ${enable_mpi}     \
                                    --disable-fortran \
                                    ${with_pic}       \
                                    --prefix="${fftw_dir}" 2>&1 || continue
                        make ${make_jobs} 2>&1 || continue
                        if [ "${do_tests}" == "True" ]; then
                            make ${make_jobs} check 2>&1 | tee "test_log"
                            fftw_test_success="${fftw_test_success_backup}"
                            [ ${PIPESTATUS[0]} -eq 0 ] || fftw_test_success="False"
                        fi
                        make ${make_jobs} install 2>&1 || continue
                        # Single-precision
                        make clean || :
                        ./configure ${enable_shared}  \
                                    ${enable_mpi}     \
                                    --enable-float    \
                                    --disable-fortran \
                                    ${with_pic}       \
                                    --prefix="${fftw_dir}" 2>&1 || continue
                        make ${make_jobs}         2>&1 || continue
                        make ${make_jobs} install 2>&1 || continue
                        install_success="True"
                        break
                    done
                    if [ "${install_success}" == "True" ]; then
                        break
                    fi
                done
                if [ "${install_success}" == "True" ]; then
                    break
                fi
            done
            if [ "${install_success}" == "True" ]; then
                break
            fi
        done
        if [ "${install_success}" == "True" ]; then
            break
        fi
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install FFTW"
        exit 1
    fi
    if [ "${fftw_test_success}" == "False" ]; then
        mkdir -p "$(dirname "${ftw_test_log}")"
        cp "test_log" "${fftw_test_log}"
    fi
    reset_environment
    cp "COPYING" "README" "${fftw_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/fftw" || :
    install_notice "FFTW" "${fftw_dir}"
fi

# FreeType
if [ "${freetype_install}" == "True" ] && [ "${freetype_installed}" == "False" ]; then
    install_success="False"
    for compiler in "${compiler_possibilities[@]}"; do
        reset_environment
        eval "use_${compiler}_compilers FreeType" || continue
        init_install "FreeType"
        ./configure --prefix="${freetype_dir}" \
                    --with-zlib=no             \
                    --with-bzip2=no            \
                    --with-png=no              \
                    --with-harfbuzz=no 2>&1 || continue
        make ${make_jobs} 2>&1 || continue
        # FreeType does not come with a test suite
        make ${make_jobs} install 2>&1 || continue
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install FreeType"
        exit 1
    fi
    reset_environment
    (cd docs; cp "FTL.TXT" "GPLv2.TXT" "LICENSE.TXT" "${freetype_dir}/" || :)
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/freetype" || :
    install_notice "FreeType" "${freetype_dir}"
fi

# ncurses
if [ "${ncurses_install}" == "True" ] && [ "${ncurses_installed}" == "False" ]; then
    install_success="False"
    for compiler in "${compiler_possibilities[@]}"; do
        reset_environment
        eval "use_${compiler}_compilers ncurses" || continue
        init_install "ncurses"
        # Due to a bug in (at least) ncurses 6.0, this is needed on
        # some systems. See https://trac.sagemath.org/ticket/19762
        export CPPFLAGS="-P ${CPPFLAGS}"
        ./configure --with-shared --prefix="${ncurses_dir}" 2>&1 || continue
        make ${make_jobs} 2>&1 || continue
        make ${make_jobs} install 2>&1 || continue
        if [ "${do_tests}" == "True" ]; then
            disable_status
            (sleep ${sleep_time}; echo "q") | "test/worm" -n 7 > "/dev/tty" 2>&1 \
                || ncurses_test_success="False"
            enable_status
        fi
        # Additional test run needed (if the first failed), as the one
        # above do not use tee (as it ruins the display).
        if [ "${do_tests}" == "True" ] && [ "${ncurses_test_success}" == "False" ]; then
            disable_status
            (sleep ${sleep_time}; echo "q") | "test/worm" -n 7 > "test_log" 2>&1 || :
            enable_status
        fi
        if [ "${ncurses_test_success}" == "False" ]; then
            mkdir -p "$(dirname "${ncurses_test_log}")"
            cp "test_log" "${ncurses_test_log}"
        fi
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install ncurses"
        exit 1
    fi
    reset_environment
    cp "AUTHORS" "COPYING" "${ncurses_dir}/include/ncurses/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/ncurses" || :
    install_notice "ncurses" "${ncurses_dir}"
fi

# Perl
if [ "${perl_install}" == "True" ] && [ "${perl_installed}" == "False" ]; then
    # Sometimes make fails to build due to #include of poll.h from a
    # wrong location. A fix for this is implemented below. First we try
    # without the fix, then with the fix.
    # Furthermore, sometimes the installation will complain that the
    # Perl libraries should have been compiled statically.
    # Thus, we try with# and witouth the -fPIC C flag.
    install_success="False"
    for compiler in "${compiler_possibilities[@]}"; do
        libimf_dumped="False"
        for dump_libimf in "True" "False"; do
            if [ "${dump_libimf}" == "False" ] && [ "${libimf_dumped}" == "False" ]; then
                # libimf was not found, so dump_libimf == True is
                # equivalent to dump_libimf == False.
                continue
            fi
            for perl_poll_fix in "False" "True"; do
                for perl_cflags in "" "-fPIC"; do
                    reset_environment
                    eval "use_${compiler}_compilers" || continue
                    init_install "Perl"
                    printf "
Attempting to install Perl with compiler=${compiler}, dump_libimf=${dump_libimf}, \
perl_poll_fix=${perl_poll_fix}, perl_cflags=${perl_cflags}\n\n"
                    # When an Intel C compiler is used, some libraries
                    # like libimf may not be found by the perl
                    # executable. We can fix this by dropping symlinks
                    # to all Intel libraries into the build directory.
                    # For whatever reason, updating LD_LIBRARY_PATH
                    # has no effect.
                    if [ "${dump_libimf}" == "True" ]; then
                        while IFS=':' read -ra library_paths; do
                            for library_path in "${library_paths[@]}"; do
                                is_intel_lib_dir="False"
                                for f in "${library_path}"/*; do
                                    f_base="$(basename "${f}")"
                                    if     [[ "${f_base}" == libimf*.a    ]] \
                                        || [[ "${f_base}" == libimf*.so   ]] \
                                        || [[ "${f_base}" == libimd*.so.* ]]; then
                                        is_intel_lib_dir="True"
                                        break
                                    fi
                                done
                                if [ "${is_intel_lib_dir}" == "False" ]; then
                                    continue
                                fi
                                libimf_dumped="True"
                                for f in "${library_path}"/*; do
                                    f_base="$(basename "${f}")"
                                    if (   [[ "${f_base}" == *.a    ]] \
                                        || [[ "${f_base}" == *.so   ]] \
                                        || [[ "${f_base}" == *.so.* ]] \
                                       ) && [ ! -f "./${f_base}" ]; then
                                        ln -s "${f}" ./ || :
                                    fi
                                done
                            done
                        done <<< "${LD_LIBRARY_PATH}"
                    fi
                    perl_config_options="-de -Dprefix=${perl_dir}"
                    if [ -n "${compiler}" ] && [ -n "${CC}" ]; then
                        perl_config_options="${perl_config_options} -Dcc=${CC}"
                    fi
                    if [ -n "${perl_cflags}" ]; then
                        perl_config_options="${perl_config_options} -Accflags=${perl_cflags}"
                    fi
                    ./Configure ${perl_config_options} 2>&1 || : continue
                    if [ "${perl_poll_fix}" == "True" ]; then
                        sed -i 's/<poll\.h>/<sys\/poll\.h>/' 'dist/IO/poll.h' || continue
                    fi
                    make ${make_jobs} 2>&1 || continue
                    if [ "${do_tests}" == "True" ]; then
                        # On some systems, the Perl test hangs indefinitely.
                        # To counteract this, kill the process if it still
                        # runs after ${perl_test_max_time} seconds.
                        perl_test_max_time=3600
                        (make ${make_jobs} test 2>&1 | tee "test_log") & perl_test_pid=$!
                        soothe ${perl_test_pid} ${perl_test_max_time}
                        sleep 1
                        kill -9 ${perl_test_pid} >/dev/null 2>&1 || :
                        wait    ${perl_test_pid} >/dev/null 2>&1 || :
                        exit_code="$(wait ${perl_test_pid} >/dev/null 2>&1 || echo $?)"
                        if [ -n "${exit_code}" ]; then
                            perl_test_success="False"
                        fi
                        # The text "Failed" will be present in the test log
                        # file if any of the tests failed.
                        if grep 'Failed' "test_log" >/dev/null 2>&1; then
                            perl_test_success="False"
                        fi
                    fi
                    if [ "${perl_test_success}" == "False" ]; then
                        mkdir -p "$(dirname "${perl_test_log}")"
                        cp "test_log" "${perl_test_log}"
                    fi
                    make ${make_jobs} install 2>&1 || continue
                    install_success="True"
                    break
                done
                if [ "${install_success}" == "True" ]; then
                    break
                fi
            done
            if [ "${install_success}" == "True" ]; then
                break
            fi
        done
        if [ "${install_success}" == "True" ]; then
            break
        fi
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install Perl"
        exit 1
    fi
    reset_environment
    cp "AUTHORS" "Copying" "README" "${perl_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/perl" || :
    install_notice "Perl" "${perl_dir}"
fi

# OpenSSL
if [ "${openssl_install}" == "True" ] && [ "${openssl_installed}" == "False" ]; then
    install_success="False"
    for compiler in "${compiler_possibilities[@]}"; do
        reset_environment
        eval "use_${compiler}_compilers OpenSSL" || continue
        init_install "OpenSSL"
        export PATH="${perl_dir}/bin:${PATH}"
        export PERL="${perl_dir}/bin/perl"
        ./config shared --prefix="${openssl_dir}" \
            --openssldir="${openssl_dir}/openssl" 2>&1 || continue
        make 2>&1 || continue  # Should not be run in parallel!
        if [ "${do_tests}" == "True" ]; then
            make test 2>&1 | tee "test_log"  # Should not be run in parallel!
            [ ${PIPESTATUS[0]} -eq 0 ] || openssl_test_success="False"
        fi
        if [ "${openssl_test_success}" == "False" ]; then
            mkdir -p "$(dirname "${openssl_test_log}")"
            cp "test_log" "${openssl_test_log}"
        fi
        make install 2>&1 || continue  # Should not be run in parallel!
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install OpenSSL"
        exit 1
    fi
    reset_environment
    cp "LICENSE" "README" "${openssl_dir}/include/openssl/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/openssl" || :
    install_notice "OpenSSL" "${openssl_dir}"
fi

# libffi
if [ "${libffi_install}" == "True" ] && [ "${libffi_installed}" == "False" ]; then
    install_success="False"
    for compiler in "${compiler_possibilities[@]}"; do
        reset_environment
        eval "use_${compiler}_compilers libffi" || continue
        init_install "libffi"
        ./configure --prefix="${libffi_dir}" 2>&1 || continue
        make ${make_jobs} 2>&1 || continue
        if [ "${do_tests}" == "True" ]; then
            make check 2>&1 | tee "test_log"
            [ ${PIPESTATUS[0]} -eq 0 ] || libffi_test_success="False"
        fi
        if [ "${libffi_test_success}" == "False" ]; then
            mkdir -p "$(dirname "${libffi_test_log}")"
            cp "test_log" "${libffi_test_log}"
        fi
        make ${make_jobs} install 2>&1 || continue
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install libffi"
        exit 1
    fi
    reset_environment
    cp "LICENSE" "README" "${libffi_dir}/lib/libffi-${libffi_version}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/libffi" || :
    install_notice "libffi" "${libffi_dir}"
fi

# OpenBLAS
if [ "${blas_install}" == "True" ] && [ "${blas_installed}" == "False" ]; then
    # Due to the threading behaviour of Python,
    # we install a non-threaded version of OpenBLAS.
    # We wish to use the gfortran Fortran compiler. We try out all the
    # compiler environments but overwriting the Fortran compiler.
    # If this fails, we retry without overwriting the Fortran compiler.
    # On 32 bit systems we need to set BINARY=32. First we try without,
    # then with this option.
    # On Haswell architectures the -mavx2 C and Fortran compiler flag
    # is added, though not all compilers accept these. We first try
    # with both, then we switch them out for -mavx, then only with the C
    # flag -mavx2, then only with the C flag -mavx. If all fail we
    # disable AVX2 entirely. If this fails as well we additionally
    # disable AVX.
    # Note that OpenBLAS runs its test suite during this build.
    install_success="False"
    mavx_C_options=("-mavx2" "-mavx" "-mavx2" "-mavx" "NO_AVX2" "NO_AVX")
    mavx_F_options=("-mavx2" "-mavx" ""       ""      "NO_AVX2" "NO_AVX")
    for ((mavx_index=0; mavx_index<${#mavx_C_options[@]}; mavx_index++)); do
        mavx_C="${mavx_C_options[${mavx_index}]}"
        mavx_F="${mavx_F_options[${mavx_index}]}"
        for openblas_gfortran in "True" "False"; do
            for compiler in "${compiler_possibilities[@]}"; do
                for openblas_BINARY in "" "32"; do
                    reset_environment
                    eval "use_${compiler}_compilers" || continue
                    init_install "BLAS"
                    printf "
Attempting to install OpenBLAS with mavx_C=${mavx_C}, mavx_F=${mavx_F}, \
openblas_gfortran=${openblas_gfortran}, compiler=${compiler}, \
openblas_BINARY=${openblas_BINARY}\n\n"
                    openblas_make_options="USE_THREAD=0"
                    if [ "${mavx_C}" == "NO_AVX2" ]; then
                        # Disable AVX2 completely
                        openblas_make_options="${openblas_make_options} NO_AVX2=1"
                    elif [ "${mavx_C}" == "NO_AVX" ]; then
                        # Disable AVX2 and AVX completely
                        openblas_make_options="${openblas_make_options} NO_AVX2=1 NO_AVX=1"
                    else
                        # Handle the C mavx flag
                        pattern='CCOMMON_OPT *\\+= *-mavx2'
                        linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
                            "Makefile.x86_64" | head -n 1)
                        if [ "${mavx_C}" != "-mavx2" ] && [ -z "${linenr}" ]; then
                            continue
                        fi
                        if [ -z "${mavx_C}" ]; then
                            sed -i "${linenr}d" "Makefile.x86_64"
                        elif [ "${mavx_C}" == "-mavx" ]; then
                            sed -i "${linenr}s/.*/CCOMMON_OPT += -mavx/" "Makefile.x86_64"
                        fi
                        # Handle the F mavx flag
                        pattern='FCOMMON_OPT *\\+= *-mavx2'
                        linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
                            "Makefile.x86_64" | head -n 1)
                        if [ "${mavx_F}" != "-mavx2" ] && [ -z "${linenr}" ]; then
                            continue
                        fi
                        if [ -z "${mavx_F}" ]; then
                            sed -i "${linenr}d" "Makefile.x86_64"
                        elif [ "${mavx_F}" == "-mavx" ]; then
                            sed -i "${linenr}s/.*/FCOMMON_OPT += -mavx/" "Makefile.x86_64"
                        fi
                    fi
                    if [ "${openblas_gfortran}" == "True" ]; then
                        export FC="gfortran"
                        export F77="gfortran"
                        export F90="gfortran"
                        export F9X="gfortran"
                    fi
                    if ([ -n "${compiler}" ] && [ -n "${FC}" ]) \
                        || [ "${openblas_gfortran}" == "True" ]; then
                        openblas_make_options="${openblas_make_options} FC=${FC}"
                    fi
                    if [ -n "${compiler}" ] && [ -n "${CC}" ]; then
                        openblas_make_options="${openblas_make_options} CC=${CC}"
                    fi
                    if [ -n "${openblas_BINARY}" ]; then
                        openblas_make_options="${openblas_make_options} BINARY=${openblas_BINARY}"
                    fi
                    make ${openblas_make_options} || continue
                    make PREFIX="${blas_dir}" install || continue
                    install_success="True"
                    break
                done
                if [ "${install_success}" == "True" ]; then
                    break
                fi
            done
            if [ "${install_success}" == "True" ]; then
                break
            fi
        done
        if [ "${install_success}" == "True" ]; then
            break
        fi
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install OpenBLAS"
        exit 1
    fi
    reset_environment
    cp "LICENSE" "${blas_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/blas" || :
    install_notice "BLAS" "${blas_dir}"
fi

# Python
if [ "${python_install}" == "True" ]; then
    # If the path to an already installed Python distribution is set in
    # the PYTHONPATH variable, it may conflict with the installation
    # provided by this script. Specifically, issues have been noted when
    # updating pip. Here we make sure to unset PYTHONPATH, and we do not
    # set it again, not even through the reset_environment function.
    unset PYTHONPATH
    # As we are installing Python from scratch, we remove the user site
    # directory (~/.local/lib/python3.x/site-packages) from the searched
    # paths when importing modules in Python. In this way, other Python
    # distributions on the system cannot interfere with this one.
    export PYTHONNOUSERSITE="True"
fi
if [ "${python_install}" == "True" ] && [ "${python_installed}" == "False" ]; then
    install_success="False"
    # The configure script will check whether atomic operations may
    # be used. Some compilers (e.g. Intel 2019) only implement a subset
    # of the needed atomic operations, and so may falsely passed this
    # check. If none of the other combination of options (compiler and
    # optimization choices) work, we try everything again while claiming
    # that we do not support atomic operations at all.
    for compiler in "${compiler_possibilities[@]}"; do
        for disable_atomic_operations in "False" "True"; do
            # Build with pip if both openssl and zlib are installed.
            # For Python >=3.7, a standalone libffi is also required,
            # though we do not check explicitly for this.
            with_ensurepip_install=""
            if [ -n "${openssl_dir}" ] && [ -n "${zlib_dir}" ]; then
                with_ensurepip_install="--with-ensurepip=install"
            fi
            # Try building with optimizations (both profile guided
            # compile time optimization (pgo) and link time
            # optimization (lto)). If it fails for whatever reason,
            # fall back to a non-optimized build.
            for pyoptimizations in "pgo lto" "pgo" "lto" ""; do
                reset_environment
                eval "use_${compiler}_compilers" || continue
                init_install "Python"
                printf "
Attempting to install Python with compiler=${compiler}, \
disable_atomic_operations=${disable_atomic_operations}, pyoptimizations=${pyoptimizations}\n\n"
                # Set up environment variables and configure options
                if [ "${disable_atomic_operations}" == "True" ]; then
                    sed -i '/have_stdatomic_h *= *yes/c\have_stdatomic_h=no' configure
                fi
                with_pgo=""
                if [[ "${pyoptimizations}" == *"pgo"* ]]; then
                    with_pgo="--enable-optimizations"
                fi
                with_lto=""
                if [[ "${pyoptimizations}" == *"lto"* ]]; then
                    with_lto="--with-lto"
                fi
                if [ -n "${ncurses_dir}" ]; then
                    export CPPFLAGS="-I${ncurses_dir}/include \
-I${ncurses_dir}/include/ncurses ${CPPFLAGS}"
                    export LD_LIBRARY_PATH="${ncurses_dir}/lib:${LD_LIBRARY_PATH}"
                    export LDFLAGS="-L${ncurses_dir}/lib -Wl,-rpath=${ncurses_dir}/lib ${LDFLAGS}"
                fi
                with_openssl=""
                if [ -n "${openssl_dir}" ]; then
                    export CPPFLAGS="-I${openssl_dir}/include/openssl ${CPPFLAGS}"
                    export LD_LIBRARY_PATH="${openssl_dir}/lib:${LD_LIBRARY_PATH}"
                    export LDFLAGS="-L${openssl_dir}/lib -Wl,-rpath=${openssl_dir}/lib ${LDFLAGS}"
                    with_openssl="--with-openssl=${openssl_dir}"
                    # Modify Modules/Setup.dist in order for Python to use the
                    # custom SSL library.
                    first_line="$(grep -n 'SSL=' 'Modules/Setup.dist')"
                    first_line=${first_line%:*}
                    ((last_line = first_line + 3))
                    sed -i "${first_line},${last_line}s/.//" "Modules/Setup.dist"
                    sed -i "${first_line}s/.*/SSL=${openssl_dir//\//\\/}/" "Modules/Setup.dist"
                fi
                if [ -n "${zlib_dir}" ]; then
                    export CPPFLAGS="-I${zlib_dir}/include ${CPPFLAGS}"
                    export LD_LIBRARY_PATH="${zlib_dir}/lib:${LD_LIBRARY_PATH}"
                    export LDFLAGS="-L${zlib_dir}/lib -Wl,-rpath=${zlib_dir}/lib ${LDFLAGS}"
                fi
                with_system_ffi=""
                if [ -n "${libffi_dir}" ]; then
                    current_dir="$(pwd)"
                    for lib_dir in "lib" "lib64"; do
                        if [ ! -d "${libffi_dir}/${lib_dir}" ]; then
                            continue
                        fi
                        cd "${libffi_dir}/${lib_dir}"
                        for f in *; do
                            if     [ -d "${f}" ] \
                                && [[ "${f}" == "libffi"* ]] \
                                && [ -d "${libffi_dir}/${lib_dir}/${f}/include" ]; then
                                export CPPFLAGS="-I${libffi_dir}/${lib_dir}/${f}/include \
${CPPFLAGS}"
                                break
                            fi
                        done
                        export LD_LIBRARY_PATH="${libffi_dir}/${lib_dir}:${LD_LIBRARY_PATH}"
                        export LDFLAGS="-L${libffi_dir}/${lib_dir} \
-Wl,-rpath=${libffi_dir}/${lib_dir} ${LDFLAGS}"
                    done
                    cd "${current_dir}"
                    with_system_ffi="--with-system-ffi"
                fi
                # Configure.
                # When pgo optimizations are enabled, some of the tests which
                # are performed may hang. It appears that the configure script
                # allows each test to take up to an hour before they are
                # forcefully killed. We thus do not need to kill any such
                # hanging process manually. We do however write out a soothing
                # message in the case of such hangs, letting the user know that
                # everything is all right.
                pyconfigure_success="True"
                ./configure --enable-shared ${with_pgo} ${with_lto} --prefix="${python_dir}" \
                    ${with_ensurepip_install}                                                \
                    ${with_openssl}                                                          \
                    ${with_system_ffi}                                                       \
                    2>&1 || pyconfigure_success="False" & python_configure_pid=$!
                soothe ${python_configure_pid}
                if [ "${pyconfigure_success}" == "False" ]; then
                    continue
                fi
                # Make
                make ${make_jobs} 2>&1 || continue
                # Test
                if [ "${do_tests}" == "True" ]; then
                    make ${make_jobs} test 2>&1 | tee "test_log"
                    [ ${PIPESTATUS[0]} -eq 0 ] || python_test_success="False"
                fi
                if [ "${python_test_success}" == "False" ]; then
                    mkdir -p "$(dirname "${python_test_log}")"
                    cp "test_log" "${python_test_log}"
                else
                    rm -f "${python_test_log}" || :
                fi
                # Make install
                make install 2>&1 || continue  # Should be run serially
                install_success="True"
                break
            done
            if [ "${install_success}" == "True" ]; then
                break
            fi
        done
        if [ "${install_success}" == "True" ]; then
            break
        fi
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install Python"
        exit 1
    fi
    reset_environment
    cp "LICENSE" "README.rst" "${python_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/python" || :
    install_notice "Python" "${python_dir}"
fi
# Create a python variable, storing the path to the Python interpreter
if [ -n "${python_dir}" ]; then
    found_python_interpreter="False"
    for python_version_major in 3 2; do
        if [ -f "${python_dir}/bin/python${python_version_major}" ]; then
            found_python_interpreter="True"
            break
        fi
    done
    if [ "${found_python_interpreter}" == "True" ]; then
        python_version_major_dot_minor=$("${python_dir}/bin/python${python_version_major}" -c \
            "from sys import version_info as v; print(str(v.major) + '.' + str(v.minor))")
        python="${python_dir}/bin/python${python_version_major_dot_minor}"
    fi
fi



###########################
# Install Python packages #
###########################
# Set "pypackage"_installed variables
blessings_installed="False"
cython_installed="False"
cythongsl_installed="False"
h5py_installed="False"
matplotlib_installed="False"
mpi4py_installed="False"
numpy_installed="False"
pytest_installed="False"
scipy_installed="False"
if [ -n "${python}" ]; then
    current_step="checking of installed Python packages"
    set_status "Checking for installed Python packages"
    for pypackage in blessings     \
                     cython        \
                     cythongsl     \
                     h5py          \
                     matplotlib    \
                     mpi4py        \
                     numpy         \
                     pytest        \
                     scipy         \
                     pip; do
        pypackage_installed=$(check_pypackage_installed ${pypackage})
        eval "${pypackage}_installed=\"${pypackage_installed}\""
    done
fi

# Function for downloading Python packages, utilizing pip
pip_download(){
    # Arguments: Python package name, version, pip_download_time.
    # No second argument, blank second argument or a second argument of
    # "upgrade" means newest version. The second argument can also be a
    # version string that pip understands, e.g. ">=1.4".
    # The third argument determines how many seconds pip shoul get
    # to download the package before it is killed. This can be helpful
    # if pip (for whatever reason) decides to run the setup.py file of
    # the package after a successful download, and that process ends
    # up hanging. If no third argument is given, or if the third
    # argument is 0, no time limit is set.
    local command_end=""
    if [ -n "${2}" ] && [ "${2}" != "upgrade" ]; then
        if [[ "${2}" == [0-9]* ]]; then
            # Second argument is a specific version
            command_end="==${2}"
        else
            # Second argument is a version string that pip understands
            command_end="${2}"
        fi
    fi
    pip_name="${1//_/}"
    pip_name="$(echo "${pip_name}" | tr '[:upper:]' '[:lower:]')"
    tmp_pip_dir="${top_dir}/tmp/pip"
    mkdir -p "${tmp_pip_dir}"
    tmp_pip_dir="${tmp_pip_dir// /\\ }"  # Add backslashes before spaces
    # Maximum allowed time (in seconds) for download. After this time,
    # the download process will be killed. This is needed because the
    # process sometimes hang after an otherwise successful download.
    pip_download_time=3600
    if [ -n "${3}" ]; then
        pip_download_time=${3}
    fi
    # Download the Python package
    for n in {1..50}; do
        pip_status="error"
        # Dependent on the version of pip, different calling conventions
        # are used to download (and not install) the source code
        # of a Python package.
        for pip_args in "download -v -v -v
                                  --no-cache-dir
                                  --no-binary=:all:
                                  --dest=${tmp_pip_dir}
                                  ${pip_name}${command_end}" \
                        "install  -v -v -v
                                  --no-cache-dir
                                  --no-binary=:all:
                                  --download
                                  ${tmp_pip_dir}
                                  ${pip_name}${command_end}" \
                        "install  -v -v -v
                                  --no-cache-dir
                                  --no-use-wheel
                                  --download
                                  ${tmp_pip_dir}
                                  ${pip_name}${command_end}" \
                        "install  -v -v -v
                                  --no-use-wheel
                                  --download
                                  ${tmp_pip_dir}
                                  ${pip_name}${command_end}"; do
            # Download Python package
            "${python}" -m pip ${pip_args} & pip_download_pid=$!
            # The above command may succeed in retrieving the package,
            # but then hang indefinately. Kill the process after
            # ${pip_download_time} seconds.
            soothe ${pip_download_pid} ${pip_download_time}
            # If the archive exists in the tmp/pip dir,
            # the download completed successfully.
            if ls "${top_dir}/tmp/pip" | grep -i "${pip_name}" > /dev/null 2>&1; then
                pip_status="success"
            fi
            if [ "${pip_status}" == "success" ]; then
                break
            fi
        done
        if [ "${pip_status}" == "success" ]; then
            break
        fi
        sleep ${sleep_time}
    done
    if [ "${pip_status}" == "error" ]; then
        error "Error downloading ${1}"
        exit 1
    fi
}

# Function for installing and upgrading Python packages, utilizing pip
pip_install_pypackage(){
    # Arguments: Python package name, [version or "upgrade"]
    # (install specific version or update existing version to newest).
    # If second argument is not provided, the newest version
    # will be installed.
    local command_end=""
    if [ "${2}" == "upgrade" ]; then
        current_step="upgrade of ${1}"
        heading "Upgrading ${1}"
        set_status "Upgrading ${1}"
    else
        if [ -n "${2}" ]; then
            current_step="installation of ${1} ${2}"
            heading "Installing ${1} ${2}"
            set_status "Installing ${1} ${2}"
        else
            current_step="installation of ${1}"
            heading "Installing ${1}"
            set_status "Installing ${1}"
        fi
        if [ -n "${2}" ]; then
            command_end="==${2}"
        fi
    fi
    # Download Python package source
    tmp_pip_dir="${top_dir}/tmp/pip"
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp" || :
    mkdir -p "${tmp_pip_dir}" "${tmp_pip_dir}_tmp"
    export TMPDIR="${tmp_pip_dir}_tmp"
    pypackage="$(echo "${1}" | tr '[:upper:]' '[:lower:]')"
    pip_download "${pypackage}" "${2}"
    rm -rf "${tmp_pip_dir}_cp" || :
    cp -r "${tmp_pip_dir}" "${tmp_pip_dir}_cp"
    # Install Python package from source
    upgrade_flag=""
    if [ "${2}" == "upgrade" ]; then
        upgrade_flag="--upgrade"
    fi
    for pyuser in "" "--user"; do
        # After the adoption of PEP 518 (pip 10), some packages require
        # wheels (not bare source) when building. This can be disabled by
        # supplying --no-build-isolation. We try both.
        # Some times the installation process will appear to hang,
        # but it will eventually get going. This happens often for
        # particular packages, such as h5py. When this is the case,
        # write a soothing message.
        for extra_pip_arg in ""    \
            "--no-build-isolation" \
            "--no-cache-dir"       \
            "--no-build-isolation --no-cache-dir"; do
            if [ -n "${extra_pip_arg}" ]; then
                printf "\npip failed to install ${1}. \
Now trying with ${pyuser} ${extra_pip_arg}\n\n"
                rm -rf "${tmp_pip_dir}" || :
                cp -r "${tmp_pip_dir}_cp" "${tmp_pip_dir}"
            fi
            if [ -z "${upgrade_flag}" ]; then
                "${python}" -m pip uninstall "${pypackage}" -y >/dev/null 2>&1 || :
            fi
            "${python}" -m pip install ${pyuser} -v -v -v                \
                                       ${extra_pip_arg}                  \
                                       -b "${tmp_pip_dir}/build"         \
                                       ${upgrade_flag}                   \
                                       --no-index                        \
                                       --find-links="${tmp_pip_dir}"     \
                                       "${pypackage}${command_end}" 2>&1 \
                                        & pip_install_pid=$!
            soothe ${pip_install_pid}
            pypackage_installed=$(check_pypackage_installed ${pypackage})
            if [ "${pypackage_installed}" == "True" ]; then
                break
            fi
        done
        if [ "${pypackage_installed}" == "True" ]; then
            break
        fi
        rm -rf "${tmp_pip_dir}"
        # If we failed to install the Python package, try installing it
        # via pip without using any additional arguments.
        printf "\npip could not install/upgrade ${1}, neither with or without \
--no-build-isolation and --no-cache-dir\nNow trying without specifying any \
extra arguments to pip\n\n"
        if [ -z "${upgrade_flag}" ]; then
            "${python}" -m pip uninstall "${pypackage}" -y >/dev/null 2>&1 || :
        fi
        "${python}" -m pip install ${pyuser} "${pypackage}${command_end}" 2>&1 & pip_install_pid=$!
        soothe ${pip_install_pid}
        pypackage_installed=$(check_pypackage_installed ${pypackage})
        if [ "${pypackage_installed}" == "True" ]; then
            break
        fi
        # If we still fail, try with just the --no-cache-dir argument
        printf "\npip could not install/upgrade ${1} using no additional arguments\n\
Now trying with just --no-cache-dir\n\n"
        if [ -z "${upgrade_flag}" ]; then
            "${python}" -m pip uninstall "${pypackage}" -y >/dev/null 2>&1 || :
        fi
        "${python}" -m pip install ${pyuser} --no-cache-dir \
            "${pypackage}${command_end}" 2>&1 & pip_install_pid=$!
        soothe ${pip_install_pid}
        pypackage_installed=$(check_pypackage_installed ${pypackage})
    done
    reset_environment
    # Exit on failure
    if [ "${pypackage_installed}" != "True" ]; then
        echo "pip could not install/upgrade ${1}"
        return 1
    fi
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp" "${tmp_pip_dir}_cp" || :
}

# Upgrade/install pip, setuptools and wheel.
# Do not use the pip_download or pip_install_pypackage functions
# for this, as these packages (and their dependencies) may actually be
# needed for that to work, resulting in a bootstrapping problem.
# This problem really arises from the choice of installing Python
# packages from source. Let 'pip install' upgrade pip, setuptools and
# wheel by whatever means it wants, ensuring that the dependencies of
# these bootstrapping packages are installed/upgraded as well.
if [ "${pip_install}" == "True" ] && [ "${python_installed}" == "False" ]; then
    tmp_pip_dir="${top_dir}/tmp/pip"
    export TMPDIR="${tmp_pip_dir}_tmp"
    for package in "pip" "setuptools" "wheel"; do
        current_step="upgrade/install of ${package}"
        heading "Upgrading/installing ${package}"
        set_status "Upgrading/installing ${package}"
        eval "package_version=\${${package}_version}"
        # Dependent on the version of pip,
        # the --no-cache-dir option may be available or not.
        pip_success="True"
        for extra_pip_arg in "--no-cache-dir" ""; do
            rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp" || :
            mkdir -p "${tmp_pip_dir}" "${tmp_pip_dir}_tmp"
            "${python}" -m pip install -v -v -v                  \
                                       ${extra_pip_arg}          \
                                       -b "${tmp_pip_dir}/build" \
                                       --upgrade                 \
                                       "${package}==${package_version}" 2>&1 || pip_success="False"
            if [ "${pip_success}" == "True" ]; then
                break
            fi
        done
        # Do not exit on failure, but write a warning
        if [ "${pip_success}" == "False" ]; then
            error "Could not upgrade ${package}"
        fi
    done
    reset_environment
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp" || :
fi

# Upgrade all packages pre-installed
# with the newly installed Python distribution.
if [ "${python_install}" == "True" ] && [ "${python_installed}" == "False" ]; then
    installed_packages_success="True"
    installed_packages="$("${python}" -m pip list --format=colu2mns 2>/dev/null)" \
        || installed_packages_success="False"
    if [ "${installed_packages_success}" == "False" ]; then
        installed_packages_success="True"
        installed_packages="$("${python}" -m pip list 2>/dev/null)" \
            || installed_packages_success="False"
    fi
    if [ "${installed_packages_success}" == "False" ]; then
        installed_packages="$("${python}" -c "
import pip
print('\n'.join([i.key for i in pip.get_installed_distributions()]))
")"
    fi
    installed_packages="$("${python}" -c "
packages = '''${installed_packages}'''.split('\n')
for i, package in enumerate(packages):
    if not package.strip().replace(' ', '').replace('-', ''):
        packages = packages[i+1:]
        break
print('\n'.join(packages))
" | awk '{print $1}')"
    while read package; do
        # No need to attempt updates of pip, setuptools and wheel,
        # as these have just been updated.
        if     [ "${package}" == "pip"        ] \
            || [ "${package}" == "setuptools" ] \
            || [ "${package}" == "wheel"      ]; then
            continue
        fi
        # Attempt to update all other installed Python packages
        for n in {1..50}; do
            pip_success="True"
            pip_install_pypackage "${package}" "upgrade" || pip_success="False"
            if [ "${pip_success}" == "True" ]; then
                break
            fi
        done
    done <<< "${installed_packages}"
fi

# Install Python packages from PyPI

# Blessings
if [ "${blessings_install}" == "True" ] && [ "${blessings_installed}" == "False" ]; then
    pip_install_pypackage "Blessings" "${blessings_version}"
fi

# Cython
if [ "${cython_install}" == "True" ] && [ "${cython_installed}" == "False" ]; then
    install_success="False"
    for compiler in "${compiler_possibilities[@]}"; do
        eval "use_${compiler}_compilers Cython" || continue
        pip_install_pypackage "Cython" "${cython_version}"
        if [ "$(check_pypackage_installed cython)" == "False" ]; then
            continue
        fi
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install Cython"
        exit 1
    fi
    reset_environment
fi

# CythonGSL
if [ "${cythongsl_install}" == "True" ] && [ "${cythongsl_installed}" == "False" ]; then
    install_success="False"
    for compiler in "${compiler_possibilities[@]}"; do
        reset_environment
        eval "use_${compiler}_compilers CythonGSL" || continue
        export LD_LIBRARY_PATH="${gsl_dir}/lib:${LD_LIBRARY_PATH}"
        pip_install_pypackage "CythonGSL" "${cythongsl_version}"
        if [ "$(check_pypackage_installed cythongsl)" == "False" ]; then
            continue
        fi
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install CythonGSL"
        exit 1
    fi
    reset_environment
fi

# pytest
if [ "${pytest_install}" == "True" ] && [ "${pytest_installed}" == "False" ]; then
    pip_install_pypackage "pytest" "${pytest_version}"
fi

# NumPy (manual invocation of setup.py is needed
# as we need to link to OpenBLAS).
if [ "${numpy_install}" == "True" ] && [ "${numpy_installed}" == "False" ]; then
    current_step="installation of NumPy ${numpy_version}"
    heading "Installing NumPy ${numpy_version}"
    set_status "Installing NumPy ${numpy_version}"
    # Download NumPy
    tmp_pip_dir="${top_dir}/tmp/pip"
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp" || :
    mkdir -p "${tmp_pip_dir}_tmp"
    export TMPDIR="${tmp_pip_dir}_tmp"
    pip_download "numpy" "${numpy_version}"
    cd "${tmp_pip_dir}"
    # It can happen that an archive format different from tar.gz is
    # downloaded, in which case the extraction will fail if the
    # corresponding tool is not installed. In that case, try to download
    # NumPy directly from GitHub
    extract "numpy"* "True" || :
    numpy_extract_success="False"
    for f in *; do
        f_lower="$(echo "${f}" | tr '[:upper:]' '[:lower:]')"
        if [ -d "${f}" ] && [[ "${f_lower}" == "numpy"* ]]; then
            numpy_extract_success="True"
            numpy_build_dir="${tmp_pip_dir}/${f}"
            break
        fi
    done
    if [ "${numpy_extract_success}" == "False" ]; then
        numpy_url="https://github.com/numpy/numpy/archive/v${numpy_version}.tar.gz"
        download "numpy"
        cd "${top_dir}/tmp/numpy"
        extract * "True"
        for f in *; do
            f_lower="$(echo "${f}" | tr '[:upper:]' '[:lower:]')"
            if [ -d "${f}" ] && [[ "${f_lower}" == "numpy"* ]]; then
                numpy_build_dir="${top_dir}/tmp/numpy/${f}"
                break
            fi
        done
    fi
    # Create a site.cfg file containing information about OpenBLAS
    echo "[DEFAULT]
library_dirs = ${blas_dir}/lib
include_dirs = ${blas_dir}/include

[ALL]
library_dirs = ${blas_dir}/lib
include_dirs = ${blas_dir}/include

[atlas]
atlas_libs = openblas
libraries = openblas

[openblas]
libraries = openblas
library_dirs = ${blas_dir}/lib
include_dirs = ${blas_dir}/include
runtime_library_dirs = ${blas_dir}/lib
" > "${numpy_build_dir}/site.cfg"
    # Build and install NumPy with OpenBLAS support.
    # We wish to use the gfortran Fortran compiler. We try out all the
    # compiler environments but overwriting the Fortran compiler.
    # If this fails, we retry without overwriting the Fortran compiler.
    # On some systems, several additional environment variables need to
    # be modified. We try all combinations until we hit a working one.
    cp -r "${numpy_build_dir}" "${numpy_build_dir}_cp"
    install_success="False"
    for pyuser in "" "--user"; do
        for numpy_gfortran in "True" "False"; do
            for compiler in "${compiler_possibilities[@]}"; do
                for fcompiler in "gnu95" ""; do
                    for extra_FCFLAGS in "" "-fPIC"; do
                        for extra_LDFLAGS in "" "-shared"; do
                            reset_environment
                            eval "use_${compiler}_compilers" || continue
                            printf "
Attempting to install NumPy with pyuser=${pyuser}, numpy_gfortran=${numpy_gfortran}, \
compiler=${compiler}, fcompiler=${fcompiler}, extra_FCFLAGS=${extra_FCFLAGS}, \
extra_LDFLAGS=${extra_LDFLAGS}\n\n"
                            if [ "${numpy_gfortran}" == "True" ]; then
                                export FC="gfortran"
                                export F77="gfortran"
                                export F90="gfortran"
                                export F9X="gfortran"
                            fi
                            export TMPDIR="${tmp_pip_dir}_tmp"
                            export BLAS="${blas_dir}/lib/libopenblas.a"
                            export LAPACK="${blas_dir}/lib/libopenblas.a"
                            export LD_LIBRARY_PATH="${blas_dir}/lib:${LD_LIBRARY_PATH}"
                            export FCFLAGS="${extra_FCFLAGS} ${FCFLAGS}"
                            export FFLAGS="${extra_FCFLAGS} ${FFLAGS}"
                            export LDFLAGS="${extra_LDFLAGS} ${LDFLAGS}"
                            rm -rf "${numpy_build_dir}" || :
                            cp -r "${numpy_build_dir}_cp" "${numpy_build_dir}"
                            cd "${numpy_build_dir}"
                            echo "True" > ".setuppy_success"
                            if [ -n "${fcompiler}" ]; then
                                ("${python}" setup.py build --fcompiler="${fcompiler}" \
                                    || echo "False" > ".setuppy_success") & setuppy_pid=$!
                            else
                                ("${python}" setup.py build \
                                    || echo "False" > ".setuppy_success") & setuppy_pid=$!
                            fi
                            soothe ${setuppy_pid}
                            sleep 1
                            setuppy_success="$(cat '.setuppy_success')"
                            if [ "${setuppy_success}" != "True" ]; then
                                continue
                            fi
                            "${python}" setup.py install ${pyuser} & setuppy_pid=$!
                            soothe ${setuppy_pid}
                            if [ "$(check_pypackage_installed numpy)" == "False" ]; then
                                continue
                            fi
                            install_success="True"
                            break
                        done
                        if [ "${install_success}" == "True" ]; then
                            break
                        fi
                    done
                    if [ "${install_success}" == "True" ]; then
                        break
                    fi
                done
                if [ "${install_success}" == "True" ]; then
                    break
                fi
            done
            if [ "${install_success}" == "True" ]; then
                break
            fi
        done
        if [ "${install_success}" == "True" ]; then
            break
        fi
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install NumPy"
        exit 1
    fi
    cd "${top_dir}"
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp" "${top_dir}/tmp/numpy" || :
    reset_environment
    # Test NumPy
    export LD_LIBRARY_PATH="${blas_dir}/lib:${LD_LIBRARY_PATH}"
    if [ "${do_tests}" == "True" ]; then
        "${python}" -c "import numpy; numpy.test('full', verbose=2, \
extra_argv=['--color=yes'])" 2>&1 | tee "${numpy_test_log}"
        [ ${PIPESTATUS[0]} -eq 0 ] || numpy_test_success="False"
        if [ "${numpy_test_success}" == "True" ]; then
            if tail -n 1 "${numpy_test_log}" | grep " failed" >/dev/null 2>&1; then
                numpy_test_success="False"
            fi
        fi
        if [ "${numpy_test_success}" == "True" ]; then
            rm -f "${numpy_test_log}" || :
        fi
    fi
    reset_environment
fi

# SciPy (manual invocation of setup.py is needed
# as we need to link to OpenBLAS).
if [ "${scipy_install}" == "True" ] && [ "${scipy_installed}" == "False" ]; then
    current_step="installation of SciPy ${scipy_version}"
    heading "Installing SciPy ${scipy_version}"
    set_status "Installing SciPy ${scipy_version}"
    # Download SciPy
    tmp_pip_dir="${top_dir}/tmp/pip"
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp" || :
    mkdir -p "${tmp_pip_dir}_tmp"
    export TMPDIR="${tmp_pip_dir}_tmp"
    pip_download "scipy" "${scipy_version}"
    cd "${tmp_pip_dir}"
    extract "scipy"* "True"
    for f in *; do
        f_lower="$(echo "${f}" | tr '[:upper:]' '[:lower:]')"
        if [ -d "${f}" ] && [[ "${f_lower}" == "scipy"* ]]; then
            scipy_build_dir="${tmp_pip_dir}/${f}"
            break
        fi
    done
    # Create a site.cfg file containing information about OpenBLAS
    echo "[DEFAULT]
library_dirs = ${blas_dir}/lib
include_dirs = ${blas_dir}/include

[ALL]
library_dirs = ${blas_dir}/lib
include_dirs = ${blas_dir}/include

[atlas]
atlas_libs = openblas
libraries = openblas

[openblas]
libraries = openblas
library_dirs = ${blas_dir}/lib
include_dirs = ${blas_dir}/include
runtime_library_dirs = ${blas_dir}/lib
" > "${scipy_build_dir}/site.cfg"
    # Build and install SciPy with OpenBLAS support.
    # We wish to use the gfortran Fortran compiler. We try out all the
    # compiler environments but overwriting the Fortran compiler.
    # If this fails, we retry without overwriting the Fortran compiler.
    # On some systems, several additional environment variables need to
    # be modified. We try all combinations until we hit a working one.
    cp -r "${scipy_build_dir}" "${scipy_build_dir}_cp"
    install_success="False"
    for pyuser in "" "--user"; do
        for scipy_gfortran in "True" "False"; do
            for compiler in "${compiler_possibilities[@]}"; do
                for fcompiler in "gnu95" ""; do
                    for extra_FCFLAGS in "" "-fPIC"; do
                        for extra_LDFLAGS in "" "-shared"; do
                            reset_environment
                            eval "use_${compiler}_compilers" || continue
                            printf "
Attempting to install SciPy with pyuser=${pyuser}, scipy_gfortran=${scipy_gfortran}, \
compiler=${compiler}, fcompiler=${fcompiler}, extra_FCFLAGS=${extra_FCFLAGS}, \
extra_LDFLAGS=${extra_LDFLAGS}\n\n"
                            if [ "${scipy_gfortran}" == "True" ]; then
                                export FC="gfortran"
                                export F77="gfortran"
                                export F90="gfortran"
                                export F9X="gfortran"
                            fi
                            export TMPDIR="${tmp_pip_dir}_tmp"
                            export TMPDIR="${tmp_pip_dir}_tmp"
                            export BLAS="${blas_dir}/lib/libopenblas.a"
                            export LAPACK="${blas_dir}/lib/libopenblas.a"
                            export LD_LIBRARY_PATH="${blas_dir}/lib:${LD_LIBRARY_PATH}"
                            export FCFLAGS="${extra_FCFLAGS} ${FCFLAGS}"
                            export FFLAGS="${extra_FCFLAGS} ${FFLAGS}"
                            export LDFLAGS="${extra_LDFLAGS} ${LDFLAGS}"
                            cd "${top_dir}"
                            rm -rf "${scipy_build_dir}" || :
                            cp -r "${scipy_build_dir}_cp" "${scipy_build_dir}"
                            cd "${scipy_build_dir}"
                            echo "True" > ".setuppy_success"
                            if [ -n "${fcompiler}" ]; then
                                ("${python}" setup.py build --fcompiler="${fcompiler}" \
                                    || echo "False" > ".setuppy_success") & setuppy_pid=$!
                            else
                                ("${python}" setup.py build \
                                    || echo "False" > ".setuppy_success") & setuppy_pid=$!
                            fi
                            soothe ${setuppy_pid}
                            sleep 1
                            setuppy_success="$(cat '.setuppy_success')"
                            if [ "${setuppy_success}" != "True" ]; then
                                continue
                            fi
                            "${python}" setup.py install ${pyuser} & setuppy_pid=$!
                            soothe ${setuppy_pid}
                            if [ "$(check_pypackage_installed scipy)" == "False" ]; then
                                continue
                            fi
                            install_success="True"
                            break
                        done
                        if [ "${install_success}" == "True" ]; then
                            break
                        fi
                    done
                    if [ "${install_success}" == "True" ]; then
                        break
                    fi
                done
                if [ "${install_success}" == "True" ]; then
                    break
                fi
            done
            if [ "${install_success}" == "True" ]; then
                break
            fi
        done
        if [ "${install_success}" == "True" ]; then
            break
        fi
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install SciPy"
        exit 1
    fi
    cd "${top_dir}"
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp" || :
    reset_environment
    # Test SciPy
    export LD_LIBRARY_PATH="${blas_dir}/lib:${LD_LIBRARY_PATH}"
    if [ "${do_tests}" == "True" ]; then
        # We skip the test_face test as this require bz2,
        # which may not be installed.
        "${python}" -c "import scipy; scipy.test('full', verbose=2, \
extra_argv=['--color=yes', '-k not test_face'])" 2>&1 | tee "${scipy_test_log}"
        [ ${PIPESTATUS[0]} -eq 0 ] || scipy_test_success="False"
        if [ "${scipy_test_success}" == "True" ]; then
            if tail -n 1 "${scipy_test_log}" | grep " failed" >/dev/null 2>&1; then
                scipy_test_success="False"
            fi
        fi
        if [ "${scipy_test_success}" == "True" ]; then
            rm -f "${scipy_test_log}" || :
        fi
    fi
    reset_environment
fi

# Matplotlib (as Matplotlib has a hard time finding FreeType,
# some hacks are needed).
if [ "${matplotlib_install}" == "True" ] && [ "${matplotlib_installed}" == "False" ]; then
    current_step="installation of Matplotlib ${matplotlib_version}"
    heading "Installing Matplotlib ${matplotlib_version}"
    set_status "Installing Matplotlib ${matplotlib_version}"
    # Download matplotlib itself
    tmp_pip_dir="${top_dir}/tmp/pip"
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp" || :
    mkdir -p "${tmp_pip_dir}_tmp"
    export TMPDIR="${tmp_pip_dir}_tmp"
    pip_download "matplotlib" "${matplotlib_version}"
    # Matplotlib depends on other Python packages not directly used
    # by COùòïCEPT. Most often these dependencies are downloaded
    # automatically by the previous command. In case of failure,
    # we do it manually.
    if [ "${numpy_preinstalled}" == "True" ] || [ "${numpy_install}" == "True" ]; then
        # NumPy already installed
        deps=(                \
            "pyparsing"       \
            "python-dateutil" \
            "pytz"            \
            "cycler"          \
            "six"             \
            "kiwisolver"      \
        )
        # From http://matplotlib.org/users/installing.html and matplotlib's setupext.py
        dep_versions=(
            ">=2.0.1,!=2.0.4,!=2.1.2,!=2.1.6" \
            ">=2.1"                           \
            ""                                \
            ">=0.10.0"                        \
            ">=1.10"                          \
            ">=1.0.1"                         \
        )
    else
        # NumPy not installed. Add it as a matplotlib dependency
        deps=(                \
            "numpy"           \
            "pyparsing"       \
            "python-dateutil" \
            "pytz"            \
            "cycler"          \
            "six"             \
            "kiwisolver"      \
        )
        # From http://matplotlib.org/users/installing.html and matplotlib's setupext.py
        dep_versions=(
            ">=1.10.0"                        \
            ">=2.0.1,!=2.0.4,!=2.1.2,!=2.1.6" \
            ">=2.1"                           \
            ""                                \
            ">=0.10.0"                        \
            ">=1.10"                          \
            ">=1.0.1"                         \
        )
    fi
    # An illegal version of pyparsing may be downloaded by Matplotlib!
    pyparsing_downloaded="$(ls "${top_dir}/tmp/pip" | grep -i "pyparsing" || :)"
    illegal_pyparsings=("2.0.0" "2.0.4" "2.1.2" "2.1.6")
    for ((i=0; i<${#illegal_pyparsings[@]}; i+=1)); do
        if [[ "${pyparsing_downloaded}" == "pyparsing-${illegal_pyparsings[i]}"* ]]; then
            # Illegal pyparsing downloaded!
            rm -rf "${top_dir}/tmp/pip/pyparsing"* || :
            break
        fi
    done
    for ((i=0; i<${#deps[@]}; i+=1)); do
        if ! ls "${top_dir}/tmp/pip" | grep -i "${deps[i]}" > /dev/null 2>&1; then
            pip_download "${deps[i]}" "${dep_versions[i]}"
        fi
    done
    # Install matplotlib
    cd "${tmp_pip_dir}"
    extract "matplotlib"* "True"
    for f in *; do
        f_lower="$(echo "${f}" | tr '[:upper:]' '[:lower:]')"
        if [ -d "${f}" ] && [[ "${f_lower}" == "matplotlib"* ]]; then
            cd "${f}"
            break
        fi
    done
    cp "setup.cfg.template" "setup.cfg"
    freetype_include2="$(echo "${freetype_dir}/include/freetype"* | awk '{print $NF}')"
    libpng_version_majors="$(echo "${libpng_version}" | grep -m 1 -o -P "[0-9]*\.[0-9]*" \
                                                      | head -n 1)"
    libpng_version_majors="$(echo "${libpng_version_majors//./}")"
    basedirlist="${freetype_dir},\
${freetype_dir}/include,\
${freetype_include2},\
${freetype_dir}/lib,\
${libpng_dir},\
${libpng_dir}/include,\
${libpng_dir}/lib,\
${libpng_dir}/include/libpng${libpng_version_majors},\
${zlib_dir},\
${zlib_dir}/include,\
${zlib_dir}/lib\
"
    sed -i "/basedirlist/c\basedirlist = ${basedirlist}" "setup.cfg"
    cp -r "${freetype_include2}/"* "${freetype_dir}/include/"
    export CPPFLAGS="-I${freetype_dir}/include                              \
                     -I${freetype_include2}                                 \
                     -I${libpng_dir}/include                                \
                     -I${libpng_dir}/include/libpng${libpng_version_majors} \
                     -I${zlib_dir}/include ${CPPFLAGS}"
    export LDFLAGS="-L${freetype_dir}/lib          \
                    -Wl,-rpath=${freetype_dir}/lib \
                    -L${libpng_dir}/lib            \
                    -Wl,-rpath=${libpng_dir}/lib   \
                    -L${zlib_dir}/lib              \
                    -Wl,-rpath=${zlib_dir}/lib ${LDFLAGS}"
    export PATH="${freetype_dir}/bin:${libpng_dir}/bin:${PATH}"
    export LD_LIBRARY_PATH="${libpng_dir}/lib:${LD_LIBRARY_PATH}"
    export LD_LIBRARY_PATH="${zlib_dir}/lib:${LD_LIBRARY_PATH}"
    export LD_LIBRARY_PATH="${blas_dir}/lib:${LD_LIBRARY_PATH}"
    export PKG_CONFIG_PATH="${libpng_dir}/lib/pkgconfig:\
${zlib_dir}/lib/pkgconfig:${PKG_CONFIG_PATH}"
    # After the adoption of PEP 518 (pip 10), some packages require
    # wheels (not bare source) when building. This can be disabled by
    # supplying --no-build-isolation. We try both.
    # Some times the installation process will appear to hang,
    # but it will eventually get going. When this is the case,
    # write a soothing message.
    for extra_pip_arg in "" "--no-build-isolation"; do
        "${python}" -m pip install -v -v -v                          \
                                   ${extra_pip_arg}                  \
                                   -b "${top_dir}/tmp/pip/build"     \
                                   --no-index                        \
                                   --find-links="${top_dir}/tmp/pip" \
                                   . 2>&1 & pip_install_pid=$!
        soothe ${pip_install_pid}
        pypackage_installed=$(check_pypackage_installed matplotlib)
        if [ "${pypackage_installed}" == "True" ]; then
            break
        fi
        if [ -z "${extra_pip_arg}" ]; then
            printf "\nFailed to install matplotlib. Now trying with --no-build-isolation\n\n"
        fi
    done
    reset_environment
    cd "${top_dir}"
    # Exit if installation failed
    if [ "${pypackage_installed}" == "False" ]; then
        error "Could not install matplotlib"
        exit 1
    fi
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp" || :
fi

# MPI4Py
if [ "${mpi4py_install}" == "True" ] && [ "${mpi4py_installed}" == "False" ]; then
    install_success="False"
    for fun in "use_specified_mpi_compilers" ""; do
        reset_environment
        if [ -n "${fun}" ]; then
            eval "${fun}"
        fi
        export PATH="${mpi_bindir}:${mpi_compilerdir}:${PATH}"
        pip_install_pypackage "MPI4Py" "${mpi4py_version}" || continue
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install MPI4Py"
        exit 1
    fi
    reset_environment
fi

# H5Py
if [ "${h5py_install}" == "True" ] && [ "${h5py_installed}" == "False" ]; then
    install_success="False"
    for fun in "use_specified_mpi_compilers" ""; do
        reset_environment
        if [ -n "${fun}" ]; then
            eval "${fun}"
        fi
        export LD_LIBRARY_PATH="${hdf5_dir}/lib:${LD_LIBRARY_PATH}"
        if [ -d "${blas_dir}/lib" ]; then
            export LD_LIBRARY_PATH="${blas_dir}/lib:${LD_LIBRARY_PATH}"
        fi
        export HDF5_DIR="${hdf5_dir}"
        export HDF5_MPI="ON"
        export CC="${mpicc}"
        pip_install_pypackage "h5py" "${h5py_version}" || continue
        install_success="True"
        break
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install H5Py"
        exit 1
    fi
    reset_environment
fi



###########################
# Install and patch CLASS #
###########################
if [ "${class_install}" == "True" ] && [ "${class_installed}" == "False" ]; then
    init_install "CLASS"
    # Move the content of the current directory (the files of CLASS,
    # except .gitignore) to the CLASS installation directory.
    mkdir -p "${class_dir}"
    mv ./* "${class_dir}/"
    cd "${class_dir}"
    # Below we will do a lot of patching on the CLASS source code.
    # To aid us, we define the following function.
    patch_class(){
        filename="$1"
        local linenr="$2"
        action="$3"
        belonging="$4"
        new_lines="$5"
        wrap_in_comments="$6"
        # Determine file type ("c" or "python")
        extension="${filename##*.}"
        filetype=""
        if     [ "${extension}" == "c"   ] \
            || [ "${extension}" == "h"   ] \
            || [ "${extension}" == "cpp" ]; then
            filetype="c"
        elif   [ "${extension}" == "py"  ] \
            || [ "${extension}" == "pyx" ] \
            || [ "${extension}" == "pxd" ]; then
            filetype="python"
        fi
        # Add comments around inserted lines
        if [ "${wrap_in_comments}" != "False" ]; then
            if [ "${filetype}" == "c" ]; then
                new_lines=(""                      \
                    "/************************/"   \
                    "/* For use with CONCEPT */"   \
                    "/************************/"   \
                    "${new_lines[@]}"              \
                    "/**************************/" \
                    "/* ^For use with CONCEPT^ */" \
                    "/**************************/" \
                    ""                             \
                )
            elif [ "${filetype}" == "python" ]; then
                new_lines=(""                    \
                    "########################"   \
                    "# For use with CONCEPT #"   \
                    "########################"   \
                    "${new_lines[@]}"            \
                    "##########################" \
                    "# ^For use with CONCEPT^ #" \
                    "##########################" \
                    ""                           \
                )
            fi
        fi
        # Find indentation at linenr
        indentation=""
        if [ "${belonging}" == "below" ]; then
            n_lines=$(wc -l "${filename}" | awk '{print $1}')
            ((n_lines_down = n_lines - linenr + 1))
            content="$(tail -n ${n_lines_down} "${filename}")"
        elif [ "${belonging}" == "above" ]; then
            ((n_lines_down = linenr - 1))
            content="$(head -n ${n_lines_down} "${filename}" | tac)"
        fi
        local IFS=''
        while read -r line; do
            if [ -n "${line// }" ]; then
                line_unindented="$(echo "${line}" | awk '{gsub(/^ +/,"")} {print $0}')"
                ((indentation_size = ${#line} - ${#line_unindented})) || :
                if [ "${filetype}" == "c" ] && [ "${line_unindented:0:1}" == "}" ]; then
                    ((indentation_size += 2))
                fi
                indentation="$(printf "%${indentation_size}s")"
                break
            fi
        done <<< "${content}"
        # Construct string of indented lines from the new_lines array
        new_line_nr=0
        for new_line in "${new_lines[@]}"; do
            if [ -n "${new_line}" ]; then
                indentation_use="${indentation}"
            else
                indentation_use=""
            fi
            if [ ${new_line_nr} -eq 0 ]; then
                new_lines_str="\\${indentation_use}${new_line}"
            else
                new_lines_str="${new_lines_str}\n${indentation_use}${new_line}"
            fi
            ((new_line_nr += 1))
        done
        # Insert the new lines in the file
        if [ "${action}" == "insert" ]; then
            sed -i "${linenr}i${new_lines_str}" "${filename}"
        elif [ "${action}" == "replace" ]; then
            sed -i "${linenr}d" "${filename}"
            sed -i "${linenr}i${new_lines_str}" "${filename}"
        fi
    }
    # Change the values of some preprocessing directives
    # in header files, allowing larger inputs and outputs.
    # Specifically, these are the changes:
    # _MAXTITLESTRINGLENGTH_   = 10‚Å∂  (in include/common.h)
    # _LINE_LENGTH_MAX_        = 10‚Å¥  (in include/parser.h)
    # _ARGUMENT_LENGTH_MAX_    = 10‚Å¥  (in include/parser.h)
    # _MAX_NUMBER_OF_K_FILES_  = 10‚Åµ  (in include/perturbations.h)
    value=1000000
    sed -i "s/^\( *#define \+_MAXTITLESTRINGLENGTH_ \+\)[^ ]*\(.*\)*$/\1${value}\2/" \
           "${class_dir}/include/common.h"
    value=10000
    sed -i "s/^\( *#define \+_LINE_LENGTH_MAX_ \+\)[^ ]*\(.*\)*$/\1${value}\2/" \
           "${class_dir}/include/parser.h"
    value=10000
    sed -i "s/^\( *#define \+_ARGUMENT_LENGTH_MAX_ \+\)[^ ]*\(.*\)*$/\1${value}\2/" \
           "${class_dir}/include/parser.h"
    value=100000
    sed -i "s/^\( *#define \+_MAX_NUMBER_OF_K_FILES_ \+\)[^ ]*\(.*\)*$/\1${value}\2/" \
           "${class_dir}/include/perturbations.h"
    # As only the (relatively) late-time evolution is needed from CLASS,
    # we hardcode the perturbations output to only be printed here.
    a_min="3e-4"
    pattern=' +a *= *pvecback'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    ((linenr += 1))
    new_lines=(                                  \
        "/* Only return output at late times */" \
        "double a_min = ${a_min};"               \
        "if (a < a_min)"                         \
        "  return _SUCCESS_;"                    \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "below" "${new_lines[@]}"
    # When using the Runge-Kutta evolver, the derivatives are only
    # computed at the beginning of each time step, which is not
    # necessarily precise enough. Here we remove the derivative
    # computation in tools/evolver_rkck.c entirely and place it
    # in the perturb_print_variables function of
    # source/perturbations.c instead. This also ensures that
    # e.g. the ppw struct has been updated correctly
    # when it is time to print the perturbation results.
    pattern='( *x1 *== *x_ini *)'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/tools/evolver_rkck.c" | head -n 1)
    new_lines=(                                          \
        "/* derivs will be called in print_variables */" \
        "if (0 == 1) {  /* (x1 == x_ini) { */"           \
    )
    patch_class "${class_dir}/tools/evolver_rkck.c" ${linenr} "replace" "below" "${new_lines[@]}"
    pattern='double *\\* *dataptr *;'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    ((linenr += 1))
    new_lines=(                                                                  \
        "/**"                                                                    \
        " * Compute perturbation derivatives. This also ensure that the"         \
        " * ppw (and other) structs are up-to-date. This is important"           \
        " * when using the Runge-Kutta evolver, as this is otherwise"            \
        " * not taken care off correctly."                                       \
        " */"                                                                    \
        "class_call("                                                            \
        "  perturb_derivs(tau, y, dy, parameters_and_workspace, error_message)," \
        "  error_message,"                                                       \
        "  error_message);"                                                      \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "below" "${new_lines[@]}"
    # Include ncdm Psi0[q] in perturbation output
    include_ncdm_Psi0="False"
    if [ "${include_ncdm_Psi0}" == "True" ]; then
        pattern=' *char +tmp *\\[ *40 *\\] *;'
        linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
            "${class_dir}/source/perturbations.c" | head -n 1)
        new_lines=(           \
            "char tmp[1024];" \
            "int index_q;"    \
        )
        patch_class "${class_dir}/source/perturbations.c" ${linenr} \
            "replace" "below" "${new_lines[@]}"
        pattern='sprintf *\\( *tmp *, *\"cs2_ncdm\\[%d\\]\" *, *n_ncdm *\\) *;'
        linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
            "${class_dir}/source/perturbations.c" | head -n 1)
        ((linenr += 2))
        new_lines=(                                                                   \
            "/* Include ncdm Psi0[q] in perturbation output */"                       \
            "for (index_q=0; index_q<pba->q_size_ncdm[n_ncdm]; index_q++) {"          \
            "  sprintf(tmp,\"Psi0[%d](%.16f)\",n_ncdm,pba->q_ncdm[n_ncdm][index_q]);" \
            "  class_store_columntitle(ppt->scalar_titles,tmp,_TRUE_);"               \
            "}"                                                                       \
        )
        patch_class "${class_dir}/source/perturbations.c" ${linenr} \
            "insert" "below" "${new_lines[@]}"
        pattern="class_store_double *\\\\( *dataptr *, \
*delta_p_over_delta_rho_ncdm *\\\\[ *n_ncdm *\\\\] *,"
        linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
            "${class_dir}/source/perturbations.c" | head -n 1)
        ((linenr += 1))
        new_lines=(                                                            \
            "/* Include ncdm Psi0[q] in perturbation output */"                \
            "if (ppw->approx[ppw->index_ap_ncdmfa] == (int)ncdmfa_on) {"       \
            "  for (index_q=0; index_q<pba->q_size_ncdm[n_ncdm]; index_q++) {" \
            "    class_store_double(dataptr, 0.0, _TRUE_, storeidx);"          \
            "  }"                                                              \
            "}"                                                                \
            "else {"                                                           \
            "  idx = ppw->pv->index_pt_psi0_ncdm1;"                            \
            "  for (index_q=0; index_q<pba->q_size_ncdm[n_ncdm]; index_q++) {" \
            "    class_store_double(dataptr, y[idx], _TRUE_, storeidx);"       \
            "    /* Jump to next momentum bin */"                              \
            "    idx += (ppw->pv->l_max_ncdm[n_ncdm]+1);"                      \
            "  }"                                                              \
            "}"                                                                \
        )
        patch_class "${class_dir}/source/perturbations.c" ${linenr} \
            "insert" "below" "${new_lines[@]}"
    fi
    # Correctly implement the fld pressure perturbation,
    # both with and without PPF.
    pattern='double *rho_plus_p_theta_fld *;'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/include/perturbations.h" | head -n 1)
    ((linenr += 1))
    new_lines=(                                                                               \
"double delta_p_fld;  /**< pressure perturbation of fluid, very non-trivial in PPF scheme */" \
    )
    patch_class "${class_dir}/include/perturbations.h" ${linenr} \
        "insert" "above" "${new_lines[@]}"
    pattern='/\\* *fluid *contribution *\\*/'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    ((linenr += 1))
    new_lines=(                                                                                  \
        "/**"                                                                                    \
        " * Count up total pressure and conformal time derivative of pressure,"                  \
        " * excluding the fld species. These are used for the PPF formalism of fld."             \
        " */"                                                                                    \
        "double p_tot = 0.;"                                                                     \
        "double p_tot_prime = 0.;"                                                               \
        "if (pba->has_fld == _TRUE_ && pba->use_ppf == _TRUE_) {"                                \
        "  /* Photons */"                                                                        \
        "  p_tot += 1./3.*ppw->pvecback[pba->index_bg_rho_g];"                                   \
        "  p_tot_prime += -3.*a_prime_over_a*(1. + 1./3.)*1./3."                                 \
        "    *ppw->pvecback[pba->index_bg_rho_g];"                                               \
        "  /* Baryons have no pressure */"                                                       \
        "  /* Ultra relativistic species */"                                                     \
        "  if (pba->has_ur == _TRUE_) {"                                                         \
        "    p_tot += 1./3.*ppw->pvecback[pba->index_bg_rho_ur];"                                \
        "    p_tot_prime += -3.*a_prime_over_a*(1. + 1./3.)*1./3."                               \
        "      *ppw->pvecback[pba->index_bg_rho_ur];"                                            \
        "  }"                                                                                    \
        "  /* Cold dark matter has no pressure */"                                               \
        "  /* Non-cold dark matter */"                                                           \
        "  if (pba->has_ncdm == _TRUE_) {"                                                       \
        "    for(n_ncdm = 0; n_ncdm < pba->N_ncdm; n_ncdm++) {"                                  \
        "      p_tot += ppw->pvecback[pba->index_bg_p_ncdm1 + n_ncdm];"                          \
        "      p_tot_prime += -a_prime_over_a*(5.*ppw->pvecback[pba->index_bg_p_ncdm1 + n_ncdm]" \
        "        - ppw->pvecback[pba->index_bg_pseudo_p_ncdm1 + n_ncdm]);"                       \
        "    }"                                                                                  \
        "  }"                                                                                    \
        "  /* Decaying cold dark matter has no pressure */"                                      \
        "  /* Decay radiation */"                                                                \
        "  if (pba->has_dr == _TRUE_) {"                                                         \
        "    p_tot += 1./3.*ppw->pvecback[pba->index_bg_rho_dr];"                                \
        "    p_tot_prime += -3.*a_prime_over_a*(1. + 1./3.)*1./3."                               \
        "      *ppw->pvecback[pba->index_bg_rho_dr]"                                             \
        "      + 1./3.*a*pba->Gamma_dcdm*ppw->pvecback[pba->index_bg_rho_dcdm];"                 \
        "  }"                                                                                    \
        "  /* Importantly, we skip the dark energy fluid */"                                     \
        "  /* Scalar field */"                                                                   \
        "  if (pba->has_scf == _TRUE_) {"                                                        \
        "    p_tot += ppw->pvecback[pba->index_bg_p_scf];"                                       \
        "    p_tot_prime += -a_prime_over_a/(a*a)*ppw->pvecback[pba->index_bg_phi_prime_scf]"    \
        "      *ppw->pvecback[pba->index_bg_phi_prime_scf]"                                      \
        "      - 2./3.*ppw->pvecback[pba->index_bg_dV_scf]"                                      \
        "        *ppw->pvecback[pba->index_bg_phi_prime_scf];"                                   \
        "  }"                                                                                    \
        "  /* Lambda has constant pressure */"                                                   \
        "}"                                                                                      \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} \
        "insert" "above" "${new_lines[@]}"
    for n in $(grep -n 'class_call *( *background_w_fld *(' "${class_dir}/source/perturbations.c" \
        | awk '{print $1}'); do
        n="${n//:}"
        if [ ${n} -gt ${linenr} ]; then
            ((linenr = n + 1))
            new_lines=(                                                 \
                "double w_prime_fld = dw_over_da_fld*a_prime_over_a*a;" \
            )
            patch_class "${class_dir}/source/perturbations.c" ${linenr} \
                "insert" "above" "${new_lines[@]}"
            break
        fi
    done
    for n in $(grep -n 'ppw *-> *rho_plus_p_theta_fld *=' "${class_dir}/source/perturbations.c" \
        | awk '{print $1}'); do
        n="${n//:}"
        if [ ${n} -gt ${linenr} ]; then
            ((linenr = n + 1))
            new_lines=(                                                                          \
                "/* Pressure perturbation of fld without PPF */"                                 \
                "double ca2_fld = w_fld - w_prime_fld/(3.*a_prime_over_a*(1. + w_fld));"         \
                "ppw->delta_p_fld = pba->cs2_fld*ppw->delta_rho_fld"                             \
                "  + (pba->cs2_fld - ca2_fld)*(3.*a_prime_over_a*ppw->rho_plus_p_theta_fld/k2);" \
            )
            patch_class "${class_dir}/source/perturbations.c" ${linenr} \
                "insert" "above" "${new_lines[@]}"
            break
        fi
    done
    pattern='s2sq *= ppw *->'
    linenr_1=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    ((linenr_1 += 1))
    pattern='ppw *-> *S_fld *='
    linenr_2=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    ((linenr_2 -= 1))
    sed -i "${linenr_1},${linenr_2}d" "${class_dir}/source/perturbations.c"
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    new_lines=(                                                                                  \
        "double alpha_prime, X, Y, Z, X_prime, Y_prime, Z_prime;"                                \
        "double rho_plus_p_theta_fld_prime, metric_euler;"                                       \
        "double rho_t, rho_t_prime, p_t, p_t_prime, rho_fld, rho_fld_prime, p_fld, p_fld_prime;" \
        "double H, H_prime;"                                                                     \
        "double theta_t,theta_t_prime, S, S_prime;"                                              \
        "if (ppt->gauge == synchronous) {"                                                       \
        "  alpha = (y[ppw->pv->index_pt_eta] + 1.5*a2/k2/s2sq*(ppw->delta_rho"                   \
        "    + 3.*a_prime_over_a/k2*ppw->rho_plus_p_theta)"                                      \
        "    - y[ppw->pv->index_pt_Gamma_fld])/a_prime_over_a;"                                  \
        "  alpha_prime = -2.*a_prime_over_a*alpha + y[ppw->pv->index_pt_eta]"                    \
        "    - 4.5*(a2/k2)*ppw->rho_plus_p_shear;"                                               \
        "  metric_euler = 0.;"                                                                   \
        "} else {"                                                                               \
        "  alpha = 0.;"                                                                          \
        "  alpha_prime = 0.;"                                                                    \
        "  metric_euler = k2*y[ppw->pv->index_pt_phi] - 4.5*a2*ppw->rho_plus_p_shear;"           \
        "}"                                                                                      \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} \
        "insert" "above" "${new_lines[@]}"
    pattern='ppw->delta_rho_fld *='
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | tail -n 1)
    ((linenr += 1))
    new_lines=(                                                                                 \
        "rho_t = rho_plus_p_tot - p_tot;"                                                       \
        "p_t = p_tot;"                                                                          \
        "rho_t_prime = -3.*a_prime_over_a*(rho_t + p_t);"                                       \
        "p_t_prime = p_tot_prime;"                                                              \
        "rho_fld = ppw->pvecback[pba->index_bg_rho_fld];"                                       \
        "p_fld = w_fld*rho_fld;"                                                                \
        "rho_fld_prime = -3.*a_prime_over_a*(rho_fld + p_fld);"                                 \
        "p_fld_prime = w_prime_fld*rho_fld - 3.*a_prime_over_a*(1. + w_fld)*p_fld;"             \
        ""                                                                                      \
        "H = ppw->pvecback[pba->index_bg_H];"                                                   \
        "H_prime = ppw->pvecback[pba->index_bg_H_prime];"                                       \
        "X = c_gamma_k_H_square;"                                                               \
        "X_prime = -2.*X*(a_prime_over_a + H_prime/H);"                                         \
        "Y = 4.5*a2/k2/s2sq*(rho_t + p_t);"                                                     \
        "Y_prime = Y*(2.*a_prime_over_a + (rho_t_prime + p_t_prime)/(rho_t + p_t));"            \
        "Z = 2./3.*k2*H/a;"                                                                     \
        "Z_prime = Z*(H_prime/H - a_prime_over_a);"                                             \
        ""                                                                                      \
        "theta_t = ppw->rho_plus_p_theta/rho_plus_p_tot;"                                       \
        "theta_t_prime = -a_prime_over_a*theta_t + (-p_t_prime*theta_t + k2*ppw->delta_p"       \
        "  - k2*ppw->rho_plus_p_shear)/rho_plus_p_tot+metric_euler;"                            \
        ""                                                                                      \
        "S = ppw->S_fld;"                                                                       \
        "S_prime = -Z_prime/Z*S + 1./Z*(rho_fld_prime + p_fld_prime)*(theta_t + k2*alpha)"      \
        "  + 1./Z*(rho_fld + p_fld)*(theta_t_prime + k2*alpha_prime);"                          \
        "rho_plus_p_theta_fld_prime = Z_prime*(S - 1./(1. + Y)*(S/(1. + 1./X)"                  \
        "  + y[ppw->pv->index_pt_Gamma_fld]*X))"                                                \
        "  + Z*(S_prime + Y_prime/(1. + Y*Y + 2.*Y)*(S/(1. + 1./X)"                             \
        "    + y[ppw->pv->index_pt_Gamma_fld]*X)"                                               \
        "    - 1./(1. + Y)*(S_prime/(1. + 1./X) + S*X_prime/(1. + X*X + 2.*X)"                  \
        "      + ppw->Gamma_prime_fld*X + y[ppw->pv->index_pt_Gamma_fld]*X_prime))"             \
        "  - k2*alpha_prime*(rho_fld + p_fld) - k2*alpha*(rho_fld_prime + p_fld_prime);"        \
        ""                                                                                      \
        "ppw->delta_p_fld = (rho_plus_p_theta_fld_prime"                                        \
        "  + 4.*a_prime_over_a*ppw->rho_plus_p_theta_fld - (rho_fld + p_fld)*metric_euler)/k2;" \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} \
        "insert" "above" "${new_lines[@]}"
    pattern='ppw *-> *delta_p *\\+= *pba *-> *cs2_fld *\\* *ppw *-> *delta_rho_fld *;'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    new_lines=(                             \
        "ppw->delta_p += ppw->delta_p_fld;" \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} \
        "replace" "above" "${new_lines[@]}"
    # For the PPF scheme, include a maximum value for (c_Œì*k*a/H)¬≤ above
    # which Œì = Œì' = 0, for the sake of numerical stability. In CAMB
    # such a maximum value is present as well and is set to 30. I have
    # found that a value of 10¬≥ or even 10‚Å¥ ensures stability as well,
    # while perturbing the fld Œ¥_fld, Œ∏_fld and Œ¥p_fld solutions
    # significantly less. Instead of a discontinuities cutoff as
    # in CAMB, we implement a smooth transition to zero, as defects in
    # Œ¥_fld, Œ∏_fld and Œ¥p_fld have been observed otherwise.
    pattern='c_gamma_k_H_square *='
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    sed -i "${linenr}d" "${class_dir}/source/perturbations.c"
    pattern='s2sq *= ppw *->'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    ((linenr += 1))
    new_lines=(                                                                                   \
        "/**"                                                                                     \
        " * The computation of Gamma_fld and Gamma_prime_fld becomes unstable"                    \
        " * at large c_Gamma*k/H. To stabilise the system we set these to zero"                   \
        " * at some large c_Gamma*k/(aH)."                                                        \
        " * As to not introduce discontinuities, we have a smooth transition"                     \
        " * phase between the untouched values and completely nullified values."                  \
        " * This transition is given the shape of an error function in"                           \
        " * log(c_Gamma*k/(aH)) space. The parameters c_gamma_k_H_square_max_{0|1}"               \
        " * specify the borders of the transition."                                               \
        " * Here we nullify/shrink Gamma_fld only."                                               \
        " */"                                                                                     \
        "double Gamma_fld, Gamma_weight, Gamma_weight_steepness;"                                 \
        "double c_gamma_k_H_square_max_0, c_gamma_k_H_square_max_1;"                              \
        "c_gamma_k_H_square_max_0 = 1e+3;"                                                        \
        "c_gamma_k_H_square_max_1 = 1e+4;"                                                        \
        "c_gamma_k_H_square = pow(pba->c_gamma_over_c_fld*k/a_prime_over_a, 2)*pba->cs2_fld;"     \
        "if (c_gamma_k_H_square > c_gamma_k_H_square_max_1){"                                     \
        "    Gamma_fld = 0.;"                                                                     \
        "} else {"                                                                                \
        "  Gamma_fld = y[ppw->pv->index_pt_Gamma_fld];"                                           \
        "  if (c_gamma_k_H_square > c_gamma_k_H_square_max_0){"                                   \
        "    Gamma_weight_steepness = 5.; /* 5 results in double precision perfect transition */" \
        "    Gamma_weight = 0.5*(erf(Gamma_weight_steepness*("                                    \
        "      0.5*(log(c_gamma_k_H_square_max_0) + log(c_gamma_k_H_square_max_1))"               \
        "      - log(c_gamma_k_H_square)"                                                         \
        "    )) + 1.);"                                                                           \
        "    Gamma_fld *= Gamma_weight;"                                                          \
        "  }"                                                                                     \
        "}"                                                                                       \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} \
        "insert" "above" "${new_lines[@]}"
    pattern='double *alpha_prime *, *X *, *Y *, *Z'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    replacements_todo=7
    replacements=0
    for n in $(grep -n 'y *\[ *ppw *-> *pv *-> *index_pt_Gamma_fld *\]' \
        "${class_dir}/source/perturbations.c" | awk '{print $1}'); do
        n="${n//:}"
        if [ ${n} -ge ${linenr} ]; then
            sed -i "${n}s/y *\[ *ppw *-> *pv *-> *index_pt_Gamma_fld *\]/Gamma_fld/" \
                "${class_dir}/source/perturbations.c"
            ((replacements += 1))
            if [ ${replacements} -eq ${replacements_todo} ]; then
                break
            fi
        fi
    done
    pattern='ppw->Gamma_prime_fld *='
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    new_lines=(                                                                         \
        "/* Nullify/shrink Gamma_prime_fld as done for Gamma_fld above */"              \
        "if (c_gamma_k_H_square > c_gamma_k_H_square_max_1){"                           \
        "    ppw->Gamma_prime_fld = 0.;"                                                \
        "} else {"                                                                      \
        "  ppw->Gamma_prime_fld = a_prime_over_a*(ppw->S_fld/(1. + c_gamma_k_H_square)" \
        "    - (1. + c_gamma_k_H_square)*Gamma_fld);"                                   \
        "  if (c_gamma_k_H_square > c_gamma_k_H_square_max_0){"                         \
        "      ppw->Gamma_prime_fld *= Gamma_weight;"                                   \
        "  }"                                                                           \
        "}"                                                                             \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} \
        "replace" "above" "${new_lines[@]}"
    # Include fld in perturbation output
    new_class_perturbation_linenr(){
        if [ "${1}" == "perturb_prepare_output" ]; then
            pattern='ppt *-> *number_of_scalar_titles *='
            linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
                "${class_dir}/source/perturbations.c" | head -n 1)
            ((linenr -= 1))
        elif [ "${1}" == "perturb_print_variables" ]; then
            pattern="class_store_double *\\\\( *dataptr *, *theta_scf *, *pba *-> *has_scf *, \
*storeidx *\\\\)*;"
            linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
                "${class_dir}/source/perturbations.c" | head -n 1)
            n_lines_total=$(wc -l "${class_dir}/source/perturbations.c" | awk '{print $1}')
            ((n_lines_down = n_lines_total - linenr))
            local IFS=''
            while read -r line; do
                ((linenr += 1))
                if [[ "${line}" == "  }" ]]; then
                    break
                fi
            done <<< "$(tail -n ${n_lines_down} "${class_dir}/source/perturbations.c")"
        fi
        echo ${linenr}
    }
    linenr=$(new_class_perturbation_linenr "perturb_prepare_output")
    new_lines=(                                                                       \
        "/* Include fld in perturbation output */"                                    \
        "class_store_columntitle(ppt->scalar_titles, \"delta_fld\", pba->has_fld);"   \
        "class_store_columntitle(ppt->scalar_titles, \"theta_fld\", pba->has_fld);"   \
        "/**"                                                                         \
        " * We choose to store cs2_fld = delta_p_fld/delta_rho_fld rather than"       \
        " * simply delta_p_fld itself, as is done for massive neutrinos."             \
        " */"                                                                         \
        "class_store_columntitle(ppt->scalar_titles, \"cs2_fld\", pba->has_fld);"     \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "below" "${new_lines[@]}"
    linenr=$(new_class_perturbation_linenr "perturb_print_variables")
    new_lines=(                                                                             \
        "/* Include fld in perturbation output */"                                          \
        "double w_fld, dw_over_da_fld, integral_fld, theta_fld;"                            \
        "if (pba->has_fld) {"                                                               \
        "  class_call(background_w_fld(pba, a, &w_fld, &dw_over_da_fld, &integral_fld),"    \
        "    pba->error_message, ppt->error_message);"                                      \
        "  class_store_double(dataptr, ppw->delta_rho_fld/pvecback[pba->index_bg_rho_fld]," \
        "    pba->has_fld, storeidx);"                                                      \
        "  /* For w_fld = -1 (Lambda), we have theta = 0 */"                                \
        "  if (w_fld == -1.) {"                                                             \
        "    theta_fld = 0.;"                                                               \
        "  }"                                                                               \
        "  else {"                                                                          \
        "    theta_fld = ppw->rho_plus_p_theta_fld/"                                        \
        "      ((1. + w_fld)*pvecback[pba->index_bg_rho_fld]);"                             \
        "  }"                                                                               \
        "  class_store_double(dataptr, theta_fld, pba->has_fld, storeidx);"                 \
        "  /**"                                                                             \
        "   * We choose to store cs2_fld = delta_p_fld/delta_rho_fld rather than"           \
        "   * simply delta_p_fld itself, as is done for massive neutrinos."                 \
        "   *"                                                                              \
        "   */"                                                                             \
        "  class_store_double(dataptr,"                                                     \
        "    ppw->delta_p_fld/ppw->delta_rho_fld, pba->has_fld, storeidx);"                 \
        "}"                                                                                 \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "below" "${new_lines[@]}"
    # Include dcdm in the growth factor D(a)
    pattern='rho_M * \\+='
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/background.c" | head -n 1)
    ((linenr += 1))
    new_lines=(                                        \
        "/* Include dcdm in growth factor */"          \
        "if (pba->has_dcdm == _TRUE_)"                 \
        "  rho_M += pvecback[pba->index_bg_rho_dcdm];" \
    )
    patch_class "${class_dir}/source/background.c" ${linenr} \
        "insert" "below" "${new_lines[@]}"
    # Include theta_tot in perturbation output
    linenr=$(new_class_perturbation_linenr "perturb_prepare_output")
    new_lines=(                                                               \
        "/* Include theta_tot in perturbation output */"                      \
        "class_store_columntitle(ppt->scalar_titles, \"theta_tot\", _TRUE_);" \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "below" "${new_lines[@]}"
    linenr=$(new_class_perturbation_linenr "perturb_print_variables")
    new_lines=(                                                                                  \
        "/* Include theta_tot in perturbation output */"                                         \
        "double rho_plus_p_tot = -2./3.*pvecback[pba->index_bg_H_prime]/a + 2./3.*pba->K/(a*a);" \
        "double theta_tot = ppw->rho_plus_p_theta/rho_plus_p_tot;"                               \
        "class_store_double(dataptr, theta_tot, _TRUE_, storeidx);"                              \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "below" "${new_lines[@]}"
    # Include h_prime in perturbation output
    linenr=$(new_class_perturbation_linenr "perturb_prepare_output")
    new_lines=(                                                                                \
        "/* Include h_prime in perturbation output */"                                         \
        "class_store_columntitle(ppt->scalar_titles, \"h_prime\", ppt->gauge == synchronous);" \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "below" "${new_lines[@]}"
    linenr=$(new_class_perturbation_linenr "perturb_print_variables")
    new_lines=(                                                          \
        "/* Include h_prime in perturbation output */"                   \
        "class_store_double(dataptr, pvecmetric[ppw->index_mt_h_prime]," \
        "  ppt->gauge == synchronous, storeidx);"                        \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "below" "${new_lines[@]}"
    # Include H_T_prime in perturbation output
    linenr=$(new_class_perturbation_linenr "perturb_prepare_output")
    new_lines=(                                                               \
        "/* Include H_T_prime (in N-body gauge) in perturbation output */"    \
        "class_store_columntitle(ppt->scalar_titles, \"H_T_prime\", _TRUE_);" \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "below" "${new_lines[@]}"
    linenr=$(new_class_perturbation_linenr "perturb_print_variables")
    new_lines=(                                                                             \
        "/**"                                                                               \
        " * Include H_T_prime (in N-body gauge) in perturbation output."                    \
        " * Here we make use of rho_plus_p_tot defined earlier."                            \
        " */"                                                                               \
        "double p_tot_prime = 0.0;"                                                         \
        "/* Photons */"                                                                     \
        " p_tot_prime += -3.*a*H*(1. + 1./3.)*1./3.*pvecback[pba->index_bg_rho_g];"         \
        "/* Baryons have no pressure */"                                                    \
        "/* Ultra relativistic species */"                                                  \
        "if (pba->has_ur == _TRUE_)"                                                        \
        "  p_tot_prime += -3.*a*H*(1. + 1./3.)*1./3.*pvecback[pba->index_bg_rho_ur];"       \
        "/* Cold dark matter has no pressure */"                                            \
        "/* Non-cold dark matter */"                                                        \
        "if (pba->has_ncdm == _TRUE_) {"                                                    \
        "  for(n_ncdm=0; n_ncdm < pba->N_ncdm; n_ncdm++)"                                   \
        "    p_tot_prime += -a*H*(5.*pvecback[pba->index_bg_p_ncdm1+n_ncdm]"                \
        "    - pvecback[pba->index_bg_pseudo_p_ncdm1+n_ncdm]);"                             \
        "}"                                                                                 \
        "/* Decaying cold dark matter has no pressure */"                                   \
        "/* Decay radiation */"                                                             \
        "if (pba->has_dr == _TRUE_)"                                                        \
        "  p_tot_prime += -3.*a*H*(1. + 1./3.)*1./3.*pvecback[pba->index_bg_rho_dr]"        \
        "    + 1./3.*a*pba->Gamma_dcdm*pvecback[pba->index_bg_rho_dcdm];"                   \
        "/* Dark energy fluid */"                                                           \
        "if (pba->has_fld == _TRUE_) {"                                                     \
        "  p_tot_prime += a*H*pvecback[pba->index_bg_rho_fld]"                              \
        "    *(a*dw_over_da_fld - 3.*w_fld*(1. + w_fld));"                                  \
        "}"                                                                                 \
        "/* Scalar field */"                                                                \
        "if (pba->has_scf == _TRUE_) {"                                                     \
        "  p_tot_prime += -H/a*pvecback[pba->index_bg_phi_prime_scf]"                       \
        "    *pvecback[pba->index_bg_phi_prime_scf]"                                        \
        "    - 2./3.*pvecback[pba->index_bg_dV_scf]*pvecback[pba->index_bg_phi_prime_scf];" \
        "}"                                                                                 \
        "/* Lambda has constant pressure */"                                                \
        "double H_T_prime = 3.*a*H/rho_plus_p_tot*("                                        \
        "  - ppw->delta_p"                                                                  \
        "  + p_tot_prime*theta_tot/(k*k)"                                                   \
        "  + ppw->rho_plus_p_shear);"                                                       \
        "class_store_double(dataptr, H_T_prime, _TRUE_, storeidx);"                         \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "below" "${new_lines[@]}"
    # Do not convert synchronous variables to Newtonian gauge
    pattern='converting *synchronous *variables *to *newtonian *ones'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
        "${class_dir}/source/perturbations.c" | head -n 1)
    ((linenr += 1))
    new_lines=(                                              \
        "/* Do not convert to Newtonian gauge */"            \
        "if (0 == 1) {  /* (ppt->gauge == synchronous) { */" \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "replace" "below" "${new_lines[@]}"
    # Add integers 'node', 'num_threads' and 'indentation' to the
    # classy.Class initializer as optional arguments and store them in
    # the 'background' struct. Here 'node' and 'indentation' will be
    # used to make CLASS print out correctly indented (with regard to
    # COùòïCEPT) status updates during perturbation computations, when the
    # perturbations_verbose parameter is negative. The 'num_threads'
    # integer will hold the number of MPI processes on the local node,
    # which signals the number of OpenMP threads to use.
    linenr_1="$(grep -n 'struct background' "${class_dir}/include/background.h" | head -n 1)"
    linenr_1="${linenr_1%%:*}"
    i=0
    while :; do
        ((i += 1))
        linenr_2="$(grep -n '};' "${class_dir}/include/background.h" | head -n ${i} | tail -n 1)"
        linenr_2="${linenr_2%%:*}"
        if [ ${linenr_2} -gt ${linenr_1} ]; then
            break
        fi
    done
    new_lines=(                                                \
        "/**"                                                  \
        " * Used to set number of OpenMP threads and to print" \
        " * status updates during perturbation computations."  \
        " */"                                                  \
        "int node, num_threads, indentation;"                  \
    )
    patch_class "${class_dir}/include/background.h" ${linenr_2} "insert" "below" "${new_lines[@]}"
    linenr="$(grep -n "__cinit__" "${class_dir}/python/classy.pyx")"
    linenr="${linenr%%:*}"
    sed -i "${linenr}s/.*/    def __cinit__(self, \
        default=False, node=0, num_threads=1, indentation=0): \
        # Changed for use with CONCEPT/" "${class_dir}/python/classy.pyx"
    ((linenr += 1))
    new_lines=(                                  \
        "self.ba.node = <int>node"               \
        "self.ba.num_threads = <int>num_threads" \
        "self.ba.indentation = <int>indentation" \
    )
    patch_class "${class_dir}/python/classy.pyx" ${linenr} "insert" "below" "${new_lines[@]}"
    linenr_1="$(grep -n 'cdef struct background:' "${class_dir}/python/cclassy.pxd")"
    linenr_1="${linenr_1%%:*}"
    i=0
    while :; do
        ((i += 1))
        linenr_2="$(grep -n 'cdef struct' "${class_dir}/python/cclassy.pxd" \
            | head -n ${i} | tail -n 1)"
        linenr_2="${linenr_2%%:*}"
        if [ ${linenr_2} -eq ${linenr_1} ]; then
            ((i += 1))
            linenr_2="$(grep -n 'cdef struct' "${class_dir}/python/cclassy.pxd" \
                | head -n ${i} | tail -n 1)"
            linenr_2="${linenr_2%%:*}"
            while :; do
                ((linenr_2 -= 1))
                line="$(sed "${linenr_2}!d" "${class_dir}/python/cclassy.pxd")"
                if [ -n "${line}" ]; then
                    break
                fi
            done
            ((linenr_2 += 1))
            break
        fi
    done
    new_lines=(           \
        "int node"        \
        "int num_threads" \
        "int indentation" \
    )
    patch_class "${class_dir}/python/cclassy.pxd" ${linenr_2} "insert" "above" "${new_lines[@]}"
    linenr="$(grep -n 'for (index_k = ppt->k_size\[index_md\]-1; index_k >=0; index_k--)' \
        "${class_dir}/source/perturbations.c")"
    linenr="${linenr%%:*}"
    ((linenr += 1))
    new_lines=(                                                                   \
        "if ((abort == _FALSE_) && (ppt->perturbations_verbose < 0)) {"           \
        "  printf("                                                               \
        "    \"%*sNode %d, thread %d: Evolving mode k = %.3e/Mpc (%d/%d)\\\\n\"," \
        "    pba->indentation, \"\","                                             \
        "    pba->node,"                                                          \
        "    thread,"                                                             \
        "    ppt->k[index_md][index_k],"                                          \
        "    index_k+1,"                                                          \
        "    ppt->k_size[index_md]"                                               \
        "  );"                                                                    \
        "  fflush(stdout);"                                                       \
        "}"                                                                       \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "below" "${new_lines[@]}"
    pattern='#pragma *omp *parallel'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" "${class_dir}/source/perturbations.c" \
        | head -n 1)
    new_lines=(                                                                  \
        "if (pba->num_threads != -1) {"                                          \
        "  /**"                                                                  \
        "   * Explicitly set the number of OpenMP threads."                      \
        "   * Note that the value of OMP_NUM_THREADS is now completely ignored." \
        "   */"                                                                  \
        "  omp_set_num_threads(pba->num_threads);"                               \
        "}"                                                                      \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "above" "${new_lines[@]}"
    # Build CLASS, including the Python wrapper classy. We explicitly
    # specify Python 3 as the language level and replace -O4 with -O3
    # (which are equivalent on compilers that recognize -O4).
    # We try with and without the -fast-math option, try different
    # commpilers and various flags for correctly linking to OpenMP.
    sed -i '1s/^/# cython: language_level=3\n/' "python/classy.pyx"
    sed -i 's/-O4/-O3/' "Makefile"
    cp "Makefile" "Makefile_ori"
    cp "python/setup.py" "python/setup.py_ori"
    install_success="False"
    for lgomp_in_extra_link_args in "" "-gomp"; do
        for compiler in "${compiler_possibilities[@]}"; do
            for OMPFLAG in "-fopenmp" "-openmp" "-qopenmp"; do
                for fast_math in "True" "False"; do
                    reset_environment
                    cp "Makefile_ori" "Makefile"
                    cp "python/setup.py_ori" "python/setup.py"
                    make clean || :
                    export LD_LIBRARY_PATH="${blas_dir}/lib:${LD_LIBRARY_PATH}"
                    eval "use_${compiler}_compilers CLASS" || continue
                    if [ "${fast_math}" == "False" ]; then
                        sed -i '0,/-ffast-math/s/-ffast-math/#-ffast-math/' "Makefile"
                    fi
                    if [ -n "${CC}" ]; then
                        sed -i "s/CC * =/CC = ${CC//\//\/}  #/" "Makefile"
                    fi
                    if [ -n "${OMPFLAG}" ]; then
                        sed -i "s/OMPFLAG *=/OMPFLAG = ${OMPFLAG}  #/" "Makefile"
                    fi
                    sed -i "s/extra_link_args *=/extra_link_args=\
'${lgomp_in_extra_link_args} ${OMPFLAG}'.split(),  #/" "python/setup.py"
                    printf "
Attempting to install CLASS with lgomp_in_extra_link_args=${lgomp_in_extra_link_args}, \
compiler=${compiler}, OMPFLAG=${OMPFLAG}, fast_math=${fast_math}\n\n"
                    PYTHON="${python}" make ${make_jobs} 2>&1 || continue
                    "${python}" -c "import classy; classy.Class().compute()" || continue
                    install_success="True"
                    break
                done
                if [ "${install_success}" == "True" ]; then
                    break
                fi
            done
            if [ "${install_success}" == "True" ]; then
                break
            fi
        done
        if [ "${install_success}" == "True" ]; then
            break
        fi
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install CLASS"
        exit 1
    fi
    reset_environment
    # Test CLASS
    if [ "${do_tests}" == "True" ]; then
        export LD_LIBRARY_PATH="${blas_dir}/lib:${LD_LIBRARY_PATH}"
        # We do not use the builtin test_class.py, as this require tens
        # of gigabytes and uses the Nose and parameterized Python
        # packages. Instead we perform a simple test of our own,
        # which only does a background computation.
        if ! "${python}" -c "
import sys
from classy import Class
cosmo = Class()
cosmo.compute()
sys.exit(int(cosmo.get_background()['proper time [Gyr]'][-1]) != 13)
"; then
            class_test_success="False"
        fi
        if [ "${class_test_success}" == "False" ]; then
            echo "CLASS did not pass a simple background computation test" \
               > "${class_test_log}"
        fi
    fi
    reset_environment
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/class" || :
    install_notice "CLASS" "${class_dir}"
fi



###################################
# Install the COùòïCEPT code itself #
###################################
# Paths used by COùòïCEPT
concept="${concept_dir}/concept"
ics_dir="${concept_dir}/ICs"
logs_dir="${concept_dir}/logs"
output_dir="${concept_dir}/output"
params_dir="${concept_dir}/params"
reusables_dir="${concept_dir}/.reusables"
tests_dir="${concept_dir}/tests"
utilities_dir="${concept_dir}/utilities"
Gadget2_dir="${gadget_dir}/Gadget2"
installer="${top_dir}/installer"
mpiexec="${mpi_bindir}/mpiexec"
# Move source files, create empty directories and create the .paths file
if [ "${concept_install}" == "True" ] && [ "${concept_installed}" == "False" ]; then
    init_install "CONCEPT"
    # Move everything from the concept-${concept_version}
    # directory to ${top_dir}.
    if [ -f "${top_dir}/installer" ]; then
        # An installation script already exists in the directory where
        # the downloaded installation script for the installed COùòïCEPT
        # version should go. This pre-existing installation script might
        # be the very file running now, and so it is not safe to
        # overwrite it. Instead, move the new installation script there
        # under a new name, reflecting its version.
        mv "installer" "${top_dir}/installer_${concept_version}"
    fi
    mv ./{.[!.],}* "${top_dir}/"
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/concept" || :
    # Create directories
    mkdir -p "${ics_dir}"
    mkdir -p "${logs_dir}"
    mkdir -p "${output_dir}"
    mkdir -p "${params_dir}"
    # Add PATH-like and a few PYTHON environment variables present at
    # install time (now) to the .env file.
    current_step="addition of PATH-like and PYTHON environment variables to the .env file"
    printf "\nAdding PATH-like and PYTHON environment variables to .env\n"
    set_status "Adding PATH-like and PYTHON environment variables to .env"
    "${python}" -c "
import os
with open('${env_file}', 'r', encoding='utf-8') as file:
    lines = file.readlines()
# Generator for extracting environment variables
def get_envs():
    for var, val in os.environ.items():
        if (
            # PATH, LD_LIBRARY_PATH, ...
            ('path' in var.lower() and (val.startswith('/') or val.startswith(':')))
            # Intel license file
            or (var in {'INTEL_LICENSE_FILE', 'INTEL_LICENCE_FILE'} and val.startswith('/'))
        ):
            yield var, val
# Add environment variables
envs_inserted = False
with open('${env_file}', 'w', encoding='utf-8') as file:
    for line in lines:
        if not envs_inserted and 'Update the environment' in line:
            print('# The following has been placed by the installer script', file=file)
            if '${python_install}' == 'True':
                print('unset PYTHONPATH', file=file)
                print('export PYTHONNOUSERSITE=\"True\"', file=file)
            print('pathenv_name_value_pairs_installtime=( \\\\', file=file)
            for var, val in get_envs():
                print(f'    {var} \"{val}\" \\\\', file=file)
            print(')', file=file)
            print('', file=file)
            envs_inserted = True
        print(line, end='', file=file)
"
    # Create the .paths file,
    # storing important paths used by COùòïCEPT.
    current_step="creation of the .paths file"
    printf "\nWriting paths to .paths\n"
    set_status "Writing paths to .paths"
    echo "# This file contains absolute paths to directories and files
# used by the COùòïCEPT code. You may manually edit these paths.

#######################
# COùòïCEPT directories #
#######################
# Directory containing the source code
concept_dir='${concept_dir}'
# Directory intended for initial conditions
ics_dir='${ics_dir}'
# Directory containing the log files
logs_dir='${logs_dir}'
# Directory intended for output
output_dir='${output_dir}'
# Directory intended for parameter files
params_dir='${params_dir}'
# Directory containing various reusable dumps
reusables_dir='${reusables_dir}'
# Directory containing tests
tests_dir='${tests_dir}'
# Top level directory, containing e.g. README.md
top_dir='${top_dir}'
# Directory containing utilities
utilities_dir='${utilities_dir}'

##########################
# Dependency directories #
##########################
# Directory of BLAS
blas_dir='${blas_dir}'
# Directory of CLASS
class_dir='${class_dir}'
# Directory of FFTW
fftw_dir='${fftw_dir}'
# Directory of FFTW2, used by GADGET
fftw_for_gadget_dir='${fftw_for_gadget_dir}'
# Directory of Gadget2
gadget_dir='${gadget_dir}'
# Directory containing the GADGET2 source code
Gadget2_dir='${Gadget2_dir}'
# Directory of GSL
gsl_dir='${gsl_dir}'
# Directory of HDF5
hdf5_dir='${hdf5_dir}'
# Directory of libpng
libpng_dir='${libpng_dir}'
# Directories of MPI
mpi_dir='${mpi_dir}'
mpi_compilerdir='${mpi_compilerdir}'
mpi_bindir='${mpi_bindir}'
mpi_libdir='${mpi_libdir}'
mpi_includedir='${mpi_includedir}'
mpi_symlinkdir='${mpi_symlinkdir}'
# Directory of Python
python_dir='${python_dir}'
# Directory of zlib
zlib_dir='${zlib_dir}'

#########
# Files #
#########
# The executable script of the COùòïCEPT code
concept='${concept}'
# The file containing environment variables
env_file='${env_file}'
# The installer script
installer='${installer}'
# The MPI C compiler
mpicc='${mpicc}'
# The MPI executable
mpiexec='${mpiexec}'
# The file containing paths (this file)
paths_file='${paths_file}'
# The Python interpreter
python='${python}'
" > "${paths_file}"
    # COùòïCEPT will be tested later
fi



#####################################################
# Install GADGET, used for testing the COùòïCEPT code #
#####################################################
# FFTW 2.x (GADGET2 is incompatible with FFTW 3.x)
if [ "${fftw_for_gadget_install}" == "True" ] \
    && [ "${fftw_for_gadget_installed}" == "False" ]; then
    install_success="False"
    fftw_for_gadget_test_success_backup="${fftw_for_gadget_test_success}"
    enable_mpi=""
    if [ -n "${mpi_dir}" ]; then
        enable_mpi="--enable-mpi"
    fi
    for enable_shared in "--enable-shared" ""; do
        for shared in "" "-shared"; do
            if [ -z "${enable_shared}" ] && [ -n "${shared}" ]; then
                continue
            fi
            for with_pic in "" "--with-pic"; do
                for PIC in "-fPIC" ""; do
                    for extra_MPILIBS in "" "-lmpi" "-lmpich"; do
                        if [ -z "${enable_mpi}" ] && [ -n "${extra_MPILIBS}" ]; then
                            continue
                        fi
                        reset_environment
                        init_install "FFTW for GADGET"
                        printf "
Attempting to install FFTW for GADGET with enable_shared=${enable_shared}, with_pic=${with_pic}, \
PIC=${PIC}, shared=${shared}, extra_MPILIBS=${extra_MPILIBS}\n\n"
                        export CFLAGS="-O3 ${PIC} ${CFLAGS}"
                        export CXXFLAGS="-O3 ${PIC} ${CXXFLAGS}"
                        export LDFLAGS="${LDFLAGS} ${shared} ${PIC}"
                        if [ -n "${enable_mpi}" ]; then
                            use_specified_mpi_compilers
                            export MPICC="${CC}"
                            export MPILIBS="${extra_MPILIBS} ${MPILIBS}"
                        fi
                        # Intel compilers may link against the NUMA library, which should be
                        # placed in /usr/lib64. Add this directory to the LDFLAGS.
                        # Both libnuma.so and libnuma.so.1 should exist. To be sure,
                        # we create symlinks to these in a new directory and add this
                        # directory to LDFLAGS as well.
                        if [ -d "/usr/lib64" ]; then
                            export LDFLAGS="${LDFLAGS} -L/usr/lib64"
                        fi
                        numa_symlink_dir="${fftw_for_gadget_dir}/numa_symlinks"
                        rm -rf "${numa_symlink_dir}" || :
                        mkdir -p "${numa_symlink_dir}" || :
                        if [ -f "/usr/lib64/libnuma.so" ] && [ ! -f "/usr/lib64/libnuma.so.1" ]; then
                            ln -s "/usr/lib64/libnuma.so" "${numa_symlink_dir}/libnuma.so.1" || :
                        fi
                        if [ -f "/usr/lib64/libnuma.so.1" ] && [ ! -f "/usr/lib64/libnuma.so" ]; then
                            ln -s "/usr/lib64/libnuma.so.1" "${numa_symlink_dir}/libnuma.so" || :
                        fi
                        export LDFLAGS="${LDFLAGS} -L${numa_symlink_dir}"
                        # Double-precision
                        ./configure ${enable_shared}     \
                                    ${enable_mpi}        \
                                    --enable-type-prefix \
                                    --disable-fortran    \
                                    ${with_pic}          \
                                    --prefix="${fftw_for_gadget_dir}" 2>&1 || continue
                        make ${make_jobs} 2>&1 || continue
                        if [ "${do_tests}" == "True" ]; then
                            make ${make_jobs} check 2>&1 | tee "test_log"
                            fftw_for_gadget_test_success="${fftw_for_gadget_test_success_backup}"
                            [ ${PIPESTATUS[0]} -eq 0 ] || fftw_for_gadget_test_success="False"
                        fi
                        make ${make_jobs} install 2>&1 || continue
                        # Single-precision
                        make clean || :
                        ./configure ${enable_shared}     \
                                    ${enable_mpi}        \
                                    --enable-float       \
                                    --enable-type-prefix \
                                    --disable-fortran    \
                                    ${with_pic}          \
                                    --prefix="${fftw_for_gadget_dir}" 2>&1 || continue
                        make ${make_jobs}         2>&1 || continue
                        make ${make_jobs} install 2>&1 || continue
                        install_success="True"
                        break
                    done
                    if [ "${install_success}" == "True" ]; then
                        break
                    fi
                done
                if [ "${install_success}" == "True" ]; then
                    break
                fi
            done
            if [ "${install_success}" == "True" ]; then
                break
            fi
        done
        if [ "${install_success}" == "True" ]; then
            break
        fi
    done
    if [ "${install_success}" == "False" ]; then
        error "Failed to install FFTW for GADGET"
        exit 1
    fi
    if [ "${fftw_for_gadget_test_success}" == "False" ]; then
        mkdir -p "$(dirname "${fftw_for_gadget_test_log}")"
        cp "test_log" "${fftw_for_gadget_test_log}"
    fi
    reset_environment
    cp "COPYING" "README" "${fftw_for_gadget_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/fftw_for_gadget" || :
    install_notice "FFTW for GADGET" "${fftw_for_gadget_dir}"
fi

# GADGET
if [ "${gadget_install}" == "True" ] && [ "${gadget_installed}" == "False" ]; then
    init_install "GADGET"
    mkdir -p "${gadget_dir}"
    mv ./* "${gadget_dir}/"
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/gadget" || :
    # GADGET will be tested as part of the COùòïCEPT test suite
    install_notice "GADGET" "${gadget_dir}"
fi



##############################
# Testing GADGET and COùòïCEPT #
##############################
if [ "${concept_install}" == "True" ] && [ "${concept_installed}" == "False" ]; then
    if [ "${do_tests}" == "True" ]; then
        # Run basic COùòïCEPT test to test the environment
        current_step="basic test of ${esc_concept}"
        heading "Basic test of ${esc_concept}"
        set_status "Basic test of ${esc_concept}"
        cd "${concept_dir}"
        "${concept}" -t "basic" 2>&1 | tee "${concept_test_log}"
        [ ${PIPESTATUS[0]} -eq 0 ] || concept_test_success="False"
        if  [ "${gadget_install}" == "True" ]; then
            # Run GADGET test
            # if basic COùòïCEPT test finished successfully
            if [ "${concept_test_success}" == "True" ]; then
                current_step="testing GADGET"
                heading "Testing GADGET"
                set_status "Testing GADGET"
                "${concept}" -t "gadget" 2>&1 | tee "${gadget_test_log}"
                [ ${PIPESTATUS[0]} -eq 0 ] || gadget_test_success="False"
                # Clean test_log if test is successfull
                if [ "${gadget_test_success}" == "True" ]; then
                    rm -f "${gadget_test_log}" || :
                fi
            fi
            # Run complete COùòïCEPT test suite if basic COùòïCEPT test
            # finished successfully.
            if [ "${concept_test_success}" == "True" ]; then
                current_step="testing ${esc_concept}"
                heading "Testing ${esc_concept}"
                set_status "Testing ${esc_concept}"
                "${concept}" -t "all" 2>&1 | tee "${concept_test_log}"
                [ ${PIPESTATUS[0]} -eq 0 ] || concept_test_success="False"
                # Clean test_log if test is successfull
                if [ "${concept_test_success}" == "True" ]; then
                    rm -f "${concept_test_log}" || :
                    # Note that this also removes
                    # the ${top_dir}/tmp directory.
                    make distclean || :
                fi
            fi
        fi
        cd "${top_dir}"
    fi
    # Place the installation notice in the GADGET directory in order
    # to minimize the number of files in the COùòïCEPT directory.
    install_notice "CONCEPT" "${gadget_dir}"
fi



#############################
# Final cleanup and notices #
#############################
# Make sure that the tmp directory is removed. This may fail on clusters
# with the nfs file system ("Device or resource busy") due to still
# running background processes holding .nfs... files open.
rm -rf "${top_dir}/tmp" || :
# Remove the Python cache generated by all the Python invocations
# during the install.
rm -rf "${top_dir}/__pycache__" || :
# Pytest may leave a cache directory
rm -rf "${top_dir}/.pytest_cache" || :
# Remove miscellaneous files which may be left
# by one of the installations.
rm -rf "${top_dir}/_configtest"* || :
rm -f "${top_dir}/gramA" "${top_dir}/gramB" || :
# Copyright notice
disable_status
copyright_notice(){
    # Arguments: Program/package name, text if installed by this script
    if eval "[ \"\${${1}_install}\" == \"True\" ]"; then
        printf "${2}\n"
    fi
}
if [ "${install_anything}" == "True" ] && [ "${say_copyright}" != "False" ]; then
    current_step="copyright notice"
    heading "Copyright notice"
    if [ "${concept_install}" == "True" ]; then
        printf "${esc_concept} has been installed along with the following dependencies:\n"
    else
        printf "The following software have been installed:\n"
    fi
    copyright_notice "blas"            "OpenBLAS"
    copyright_notice "class"           "CLASS"
    copyright_notice "fftw"            "FFTW 3"
    copyright_notice "fftw_for_gadget" "FFTW 2"
    copyright_notice "freetype"        "FreeType"
    copyright_notice "gadget"          "GADGET"
    copyright_notice "gsl"             "GSL"
    copyright_notice "hdf5"            "HDF5"
    copyright_notice "libpng"          "libpng"
    if [ "${mpi}" == "mpich" ]; then
        copyright_notice "mpi"         "MPICH"
    elif [ "${mpi}" == "openmpi" ]; then
        copyright_notice "mpi"         "OpenMPI"
    fi
    copyright_notice "ncurses"         "ncurses"
    copyright_notice "openssl"         "OpenSSL"
    copyright_notice "perl"            "Perl"
    copyright_notice "zlib"            "zlib"
    copyright_notice "python"          "Python"
    copyright_notice "blessings"       "$(printf ${en_quad}%.s {1..4})Blessings"
    copyright_notice "cython"          "$(printf ${en_quad}%.s {1..4})Cython"
    copyright_notice "cythongsl"       "$(printf ${en_quad}%.s {1..4})CythonGSL"
    copyright_notice "h5py"            "$(printf ${en_quad}%.s {1..4})H5Py"
    copyright_notice "matplotlib"      "$(printf ${en_quad}%.s {1..4})Matplotlib"
    copyright_notice "mpi4py"          "$(printf ${en_quad}%.s {1..4})MPI4Py"
    copyright_notice "numpy"           "$(printf ${en_quad}%.s {1..4})NumPy"
    copyright_notice "pytest"          "$(printf ${en_quad}%.s {1..4})pytest"
    copyright_notice "scipy"           "$(printf ${en_quad}%.s {1..4})SciPy"
    printf "\nThese have been installed into separate directories in
\"${top_dir}\"
Any use of ${esc_concept} must conform to the license terms of the above
software in addition to its own. These can be found in the separate
installation directories.\n"
fi
# Notice about test errors
current_step="erroneous tests notice"
any_test_error_notices="False"
erroneous_test_notice(){
    # Arguments: Program name, [alternative message]
    progname="${1// /_}"
    progname="$(echo "${progname}" | tr '[:upper:]' '[:lower:]')"
    test_success="True"
    eval "test_success=\"\${${progname}_test_success}\""
    if [ "${test_success}" == "False" ]; then
        if [ "${any_test_error_notices}" == "False" ]; then
            # First test error notice
            heading "Erroneous tests notice"
            any_test_error_notices="True"
        else
            # Add newline between notices
            echo
        fi
        eval "test_log_path=\"\${${progname}_test_log}\""
        printf "${esc_bold}${esc_red}Warning: ${esc_normal}"
        real_name="${1/CONCEPT/$esc_concept}"
        if [ "${real_name}" == "MPI" ]; then
            if [ "${mpi}" == "mpich" ]; then
                real_name="MPICH"
            elif [ "${mpi}" == "openmpi" ]; then
                real_name="OpenMPI"
            fi
        fi
        printf "Some tests of ${real_name} did not pass successfully.\n"
        if [ -n "${2}" ]; then
            printf "${2}\n"
            if [ "${progname}" != "concept" ] && [ "${concept_test_success}" != "False" ]; then
                printf "As ${esc_concept} do seem to function correctly, "
                printf "you may choose to disregard this.\n"
            fi
        else
            printf "As ${real_name} did seem to install correctly, "
            printf "this is usually not of any concern.\n"
        fi
        printf "The logged output of the tests can be found in\n"
        printf "\"${test_log_path}\"\n"
    fi
}
erroneous_test_notice "CLASS"
erroneous_test_notice "FFTW"
erroneous_test_notice "FFTW for GADGET"
erroneous_test_notice "FreeType"
erroneous_test_notice "GADGET"
erroneous_test_notice "GSL"
erroneous_test_notice "HDF5"
erroneous_test_notice "libpng"
erroneous_test_notice "MPI"
erroneous_test_notice "ncurses"
erroneous_test_notice "NumPy"
erroneous_test_notice "OpenSSL"
erroneous_test_notice "Perl"
erroneous_test_notice "Python"
erroneous_test_notice "SciPy"
erroneous_test_notice "zlib"
erroneous_test_notice "CONCEPT" \
                      "${esc_italic}This should usually be taken seriously!${esc_no_italic}"
if [ "${any_test_error_notices}" == "True" ]; then
    printf "\nThe logged output of the entire installation process can be found in\n"
    printf "\"${log}\"\n"
    printf "while the logged warnings and errors can be found in\n"
    printf "\"${log}_err\"\n"
fi

# Subprocess complete
printf "\n\n\n"
disable_status
if [ "${any_test_error_notices}" == "False" ]; then
    successfully_finish_status
fi
# Deactivate traps before exiting subprocess
trap : 0
) >> "${log}") 3>&1 1>&2 2>&3 & echo $! > "${top_dir}/.log_pid") \
    | tee -a "${log}_err" 3>&1 1>&2 2>&3 &
# Wait for the .log_pid file to be created
slept=0
while [ ! -f "${top_dir}/.log_pid" ]; do
    sleep 1
    ((slept += 1))
    if [ ${slept} -eq 30 ]; then
        break
    fi
done
log_pid=$(cat "${top_dir}/.log_pid")
rm -f "${top_dir}/.log_pid" || :
# End of subprocess #
#####################



################
# Display loop #
################
# Wait for the install log to be created
slept=0
while [ ! -f "${log}" ]; do
    sleep 1
    ((slept += 1))
    if [ ${slept} -eq 30 ]; then
        error "Could not create the log file \"${log}\""
        exit 1
    fi
done

# Continuously print the tail of the install log
((n_lines_to_skip = log_file_lines_before_install + 2))
display_loop(){
    local IFS=''
    printf "\n\n"
    tail -n +${n_lines_to_skip} -f "${log}" --pid ${log_pid} | while read -r line; do
        # Print out the lines, formatted nicely
        if [[ "${line}" == "${status_prefix}"* ]]; then
            status_backup_="${status}"
            status=${line:${status_prefix_length}}
            if [ "${status}" == "${status_disable}" ]; then
                # Disable status
                status_visible="${status_off}"
                status_backup="${status_backup_}"
                printf "${esc_up}${esc_erase}"
                printf "${esc_up}"
            elif [ "${status}" == "${status_enable}" ]; then
                # Enable status
                status_visible="${status_on}"
                status="${status_backup}"
                printf "\n${esc_bold}${esc_reverted}${status}${esc_normal}\n"
            elif [ "${status}" == "${status_finish}" ]; then
                # Display loop complete. Do nothing
                :
            elif [ "${status_visible}" == "${status_on}" ]; then
                # Normal status update
                printf "${esc_up}${esc_erase}"
                printf "${esc_up}"
                printf "\n${esc_bold}${esc_reverted}${status}${esc_normal}\n"
            fi
        else
            if [ "${status_visible}" == "${status_on}" ]; then
                # Line with status enabled
                printf "${esc_up}${esc_erase}"
                printf "${esc_up}"
                printf "%s\n" "${line}"
                printf "\n${esc_bold}${esc_reverted}${status}${esc_normal}\n"
            else
                # Line with status disabled
                printf "%s\n" "${line}"
            fi
        fi
    done
}
display_loop

# Installation complete
installation_guaranteed_successful="False"
if [ "${do_tests}" == "True" ] && \
    [ "$(tail -n 1 "${log}")" == "${status_prefix}${status_finish_successfully}" ]; then
    installation_guaranteed_successful="True"
fi
if [ ! -s "${log}" ]; then
    rm -f "${log}" || :
fi
if [ ! -s "${log}_err" ]; then
    rm -f "${log}_err" || :
fi
if [ "${say_goodbye}" != "False" ]; then
    if [ "${installation_guaranteed_successful}" == "True" ]; then
        printf "${esc_bold}${esc_green}${esc_concept} installation finished${esc_normal}\n"
    else
        printf "${esc_concept} installation finished${esc_normal}\n"
    fi
fi
trap : 0
